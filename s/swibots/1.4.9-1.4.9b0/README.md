# Comparing `tmp/swibots-1.4.9-py3-none-any.whl.zip` & `tmp/swibots-1.4.9b0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,15 +1,15 @@
-Zip file size: 153874 bytes, number of entries: 212
+Zip file size: 164401 bytes, number of entries: 221
 -rw-rw-rw-  2.0 fat      250 b- defN 23-Oct-28 11:47 swibots/__init__.py
--rw-rw-rw-  2.0 fat    12897 b- defN 23-Oct-30 14:13 swibots/bot_app.py
--rw-rw-rw-  2.0 fat     2441 b- defN 23-Oct-30 14:10 swibots/config.py
--rw-rw-rw-  2.0 fat     1696 b- defN 23-Oct-30 14:10 swibots/errors.py
+-rw-rw-rw-  2.0 fat    14647 b- defN 23-Dec-23 07:05 swibots/bot_app.py
+-rw-rw-rw-  2.0 fat     2430 b- defN 23-Nov-11 03:56 swibots/config.py
+-rw-rw-rw-  2.0 fat     1752 b- defN 23-Nov-10 16:00 swibots/errors.py
 -rw-rw-rw-  2.0 fat      856 b- defN 23-Oct-30 14:10 swibots/responses.py
--rw-rw-rw-  2.0 fat     1116 b- defN 23-Oct-28 11:47 swibots/types.py
--rw-rw-rw-  2.0 fat      170 b- defN 23-Oct-28 11:47 swibots/api/__init__.py
+-rw-rw-rw-  2.0 fat     1480 b- defN 23-Nov-08 12:21 swibots/types.py
+-rw-rw-rw-  2.0 fat      193 b- defN 23-Dec-23 07:47 swibots/api/__init__.py
 -rw-rw-rw-  2.0 fat     2681 b- defN 23-Oct-28 11:47 swibots/api/api_client.py
 -rw-rw-rw-  2.0 fat      110 b- defN 23-Oct-28 11:47 swibots/api/airdrop/__init__.py
 -rw-rw-rw-  2.0 fat      941 b- defN 23-Oct-28 11:47 swibots/api/airdrop/client.py
 -rw-rw-rw-  2.0 fat       57 b- defN 23-Oct-28 11:47 swibots/api/airdrop/controllers/__init__.py
 -rw-rw-rw-  2.0 fat     1201 b- defN 23-Oct-28 11:47 swibots/api/airdrop/controllers/tournament_controller.py
 -rw-rw-rw-  2.0 fat      151 b- defN 23-Oct-28 11:47 swibots/api/airdrop/methods/__init__.py
 -rw-rw-rw-  2.0 fat      608 b- defN 23-Jul-22 12:59 swibots/api/airdrop/methods/get_referral.py
@@ -18,72 +18,81 @@
 -rw-rw-rw-  2.0 fat     1929 b- defN 23-Oct-30 14:10 swibots/api/airdrop/models/referral.py
 -rw-rw-rw-  2.0 fat     1870 b- defN 23-Jul-20 21:02 swibots/api/airdrop/models/tournament.py
 -rw-rw-rw-  2.0 fat       94 b- defN 23-Oct-28 11:47 swibots/api/auth/__init__.py
 -rw-rw-rw-  2.0 fat     1509 b- defN 23-Oct-28 11:47 swibots/api/auth/auth_client.py
 -rw-rw-rw-  2.0 fat       67 b- defN 23-Oct-28 11:47 swibots/api/auth/methods/__init__.py
 -rw-rw-rw-  2.0 fat      669 b- defN 23-Oct-28 11:47 swibots/api/auth/methods/get_me.py
 -rw-rw-rw-  2.0 fat       59 b- defN 23-Jul-12 15:29 swibots/api/auth/models/__init__.py
--rw-rw-rw-  2.0 fat     4435 b- defN 23-Oct-28 11:47 swibots/api/auth/models/auth_user.py
--rw-rw-rw-  2.0 fat       86 b- defN 23-Jul-12 15:29 swibots/api/bot/__init__.py
+-rw-rw-rw-  2.0 fat     4435 b- defN 23-Dec-23 06:47 swibots/api/auth/models/auth_user.py
+-rw-rw-rw-  2.0 fat       86 b- defN 23-Dec-23 07:47 swibots/api/bot/__init__.py
 -rw-rw-rw-  2.0 fat     1403 b- defN 23-Oct-28 11:47 swibots/api/bot/bot_client.py
 -rw-rw-rw-  2.0 fat      137 b- defN 23-Aug-01 19:09 swibots/api/bot/controllers/__init__.py
--rw-rw-rw-  2.0 fat     2481 b- defN 23-Oct-28 11:47 swibots/api/bot/controllers/bot_controller.py
+-rw-rw-rw-  2.0 fat     3408 b- defN 23-Dec-23 09:38 swibots/api/bot/controllers/bot_controller.py
 -rw-rw-rw-  2.0 fat     2988 b- defN 23-Oct-30 12:17 swibots/api/bot/controllers/game_controller.py
 -rw-rw-rw-  2.0 fat      320 b- defN 23-Oct-28 11:47 swibots/api/bot/methods/__init__.py
--rw-rw-rw-  2.0 fat      858 b- defN 23-Oct-28 11:47 swibots/api/bot/methods/answer_callback_query.py
+-rw-rw-rw-  2.0 fat     1290 b- defN 23-Dec-23 09:17 swibots/api/bot/methods/answer_callback_query.py
 -rw-rw-rw-  2.0 fat      557 b- defN 23-Jul-12 15:29 swibots/api/bot/methods/delete_bot_info.py
 -rw-rw-rw-  2.0 fat     1744 b- defN 23-Oct-28 11:47 swibots/api/bot/methods/game_methods.py
--rw-rw-rw-  2.0 fat      600 b- defN 23-Sep-25 13:24 swibots/api/bot/methods/get_bot_info.py
--rw-rw-rw-  2.0 fat      633 b- defN 23-Jul-12 15:29 swibots/api/bot/methods/update_bot_info.py
--rw-rw-rw-  2.0 fat      152 b- defN 23-Oct-28 11:47 swibots/api/bot/models/__init__.py
--rw-rw-rw-  2.0 fat     1087 b- defN 23-Oct-28 11:47 swibots/api/bot/models/bot_command.py
--rw-rw-rw-  2.0 fat     1929 b- defN 23-Oct-28 11:47 swibots/api/bot/models/bot_info.py
+-rw-rw-rw-  2.0 fat      598 b- defN 23-Dec-04 13:01 swibots/api/bot/methods/get_bot_info.py
+-rw-rw-rw-  2.0 fat     1293 b- defN 23-Dec-11 09:12 swibots/api/bot/methods/update_bot_info.py
+-rw-rw-rw-  2.0 fat      210 b- defN 23-Dec-23 06:40 swibots/api/bot/models/__init__.py
+-rw-rw-rw-  2.0 fat     2182 b- defN 23-Nov-18 04:07 swibots/api/bot/models/bot_command.py
+-rw-rw-rw-  2.0 fat     3538 b- defN 23-Dec-23 07:14 swibots/api/bot/models/bot_info.py
 -rw-rw-rw-  2.0 fat     1617 b- defN 23-Oct-30 14:10 swibots/api/bot/models/game_info.py
+-rw-rw-rw-  2.0 fat     1308 b- defN 23-Dec-23 09:23 swibots/api/callback/AppPage.py
+-rw-rw-rw-  2.0 fat      886 b- defN 23-Dec-23 09:31 swibots/api/callback/Dropdown.py
+-rw-rw-rw-  2.0 fat     1404 b- defN 23-Dec-23 09:34 swibots/api/callback/Grid.py
+-rw-rw-rw-  2.0 fat     1249 b- defN 23-Dec-23 09:30 swibots/api/callback/ListItem.py
+-rw-rw-rw-  2.0 fat      217 b- defN 23-Dec-23 08:14 swibots/api/callback/__init__.py
+-rw-rw-rw-  2.0 fat      211 b- defN 23-Dec-23 07:59 swibots/api/callback/types.py
 -rw-rw-rw-  2.0 fat      111 b- defN 23-Aug-01 02:45 swibots/api/chat/__init__.py
--rw-rw-rw-  2.0 fat     6901 b- defN 23-Oct-28 11:47 swibots/api/chat/chat_client.py
--rw-rw-rw-  2.0 fat      311 b- defN 23-Oct-28 11:47 swibots/api/chat/controllers/__init__.py
+-rw-rw-rw-  2.0 fat     7198 b- defN 23-Nov-10 16:50 swibots/api/chat/chat_client.py
+-rw-rw-rw-  2.0 fat      402 b- defN 23-Nov-10 16:49 swibots/api/chat/controllers/__init__.py
 -rw-rw-rw-  2.0 fat     1412 b- defN 23-Oct-28 11:47 swibots/api/chat/controllers/chat_controller.py
--rw-rw-rw-  2.0 fat    17713 b- defN 23-Oct-31 18:19 swibots/api/chat/controllers/media_controller.py
--rw-rw-rw-  2.0 fat    24594 b- defN 23-Oct-30 22:02 swibots/api/chat/controllers/message_controller.py
+-rw-rw-rw-  2.0 fat    22934 b- defN 23-Nov-27 13:40 swibots/api/chat/controllers/media_controller.py
+-rw-rw-rw-  2.0 fat    27411 b- defN 23-Dec-11 09:10 swibots/api/chat/controllers/message_controller.py
+-rw-rw-rw-  2.0 fat     1451 b- defN 23-Nov-10 17:13 swibots/api/chat/controllers/organization_controller.py
 -rw-rw-rw-  2.0 fat     3849 b- defN 23-Oct-28 11:47 swibots/api/chat/controllers/sticker_controller.py
 -rw-rw-rw-  2.0 fat      351 b- defN 23-Oct-28 11:47 swibots/api/chat/events/__init__.py
--rw-rw-rw-  2.0 fat     2723 b- defN 23-Oct-08 15:24 swibots/api/chat/events/callback_query_event.py
+-rw-rw-rw-  2.0 fat     3065 b- defN 24-Jan-02 13:42 swibots/api/chat/events/callback_query_event.py
 -rw-rw-rw-  2.0 fat     2838 b- defN 23-Oct-28 11:47 swibots/api/chat/events/chat_event.py
--rw-rw-rw-  2.0 fat     2155 b- defN 23-Oct-28 11:47 swibots/api/chat/events/command_event.py
+-rw-rw-rw-  2.0 fat     2312 b- defN 23-Dec-11 09:07 swibots/api/chat/events/command_event.py
 -rw-rw-rw-  2.0 fat     2180 b- defN 23-Oct-28 11:47 swibots/api/chat/events/inline_query_event.py
--rw-rw-rw-  2.0 fat     2547 b- defN 23-Oct-28 11:47 swibots/api/chat/events/message_event.py
--rw-rw-rw-  2.0 fat     1678 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/__init__.py
+-rw-rw-rw-  2.0 fat     2412 b- defN 23-Nov-11 06:17 swibots/api/chat/events/message_event.py
+-rw-rw-rw-  2.0 fat     1758 b- defN 23-Nov-10 17:06 swibots/api/chat/methods/__init__.py
 -rw-rw-rw-  2.0 fat      684 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/answer_inline_query.py
 -rw-rw-rw-  2.0 fat      714 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/clear_conversation.py
 -rw-rw-rw-  2.0 fat      726 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/delete_message.py
 -rw-rw-rw-  2.0 fat      744 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/delete_messages_from_user.py
 -rw-rw-rw-  2.0 fat     1683 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/download_media.py
--rw-rw-rw-  2.0 fat     1204 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/edit_message.py
+-rw-rw-rw-  2.0 fat     2877 b- defN 23-Nov-08 13:21 swibots/api/chat/methods/edit_message.py
 -rw-rw-rw-  2.0 fat      714 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/flag_message.py
 -rw-rw-rw-  2.0 fat     1276 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/forward_message.py
--rw-rw-rw-  2.0 fat     1172 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_channel_chat_history.py
--rw-rw-rw-  2.0 fat      748 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_community_media_files.py
--rw-rw-rw-  2.0 fat      909 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_community_media_files_by_status.py
+-rw-rw-rw-  2.0 fat     1172 b- defN 23-Nov-11 12:37 swibots/api/chat/methods/get_channel_chat_history.py
+-rw-rw-rw-  2.0 fat      761 b- defN 23-Nov-11 12:16 swibots/api/chat/methods/get_community_media_files.py
+-rw-rw-rw-  2.0 fat     1190 b- defN 23-Nov-11 12:36 swibots/api/chat/methods/get_community_media_files_by_status.py
 -rw-rw-rw-  2.0 fat      671 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/get_flag_messages.py
 -rw-rw-rw-  2.0 fat     1122 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_group_chat_history.py
 -rw-rw-rw-  2.0 fat     1002 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/get_message.py
 -rw-rw-rw-  2.0 fat      744 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/get_messages.py
 -rw-rw-rw-  2.0 fat     1134 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_messages_between_users.py
 -rw-rw-rw-  2.0 fat      576 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_unread_messages_count.py
 -rw-rw-rw-  2.0 fat      947 b- defN 23-Oct-30 14:10 swibots/api/chat/methods/get_user.py
 -rw-rw-rw-  2.0 fat      810 b- defN 23-Jul-12 15:29 swibots/api/chat/methods/get_user_media_files.py
+-rw-rw-rw-  2.0 fat     2604 b- defN 23-Nov-10 17:06 swibots/api/chat/methods/organization_methods.py
 -rw-rw-rw-  2.0 fat      870 b- defN 23-Jul-27 13:23 swibots/api/chat/methods/pin_message.py
 -rw-rw-rw-  2.0 fat     4580 b- defN 23-Oct-28 13:09 swibots/api/chat/methods/send_message.py
 -rw-rw-rw-  2.0 fat     4836 b- defN 23-Oct-28 11:47 swibots/api/chat/methods/sticker_methods.py
--rw-rw-rw-  2.0 fat     5679 b- defN 23-Oct-30 22:10 swibots/api/chat/methods/upload_media.py
--rw-rw-rw-  2.0 fat      265 b- defN 23-Oct-28 11:47 swibots/api/chat/models/__init__.py
+-rw-rw-rw-  2.0 fat     5992 b- defN 23-Nov-08 13:07 swibots/api/chat/methods/upload_media.py
+-rw-rw-rw-  2.0 fat      291 b- defN 23-Nov-11 02:52 swibots/api/chat/models/__init__.py
 -rw-rw-rw-  2.0 fat      922 b- defN 23-Oct-28 11:47 swibots/api/chat/models/group_chat_history.py
 -rw-rw-rw-  2.0 fat     1025 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline_keyboard_button.py
--rw-rw-rw-  2.0 fat     2440 b- defN 23-Oct-30 12:18 swibots/api/chat/models/inline_markup.py
--rw-rw-rw-  2.0 fat    17930 b- defN 23-Oct-30 14:10 swibots/api/chat/models/message.py
+-rw-rw-rw-  2.0 fat     2470 b- defN 23-Dec-23 06:36 swibots/api/chat/models/inline_markup.py
+-rw-rw-rw-  2.0 fat    20097 b- defN 23-Dec-11 08:56 swibots/api/chat/models/message.py
+-rw-rw-rw-  2.0 fat     4564 b- defN 23-Nov-10 18:14 swibots/api/chat/models/organization.py
 -rw-rw-rw-  2.0 fat     4047 b- defN 23-Oct-30 14:10 swibots/api/chat/models/sticker.py
 -rw-rw-rw-  2.0 fat      575 b- defN 23-Jul-12 15:29 swibots/api/chat/models/inline/__init__.py
 -rw-rw-rw-  2.0 fat     1374 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline/base_typed_inline_query_result.py
 -rw-rw-rw-  2.0 fat     2569 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline/inline_query.py
 -rw-rw-rw-  2.0 fat     1929 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline/inline_query_answer.py
 -rw-rw-rw-  2.0 fat      982 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline/inline_query_result.py
 -rw-rw-rw-  2.0 fat     1241 b- defN 23-Oct-28 11:47 swibots/api/chat/models/inline/inline_query_result_article.py
@@ -94,22 +103,22 @@
 -rw-rw-rw-  2.0 fat      211 b- defN 23-Jul-12 15:29 swibots/api/chat/models/inline/types.py
 -rw-rw-rw-  2.0 fat       46 b- defN 23-Jul-12 15:29 swibots/api/common/__init__.py
 -rw-rw-rw-  2.0 fat       49 b- defN 23-Jul-12 15:29 swibots/api/common/events/__init__.py
 -rw-rw-rw-  2.0 fat     3001 b- defN 23-Aug-14 15:28 swibots/api/common/events/event.py
 -rw-rw-rw-  2.0 fat      187 b- defN 23-Oct-28 11:47 swibots/api/common/models/__init__.py
 -rw-rw-rw-  2.0 fat      538 b- defN 23-Oct-28 11:47 swibots/api/common/models/embed_inline_field.py
 -rw-rw-rw-  2.0 fat     3291 b- defN 23-Oct-30 14:10 swibots/api/common/models/embedded_media.py
--rw-rw-rw-  2.0 fat     4139 b- defN 23-Oct-30 14:10 swibots/api/common/models/media.py
--rw-rw-rw-  2.0 fat     2950 b- defN 23-Oct-28 11:47 swibots/api/common/models/user.py
+-rw-rw-rw-  2.0 fat     4949 b- defN 23-Nov-08 13:28 swibots/api/common/models/media.py
+-rw-rw-rw-  2.0 fat     2950 b- defN 23-Dec-23 07:04 swibots/api/common/models/user.py
 -rw-rw-rw-  2.0 fat     1205 b- defN 23-Oct-30 12:14 swibots/api/common/models/usertournament.py
 -rw-rw-rw-  2.0 fat       93 b- defN 23-Jul-12 15:29 swibots/api/community/__init__.py
 -rw-rw-rw-  2.0 fat     6412 b- defN 23-Oct-30 12:18 swibots/api/community/community_client.py
 -rw-rw-rw-  2.0 fat      315 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/__init__.py
 -rw-rw-rw-  2.0 fat     1082 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/ban_controller.py
--rw-rw-rw-  2.0 fat     1258 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/channel_controller.py
+-rw-rw-rw-  2.0 fat     1294 b- defN 23-Nov-17 07:50 swibots/api/community/controllers/channel_controller.py
 -rw-rw-rw-  2.0 fat     5039 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/community_controller.py
 -rw-rw-rw-  2.0 fat      839 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/group_controller.py
 -rw-rw-rw-  2.0 fat     2286 b- defN 23-Oct-30 12:17 swibots/api/community/controllers/permissions_controller.py
 -rw-rw-rw-  2.0 fat     3980 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/quest_controller.py
 -rw-rw-rw-  2.0 fat     1971 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/restrict_controller.py
 -rw-rw-rw-  2.0 fat     1789 b- defN 23-Oct-28 11:47 swibots/api/community/controllers/rolemember_controller.py
 -rw-rw-rw-  2.0 fat     1925 b- defN 23-Jul-12 15:29 swibots/api/community/controllers/roles_controller.py
@@ -151,37 +160,37 @@
 -rw-rw-rw-  2.0 fat     1510 b- defN 23-Jul-12 15:29 swibots/api/community/models/rolemember.py
 -rw-rw-rw-  2.0 fat     3256 b- defN 23-Jul-14 11:14 swibots/api/community/models/rolepermission.py
 -rw-rw-rw-  2.0 fat      268 b- defN 23-Jul-12 15:29 swibots/base/__init__.py
 -rw-rw-rw-  2.0 fat       67 b- defN 23-Oct-28 11:47 swibots/base/rest_controller.py
 -rw-rw-rw-  2.0 fat      423 b- defN 23-Oct-28 11:47 swibots/base/rest_request.py
 -rw-rw-rw-  2.0 fat      695 b- defN 23-Oct-28 11:47 swibots/base/rest_response.py
 -rw-rw-rw-  2.0 fat     5310 b- defN 23-Oct-28 11:47 swibots/base/switch_client.py
--rw-rw-rw-  2.0 fat     1621 b- defN 23-Oct-30 14:10 swibots/base/switch_object.py
+-rw-rw-rw-  2.0 fat     1884 b- defN 23-Nov-17 08:45 swibots/base/switch_object.py
 -rw-rw-rw-  2.0 fat      563 b- defN 23-Jul-12 15:29 swibots/base/switch_ws_async_client.py
 -rw-rw-rw-  2.0 fat      135 b- defN 23-Oct-28 11:47 swibots/bots/__init__.py
--rw-rw-rw-  2.0 fat     2924 b- defN 23-Oct-28 11:47 swibots/bots/bot.py
+-rw-rw-rw-  2.0 fat     2924 b- defN 23-Dec-23 07:07 swibots/bots/bot.py
 -rw-rw-rw-  2.0 fat     2112 b- defN 23-Oct-28 11:47 swibots/bots/bot_context.py
 -rw-rw-rw-  2.0 fat     1034 b- defN 23-Sep-12 14:43 swibots/bots/decorators/__init__.py
 -rw-rw-rw-  2.0 fat      598 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_callback_query.py
 -rw-rw-rw-  2.0 fat      582 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_channel_created.py
 -rw-rw-rw-  2.0 fat      602 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_channel_deleted.py
 -rw-rw-rw-  2.0 fat      599 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_channel_updated.py
--rw-rw-rw-  2.0 fat      633 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_command.py
+-rw-rw-rw-  2.0 fat      633 b- defN 23-Nov-11 03:50 swibots/bots/decorators/on_command.py
 -rw-rw-rw-  2.0 fat      602 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_community_updated.py
 -rw-rw-rw-  2.0 fat      594 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_group_created.py
 -rw-rw-rw-  2.0 fat      594 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_group_deleted.py
 -rw-rw-rw-  2.0 fat      592 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_group_updated.py
 -rw-rw-rw-  2.0 fat      548 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_inline_query.py
 -rw-rw-rw-  2.0 fat      592 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_member_joined.py
 -rw-rw-rw-  2.0 fat      546 b- defN 23-Oct-03 18:36 swibots/bots/decorators/on_member_left.py
 -rw-rw-rw-  2.0 fat      535 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_message.py
 -rw-rw-rw-  2.0 fat      601 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_unknown_command.py
 -rw-rw-rw-  2.0 fat      541 b- defN 23-Oct-28 11:47 swibots/bots/decorators/on_user_banned.py
 -rw-rw-rw-  2.0 fat       23 b- defN 23-Jul-12 15:29 swibots/bots/filters/__init__.py
--rw-rw-rw-  2.0 fat    10341 b- defN 23-Oct-30 14:10 swibots/bots/filters/filter.py
+-rw-rw-rw-  2.0 fat    10648 b- defN 23-Nov-12 02:34 swibots/bots/filters/filter.py
 -rw-rw-rw-  2.0 fat     1337 b- defN 23-Jul-12 15:29 swibots/bots/handlers/__init__.py
 -rw-rw-rw-  2.0 fat     1087 b- defN 23-Sep-12 19:16 swibots/bots/handlers/base_handler.py
 -rw-rw-rw-  2.0 fat     1016 b- defN 23-Jul-12 15:29 swibots/bots/handlers/callback_query_handler.py
 -rw-rw-rw-  2.0 fat      704 b- defN 23-Jul-12 15:29 swibots/bots/handlers/channel_created_handler.py
 -rw-rw-rw-  2.0 fat      711 b- defN 23-Jul-12 15:29 swibots/bots/handlers/channel_deleted_handler.py
 -rw-rw-rw-  2.0 fat      758 b- defN 23-Jul-12 15:29 swibots/bots/handlers/channel_updated_handler.py
 -rw-rw-rw-  2.0 fat     1621 b- defN 23-Oct-28 11:47 swibots/bots/handlers/command_handler.py
@@ -193,22 +202,22 @@
 -rw-rw-rw-  2.0 fat      870 b- defN 23-Oct-28 11:47 swibots/bots/handlers/inline_query_handler.py
 -rw-rw-rw-  2.0 fat      702 b- defN 23-Jul-12 15:29 swibots/bots/handlers/member_joined_handler.py
 -rw-rw-rw-  2.0 fat      697 b- defN 23-Jul-12 15:29 swibots/bots/handlers/member_left_handler.py
 -rw-rw-rw-  2.0 fat      996 b- defN 23-Oct-28 11:47 swibots/bots/handlers/message_handler.py
 -rw-rw-rw-  2.0 fat      897 b- defN 23-Oct-28 11:47 swibots/bots/handlers/unknown_command_handler.py
 -rw-rw-rw-  2.0 fat      693 b- defN 23-Jul-12 15:29 swibots/bots/handlers/user_banned_handler.py
 -rw-rw-rw-  2.0 fat      242 b- defN 23-Oct-28 11:47 swibots/utils/__init__.py
--rw-rw-rw-  2.0 fat     6075 b- defN 23-Oct-28 11:47 swibots/utils/rest_client.py
--rw-rw-rw-  2.0 fat     4740 b- defN 23-Oct-30 14:10 swibots/utils/types.py
+-rw-rw-rw-  2.0 fat     6075 b- defN 23-Nov-11 06:01 swibots/utils/rest_client.py
+-rw-rw-rw-  2.0 fat     4948 b- defN 23-Nov-12 03:57 swibots/utils/types.py
 -rw-rw-rw-  2.0 fat       50 b- defN 23-Jul-12 15:29 swibots/utils/ws/__init__.py
 -rw-rw-rw-  2.0 fat      154 b- defN 23-Jul-12 15:29 swibots/utils/ws/asyncstomp/__init__.py
--rw-rw-rw-  2.0 fat    10196 b- defN 23-Oct-28 11:47 swibots/utils/ws/asyncstomp/async_ws_client.py
+-rw-rw-rw-  2.0 fat    10397 b- defN 23-Dec-23 07:20 swibots/utils/ws/asyncstomp/async_ws_client.py
 -rw-rw-rw-  2.0 fat     1054 b- defN 23-Oct-30 12:14 swibots/utils/ws/asyncstomp/async_ws_subscription.py
 -rw-rw-rw-  2.0 fat      104 b- defN 23-Jul-12 15:29 swibots/utils/ws/common/__init__.py
 -rw-rw-rw-  2.0 fat     1699 b- defN 23-Oct-28 11:47 swibots/utils/ws/common/ws_frame.py
 -rw-rw-rw-  2.0 fat      439 b- defN 23-Oct-28 11:47 swibots/utils/ws/common/ws_message.py
--rw-rw-rw-  2.0 fat     1361 b- defN 23-Oct-31 18:20 swibots-1.4.9.dist-info/LICENSE.md
--rw-rw-rw-  2.0 fat     6046 b- defN 23-Oct-31 18:20 swibots-1.4.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Oct-31 18:20 swibots-1.4.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 23-Oct-31 18:20 swibots-1.4.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat    20654 b- defN 23-Oct-31 18:20 swibots-1.4.9.dist-info/RECORD
-212 files, 416410 bytes uncompressed, 120272 bytes compressed:  71.1%
+-rw-rw-rw-  2.0 fat     1361 b- defN 24-Jan-02 13:44 swibots-1.4.9b0.dist-info/LICENSE.md
+-rw-rw-rw-  2.0 fat     7138 b- defN 24-Jan-02 13:44 swibots-1.4.9b0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Jan-02 13:44 swibots-1.4.9b0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 24-Jan-02 13:44 swibots-1.4.9b0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat    21503 b- defN 24-Jan-02 13:44 swibots-1.4.9b0.dist-info/RECORD
+221 files, 454404 bytes uncompressed, 129443 bytes compressed:  71.5%
```

## zipnote {}

```diff
@@ -111,14 +111,32 @@
 
 Filename: swibots/api/bot/models/bot_info.py
 Comment: 
 
 Filename: swibots/api/bot/models/game_info.py
 Comment: 
 
+Filename: swibots/api/callback/AppPage.py
+Comment: 
+
+Filename: swibots/api/callback/Dropdown.py
+Comment: 
+
+Filename: swibots/api/callback/Grid.py
+Comment: 
+
+Filename: swibots/api/callback/ListItem.py
+Comment: 
+
+Filename: swibots/api/callback/__init__.py
+Comment: 
+
+Filename: swibots/api/callback/types.py
+Comment: 
+
 Filename: swibots/api/chat/__init__.py
 Comment: 
 
 Filename: swibots/api/chat/chat_client.py
 Comment: 
 
 Filename: swibots/api/chat/controllers/__init__.py
@@ -129,14 +147,17 @@
 
 Filename: swibots/api/chat/controllers/media_controller.py
 Comment: 
 
 Filename: swibots/api/chat/controllers/message_controller.py
 Comment: 
 
+Filename: swibots/api/chat/controllers/organization_controller.py
+Comment: 
+
 Filename: swibots/api/chat/controllers/sticker_controller.py
 Comment: 
 
 Filename: swibots/api/chat/events/__init__.py
 Comment: 
 
 Filename: swibots/api/chat/events/callback_query_event.py
@@ -210,14 +231,17 @@
 
 Filename: swibots/api/chat/methods/get_user.py
 Comment: 
 
 Filename: swibots/api/chat/methods/get_user_media_files.py
 Comment: 
 
+Filename: swibots/api/chat/methods/organization_methods.py
+Comment: 
+
 Filename: swibots/api/chat/methods/pin_message.py
 Comment: 
 
 Filename: swibots/api/chat/methods/send_message.py
 Comment: 
 
 Filename: swibots/api/chat/methods/sticker_methods.py
@@ -237,14 +261,17 @@
 
 Filename: swibots/api/chat/models/inline_markup.py
 Comment: 
 
 Filename: swibots/api/chat/models/message.py
 Comment: 
 
+Filename: swibots/api/chat/models/organization.py
+Comment: 
+
 Filename: swibots/api/chat/models/sticker.py
 Comment: 
 
 Filename: swibots/api/chat/models/inline/__init__.py
 Comment: 
 
 Filename: swibots/api/chat/models/inline/base_typed_inline_query_result.py
@@ -615,23 +642,23 @@
 
 Filename: swibots/utils/ws/common/ws_frame.py
 Comment: 
 
 Filename: swibots/utils/ws/common/ws_message.py
 Comment: 
 
-Filename: swibots-1.4.9.dist-info/LICENSE.md
+Filename: swibots-1.4.9b0.dist-info/LICENSE.md
 Comment: 
 
-Filename: swibots-1.4.9.dist-info/METADATA
+Filename: swibots-1.4.9b0.dist-info/METADATA
 Comment: 
 
-Filename: swibots-1.4.9.dist-info/WHEEL
+Filename: swibots-1.4.9b0.dist-info/WHEEL
 Comment: 
 
-Filename: swibots-1.4.9.dist-info/top_level.txt
+Filename: swibots-1.4.9b0.dist-info/top_level.txt
 Comment: 
 
-Filename: swibots-1.4.9.dist-info/RECORD
+Filename: swibots-1.4.9b0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## swibots/bot_app.py

```diff
@@ -3,14 +3,15 @@
 import asyncio
 import logging
 import shutil
 from contextlib import AbstractContextManager
 from typing import List, Optional, Callable
 import swibots
 from contextlib import suppress
+from pathlib import Path
 from signal import signal as signal_fn, SIGINT, SIGTERM, SIGABRT
 from io import BytesIO
 from swibots.bots import Bot
 from importlib import import_module
 from swibots.errors import SwitchError, CancelError
 from swibots.api.community.events import CommunityEvent
 from swibots.api.chat.events import ChatEvent
@@ -43,25 +44,27 @@
 
     """
 
     def __init__(
         self,
         token: str,
         bot_description: Optional[str] = None,
+        plugins: dict = None,
         auto_update_bot: Optional[bool] = True,
         loop: asyncio.AbstractEventLoop = None,
         receive_updates: Optional[bool] = True,
     ):
         """
         Initialize the client
 
         Args:
             token (:obj:`str`): The bot token.
             bot_description(:obj:`str`): The bot description.
-            auto_update_bot(:obj:`bool`): Whether to automatically update the bot description and the regitered commands.
+            auto_update_bot(:obj:`bool`): Whether to automatically update the bot description and the registered commands.
+            plugins(:obj:`dict`): plugin path to load, use as: dict(root="plugins")
             loop (:obj:`asyncio.AbstractEventLoop`): The asyncio loop to use (default: asyncio.get_event_loop()).
 
         """
         super().__init__()
         self.token = token
         if not token:
             raise TokenInvalidError(f"'token' for the bot can't be '{token}'")
@@ -75,19 +78,21 @@
         self._register_commands: List[BotCommand] = []
         self._bot_description = bot_description
         self.auto_update_bot = auto_update_bot
         self._loop = loop or asyncio.get_event_loop()
         self.user = self._loop.run_until_complete(
             self.get_me(user_type=self._user_type)
         )
+        self.name = self.user.user_name
         self._bot_id = self.user.id
         self._running = False
         self._user_type = Bot
         self.rest_client = RestClient()
         self.receive_updates = receive_updates
+        self.plugins = plugins or dict()
 
     @property
     def bot(self) -> "swibots.bots.Bot":
         """
         The bot user.
 
             Returns:
@@ -103,33 +108,83 @@
         Returns:
             :obj:`List[BaseHandler]`: The list of handlers.
         """
         if self._handlers is None:
             self._handlers = []
         return self._handlers
 
-    def __loadModule(self, path):
+    def load_path(self, path):
         baseName = os.path.basename(path)
         if baseName.startswith("__") or not baseName.endswith(".py"):
             return
         try:
             module_path = path[:-3].replace("\\", ".").replace("/", ".")
 
             return import_module(module_path)
         except Exception as er:
             LoaderLog.exception(er)
 
-    def load_plugins(self, plugins: List[str]):
-        for path in plugins:
-            if os.path.isfile(path):
-                self.__loadModule(path)
-                return
-            for root, __, files in os.walk(path):
-                for f in files:
-                    self.__loadModule(os.path.join(root, f))
+    def load_plugins(self):
+        if not self.plugins:
+            return
+        plugins = self.plugins.copy()
+
+        for option in ["include", "exclude"]:
+            if plugins.get(option, []):
+                plugins[option] = [
+                    (i.split()[0], i.split()[1:] or None) for i in self.plugins[option]
+                ]
+
+        root = plugins["root"]
+        include = plugins.get("include", [])
+        exclude = plugins.get("exclude", [])
+
+        count = 0
+
+        if not include:
+            for path in sorted(Path(root.replace(".", "/")).rglob("*.py")):
+                module_path = ".".join(path.parent.parts + (path.stem,))
+                try:
+                    module = import_module(module_path)
+                    count += 1
+                except Exception as er:
+                    log.exception(er)
+        else:
+            for path in include:
+                module_path = root + "." + path
+
+                try:
+                    module = import_module(module_path)
+                    count += 1
+                except ImportError:
+                    continue
+
+                if "__path__" in dir(module):
+                    continue
+
+        if exclude:
+            for path in exclude:
+                module_path = root + "." + path
+ 
+                try:
+                    module = import_module(module_path)
+                except ImportError:
+                    continue
+
+                if "__path__" in dir(module):
+                    continue
+
+        if count > 0:
+            log.info(
+                '[{}] Successfully loaded {} modules{} from "{}"'.format(
+                    self.name, count, "s" if count > 1 else "", root
+                )
+            )
+            return
+        log.warning('[%s] No modules loaded from "%s"', self.name, root)
 
     def set_bot_commands(self, command: BotCommand | List[BotCommand]) -> "BotApp":
         if isinstance(command, list):
             self._register_commands.extend(command)
         else:
             self._register_commands.append(command)
         asyncio.run_coroutine_threadsafe(self.update_bot_commands(), self._loop)
@@ -160,15 +215,15 @@
 
     async def update_bot_commands(self):
         # get all app commands
         commands = self._register_commands or []
         description = self._bot_description or ""
         # register the commands
         self._botinfo = BotInfo(
-            description=description, id=self._bot_id, commands=commands
+            description=description, id=self._bot_id, commands=commands,
         )
 
         self._botinfo = await self.update_bot_info(self._botinfo)
 
     async def _on_chat_service_start(self, _):
         await self.chat_service.subscribe_to_notifications(callback=self.on_chat_event)
 
@@ -300,14 +355,16 @@
                 return
             self._running = True
             """Starts the app"""
             log.info("ðŸš€ Starting app...")
 
             await self._validate_token()
 
+            self.load_plugins()
+
             if self.receive_updates:
                 try:
                     await self.chat_service.start()
                     if self.on_chat_service_start is not None:
                         await self.on_chat_service_start(self)
                 except Exception as e:
                     log.exception(e)
@@ -322,23 +379,21 @@
             await self._on_app_start()
 
             log.info("ðŸš€ App started!")
 
         except asyncio.CancelledError:
             self._running = False
 
-    async def _do_stop(self):
-        log.info("ðŸ›‘ Stopping app...")
-        await self._on_app_stop()
-        self._running = False
 
     async def stop(self):
         if not self._running:
             return
-        await self._do_stop()
+        log.info("ðŸ›‘ Stopping app...")
+        await self._on_app_stop()
+        self._running = False
 
     def __enter__(self):
         return self.start()
 
     def __exit__(self, *args):
         with suppress(ConnectionError):
             self.stop()
```

## swibots/config.py

```diff
@@ -23,17 +23,16 @@
         or "https://api-gateway.switch.pe/community-service",
         "WS_URL": os.getenv("COMMUNITY_SERVICE_WS_URL")
         or "wss://api-gateway.switch.pe/v1/websocket/community/ws",
     },
     "BACKBLAZE": {
         "BUCKET_ID": os.getenv("BACKBLAZE_BUCKET_ID") or "6b741c0f098034a18b190f11",
         "ACCOUNT_ID": os.getenv("BACKBLAZE_ACCOUNT_ID") or "004b4cf9041b9f10000000006",
-        "APPLICATION_KEY": os.getenv("BACKBLAZE_APPLICATION_KEY")
-        or "K004f/A7QmJJiQmMZsyW3yGvhVcIwd4",
-    },
+        "APPLICATION_KEY": os.getenv("BACKBLAZE_APPLICATION_KEY") or "K004f/A7QmJJiQmMZsyW3yGvhVcIwd4"
+    }
 }
 
 
 def get_config():
     return APP_CONFIG
```

## swibots/errors.py

```diff
@@ -1,8 +1,8 @@
-from typing import Tuple
+from typing import Tuple, Dict, Union
 
 
 def _lstrip_str(in_s: str, lstr: str) -> str:
     """
     Args:
         in_s (:obj:`str`): in string
         lstr (:obj:`str`): substr to strip from left side
@@ -16,17 +16,17 @@
 
 class SwitchError(Exception):
     """
     Base class for Switch errors.
     .. seealso:: :wiki:`Exceptions, Warnings and Logging <Exceptions%2C-Warnings-and-Logging>`
     """
 
-    def __init__(self, message: str):
+    def __init__(self, message: Union[str, Dict]):
         super().__init__()
-
+        message = str(message)
         msg = _lstrip_str(message, "Error: ")
         msg = _lstrip_str(msg, "[Error]: ")
         msg = _lstrip_str(msg, "Bad Request: ")
         if msg != message:
             # api_error - capitalize the msg...
             msg = msg.capitalize()
         self.message = msg
```

## swibots/types.py

```diff
@@ -30,7 +30,23 @@
 
 class MediaType(enum.Enum):
     IMAGE = 1
     VIDEO = 2
     AUDIO = 3
     DOCUMENT = 7
     STICKER = 200
+
+
+def GetMediaType(media_type: int):
+    try:
+        return {
+            1: "IMAGE",
+            2: "VIDEO",
+            3: "AUDIO",
+            4: "EMBED",
+            7: "FILE",
+            200: "STATIC_STICKER",
+            201: "ANIMATED_STICKER",
+            202: "VIDEO_STICKER"
+        }[media_type]
+    except KeyError:
+        return None
```

## swibots/api/__init__.py

```diff
@@ -1,7 +1,8 @@
 from .api_client import ApiClient
 from .chat import *
 from .auth import *
 from .community import *
 from .common import *
 from .bot import *
 from .airdrop import *
+from .callback import *
```

## swibots/api/bot/controllers/bot_controller.py

```diff
@@ -1,13 +1,14 @@
 import json
 import logging
 from typing import TYPE_CHECKING, List, Optional
 from swibots.api.bot.models import BotInfo
 from swibots.errors import SwitchError
 from swibots.utils.types import JSONDict
+from swibots.api.callback import AppPage
 
 if TYPE_CHECKING:
     from swibots.api.bot import BotClient
 
 log = logging.getLogger(__name__)
 
 BASE_PATH = "/v1/bots"
@@ -29,15 +30,15 @@
             bot_id (``str``): The bot id. Defaults to the current bot id.
 
         Returns:
             :obj:``~switch.api.bot.models.BotInfo``: The bot info
         """
         if bot_id is None:
             bot_id = self.client.user.id
-        response = await self.client.get(f"{BASE_PATH}/{bot_id}")
+        response = await self.client.get(BASE_PATH + "?botId=" + str(bot_id))
         return BotInfo.build_from_json(response.data)
 
     async def update_bot_info(self, bot_info: BotInfo) -> BotInfo:
         """Update bot info
 
         Parameters:
             bot_info (``~switch.api.bot.models.BotInfo``): The bot info to update
@@ -77,7 +78,32 @@
                 "text": text,
                 "url": url,
                 "showAlerts": show_alert,
                 "cacheTime": cache_time,
             },
         )
         return response.data
+
+    async def answer_ui_query(self, callback_id: str, callback: AppPage) -> bool:
+        data = callback.to_json_request()
+        data["callbackQueryId"] = callback_id
+        response = await self.client.post(f"{BASE_PATH}/callback/answer", data=data)
+        return response.data
+
+    async def set_welcome(
+        self,
+        text: str = None,
+        thumb: str = None,
+        button: str = None,
+        command: str = None,
+    ):
+        response = await self.client.post(
+            f"{BASE_PATH}/set-intro-message",
+            data={
+                "botId": str(self.client.user.id),
+                "welcomeImage": thumb,
+                "welcomeText": text,
+                "buttonName": button,
+                "buttonCommand": command,
+            },
+        )
+        return self.client.build_object(BotInfo, response.data)
```

## swibots/api/bot/methods/answer_callback_query.py

```diff
@@ -1,10 +1,10 @@
 from typing import Type, TypeVar, Optional, List
 import swibots
-from swibots.api.bot.models import GameInfo
+from swibots.api.callback import AppPage
 
 
 class AnswerCallback:
     async def answer_callback_query(
         self: "swibots.ApiClient",
         query_id: str,
         text: Optional[str] = None,
@@ -21,7 +21,21 @@
         url: str
         show_alert: bool - whether to display popup
         cache_time: int - cache time
         """
         return await self.bots_service.bots.answer_callback_query(
             query_id, text=text, url=url, show_alert=show_alert, cache_time=cache_time
         )
+
+    async def answer_ui_query(
+        self: "swibots.ApiClient", query_id: str, callback: AppPage
+    ) -> bool:
+        """Answer UI Query
+
+        Args:
+            query_id (str): _description_
+            callback (AppPage): Callback component.
+
+        Returns:
+            Bool: whether callback was sent or not
+        """
+        return await self.bots_service.bots.answer_ui_query(query_id, callback=callback)
```

## swibots/api/bot/methods/get_bot_info.py

 * *Ordering differences only*

```diff
@@ -11,8 +11,8 @@
             bot_id (``str``): The bot id. Defaults to the current bot id.
 
         Returns:
             :obj:``~switch.api.bot.models.BotInfo``: The bot info
 
         This functions does the same as :meth:`~switch.api.bot.controllers.BotController.get_bot_info`.
         """
-        return await self.bots_service.bots.get_bot_info(bot_id=bot_id)
+        return await self.bots_service.bots.get_bot_info(bot_id=bot_id)
```

## swibots/api/bot/methods/update_bot_info.py

```diff
@@ -12,7 +12,24 @@
 
         Returns:
             :obj:``~switch.api.bot.models.BotInfo``: The bot info
 
         This functions does the same as :meth:`~switch.api.bot.controllers.BotController.update_bot_info`.
         """
         return await self.bots_service.bots.update_bot_info(bot_info=bot_info)
+
+
+    async def set_welcome(self: "swibots.ApiClient", text: str = None, thumb: str = None, button: str = None,
+                          command: str = None):
+        """Set bot welcome message
+
+        Args:
+            text (str, optional): welcome text
+            thumb (str, optional): welcome image
+            button (str, optional): button title
+            command (str, optional): button command
+
+        Returns:
+            `BotInfo`: updated bot info
+        """
+        return await self.bots_service.bots.set_welcome(text=text, thumb=thumb, button=button,
+                                                        command=command)
```

## swibots/api/bot/models/__init__.py

```diff
@@ -1,5 +1,5 @@
-from .bot_command import BotCommand
-from .bot_info import BotInfo
+from .bot_command import BotCommand, BotSubCommand
+from .bot_info import BotInfo, BotWelcome
 from .game_info import GameInfo
 
-__all__ = ["BotCommand", "BotInfo", "GameInfo"]
+__all__ = ["BotCommand", "BotInfo", "GameInfo", "BotSubCommand", "BotWelcome"]
```

## swibots/api/bot/models/bot_command.py

```diff
@@ -1,34 +1,66 @@
-from typing import Optional
+import swibots
+from typing import Optional, List, Dict
 from swibots.base import SwitchObject
 from swibots.utils.types import JSONDict
 
 
 class BotCommand(SwitchObject):
     def __init__(
         self,
         command: Optional[str] = None,
         description: Optional[str] = None,
         channel: Optional[bool] = False,
+        subcommands: Optional[List["BotSubCommand"]] = None,
     ):
         self.active = None
         self.bot_id = None
         self.command = command
         self.description = description
         self.channel = channel
+        self.subcommands = subcommands
 
     def from_json(self, data: JSONDict) -> "BotCommand":
         if data is not None:
             self.bot_id = data.get("botId")
             self.command = data.get("command")
             self.description = data.get("description") or data.get("commandDescription")
             self.channel = data.get("channel")
             self.active = data.get("active")
+            self.subcommands = []
+
+            for subcommand, value in data.get("subCommands", {}).items():
+                self.subcommands.append(
+                    BotSubCommand(
+                        command=subcommand, options=value[0] if value else None
+                    )
+                )
         return self
 
     def to_json(self) -> JSONDict:
+        subcommands = {}
+        for command in self.subcommands or []:
+            opts = [command.options] if command.options else []
+            subcommands[command.command] = opts
         return {
             "botId": self.bot_id,
             "command": self.command,
             "description": self.description,
             "channel": self.channel,
+            "subCommands": subcommands,
         }
+
+
+class BotSubCommand(SwitchObject):
+    def __init__(
+        self,
+        app: "swibots.App" = None,
+        command: Optional[str] = None,
+        options: Dict = None,
+        **kwargs
+    ):
+        super().__init__(app, **kwargs)
+        self.command = command
+        self.options = options
+
+    def to_json(self) -> JSONDict:
+        return {self.command: [self.options] if self.options else None}
```

## swibots/api/bot/models/bot_info.py

```diff
@@ -1,11 +1,43 @@
 from typing import TYPE_CHECKING, List, Optional
 from swibots.api.common.models import User
 from swibots.utils.types import JSONDict
+from swibots.base import SwitchObject
 from .bot_command import BotCommand
+from typing import Dict, Any
+
+
+class BotWelcome(SwitchObject):
+    def __init__(
+        self,
+        text: Optional[str] = None,
+        button: Optional[str] = None,
+        command: Optional[str] = None,
+        thumb: Optional[str] = None,
+    ):
+        self.text = text
+        self.thumb = thumb
+        self.button = button
+        self.command = command
+
+    def to_json(self) -> JSONDict:
+        return {
+            "welcomeImage": self.thumb,
+            "welcomeText": self.text,
+            "buttonName": self.button,
+            "buttonCommand": self.command,
+        }
+    
+    def from_json(self, data: Dict[str, Any] | None) -> Any:
+        if data:
+            self.thumb = data.get("welcomeImage")
+            self.text = data.get("welcomeText")
+            self.button = data.get("buttonName")
+            self.command = data.get("buttonCommand")
+        return self
 
 
 class BotInfo(User):
     def __init__(
         self,
         id: Optional[str] = None,
         name: Optional[str] = None,
@@ -14,44 +46,61 @@
         active: Optional[bool] = None,
         deleted: Optional[bool] = None,
         role_info: Optional[str] = None,
         admin: Optional[bool] = None,
         is_bot: Optional[bool] = None,
         commands: Optional[List[BotCommand]] = None,
         description: Optional[str] = None,
+        welcome: BotWelcome = None,
+        source_code: Optional[str] = None,
     ):
         super().__init__(
             id=id,
             name=name,
             username=username,
             image_url=image_url,
             active=active,
             deleted=deleted,
             role_info=role_info,
             admin=admin,
             is_bot=is_bot,
         )
         self.commands: List[BotCommand] = commands or []
         self.description: Optional[str] = description
+        self.source_code = source_code
+        self.welcome = welcome
 
     def to_json_request(self) -> JSONDict:
-        return {
+        data = {
             "commands": [command.to_json() for command in self.commands],
             "description": self.description,
+            "sourceCode": self.source_code,
         }
+        if self.welcome:
+            data.update(self.welcome.to_json())
+        return data
 
     def from_json(self, data: Optional[JSONDict] = None) -> "BotInfo":
         super().from_json(data)
         if data is not None:
             self.commands = [
                 BotCommand().from_json(x) for x in data.get("commands", [])
             ]
             self.description = data.get("description")
+            self.welcome = BotWelcome(
+                data.get("welcomeText"),
+                data.get("buttonName"),
+                data.get("buttonCommand"),
+                data.get("welcomeImage"),
+            )
+            self.source_code = data.get("sourceCode")
         return self
 
     def to_json(self) -> JSONDict:
         data = super().to_json()
         if not data.get("commands"):
             data["commands"] = [x.to_json() for x in self.commands]
         if not data.get("description"):
             data["description"] = self.description
+        if self.welcome:
+            data.update(self.welcome.to_json())
         return data
```

## swibots/api/chat/chat_client.py

```diff
@@ -2,14 +2,15 @@
 import logging
 from typing import Tuple, Optional, List
 from swibots.api.chat.controllers import (
     MessageController,
     ChatController,
     MediaController,
     StickerController,
+    OrganizationController
 )
 from swibots.api.chat.events import (
     ChatEvent,
     CallbackQueryEvent,
     MessageEvent,
     CommandEvent,
     InlineQueryEvent,
@@ -54,24 +55,31 @@
         base_url = base_url or get_config()["CHAT_SERVICE"]["BASE_URL"]
         self._ws_url = ws_url or get_config()["CHAT_SERVICE"]["WS_URL"]
         super().__init__(app, base_url)
         self._messages: MessageController = None
         self._post: ChatController = None
         self._media: MediaController = None
         self._stickers: StickerController = None
+        self._organization: OrganizationController = None
         self._ws: SwitchWSAsyncClient = None
         self._started = False
 
     @property
     def ws(self) -> SwitchWSAsyncClient:
         if self._ws is None:
             self._ws = SwitchWSAsyncClient(self._ws_url, self.token)
         return self._ws
 
     @property
+    def organization(self) -> OrganizationController:
+        if self._organization is None:
+            self._organization = OrganizationController(self)
+        return self._organization
+
+    @property
     def stickers(self) -> StickerController:
         if self._stickers is None:
             self._stickers = StickerController(self)
         return self._stickers
 
     @property
     def messages(self) -> MessageController:
```

## swibots/api/chat/controllers/__init__.py

```diff
@@ -1,11 +1,13 @@
 from .message_controller import MessageController
 from .chat_controller import ChatController
 from .media_controller import MediaController
 from .sticker_controller import StickerController
+from .organization_controller import OrganizationController
 
 __all__ = [
     "MessageController",
     "ChatController",
     "MediaController",
     "StickerController",
+    "OrganizationController"
 ]
```

## swibots/api/chat/controllers/media_controller.py

```diff
@@ -1,20 +1,22 @@
-import asyncio
+import asyncio, aiofiles
 import os, tempfile
-import json, mimetypes
-import logging, base64
+import json, mimetypes, re
+from datetime import datetime
+import logging, base64, random
 from io import BytesIO
 import json, mimetypes
 import logging, hashlib
 from uuid import uuid1
-from typing import Union, Dict
+import httpx
+from typing import Union
 from io import BytesIO
 import uuid
 from httpx import AsyncClient
-from typing import TYPE_CHECKING, List, Optional
+from typing import TYPE_CHECKING, Optional
 
 from swibots.errors import UnknownBackBlazeError
 from swibots.utils.types import (
     UploadProgressCallback,
     DownloadProgressCallback,
     IOClient,
     UploadProgress,
@@ -40,116 +42,121 @@
 headers = {}
 headers["Authorization"] = (
     "Basic " + base64.b64encode(f"{account_id}:{application_key}".encode()).decode()
 )
 headers["accept"] = "application/json"
 
 MAX_THUMB_SIZE = 1024 * 20
+logging.getLogger("httpx").setLevel(logging.ERROR)
 
 
 class MediaController:
     """Media controller
     This controller is used to communicate with the media endpoints.
     """
 
+    MIN_WAIT = 3
+    MAX_WAIT = 7
+
     def __init__(self, client: "ChatClient"):
         self.client = client
         self.__token = None
-        self._client = AsyncClient(timeout=None, verify=False)
         self._min_part_size = 5000000
 
     async def getAccountInfo(self):
-        if self.__token:
-            return
-        response = await self._client.get(
-            "https://api.backblazeb2.com/b2api/v2/b2_authorize_account", headers=headers
+        response = await self.request(
+            "https://api.backblazeb2.com/b2api/v2/b2_authorize_account",
+            headers=headers,
+            method="GET",
         )
         data = response.json()
         if token := data.get("authorizationToken"):
             self.__token = token
         log.debug(data)
-        self._min_part_size = data.get("absoluteMinimumPartSize")
-        return data
+        if min_size := data.get("absoluteMinimumPartSize"):
+            self._min_part_size = min_size
+
+        return self.__token
 
     async def file_to_response(
         self,
         path: str | BytesIO,
         mime_type=None,
         file_name=None,
         content: bytes = None,
         callback=None,
         callback_args=None,
+        file_size=None,
         remove: bool = None,
     ):
-        await self.getAccountInfo()
+        token = self.__token or await self.getAccountInfo()
         Isbytes = isinstance(path, BytesIO)
 
         if not mime_type:
             mime_type = (
                 mimetypes.guess_type(path.name if Isbytes else path)[0]
                 or "application/octet-stream"
             )
 
         head = {
             "Content-Type": "application/json",
-            "Authorization": self.__token,
+            "Authorization": token,
         }
-        rsp = await self._client.get(
+        rsp = await self.request(
             f"https://api004.backblazeb2.com/b2api/v2/b2_get_upload_url?bucketId={bucket_id}",
+            method="GET",
             headers=head,
         )
 
         response_data = rsp.json()
         if not response_data.get("authorizationToken"):
             raise UnknownBackBlazeError(response_data)
         token = response_data["authorizationToken"]
 
-        if Isbytes:
-            file_source = path
-        else:
-            file_source = open(path, "rb")
+        respp = rsp.json()
+        if not respp.get("uploadUrl"):
+            raise UnknownBackBlazeError(respp)
 
-        if not content:
-            content = file_source.read()
-        else:
-            file_source.close()
-            if remove:
-                os.remove(path)
-        file_sha1 = hashlib.sha1(content).hexdigest()
+        with path if Isbytes else open(path, "rb") as f:
+            content = f.read()
+            file_sha1 = hashlib.sha1(content).hexdigest()
 
-        headers = {
-            "Authorization": token,
-            "X-Bz-File-Name": file_name,
-            "Content-Type": mime_type,
-            "X-Bz-Content-Sha1": file_sha1,
-            "Content-Length": str(len(content)),
-        }
+            headers = {
+                "Authorization": token,
+                "X-Bz-File-Name": file_name,
+                "Content-Type": mime_type,
+                "X-Bz-Content-Sha1": file_sha1,
+                "Content-Length": str(len(content)),
+            }
 
-        respp = rsp.json()
-        if not response_data.get("uploadUrl"):
-            raise UnknownBackBlazeError(respp)
+            rsp = await self.request(
+                respp["uploadUrl"],
+                headers=headers,
+                data=content,
+            )
+            if Isbytes:
+                path = BytesIO(content)
+                path.name = file_name
+        if remove:
+            os.remove(path)
 
-        rsp = await self._client.post(
-            respp["uploadUrl"],
-            headers=headers,
-            data=content,
-        )
         file_response = rsp.json()
         if "contentLength" in file_response:
             if callback:
                 progress = UploadProgress(
                     path=path,
                     callback=callback,
                     callback_args=callback_args,
                     client=IOClient(),
+                    size=file_size,
                 )
                 await progress.bytes_readed(file_response["contentLength"])
         else:
             log.error(file_response)
-        return file_response
+        return path, file_response
 
     async def generate_from_ffmpeg(self, path: str, hw: int):
         log.debug("checking for ffmpeg")
         ffmpeg_path = os.getenv("FFMPEG_PATH") or "ffmpeg"
         proc = await asyncio.create_subprocess_exec(
             ffmpeg_path, stderr=asyncio.subprocess.PIPE
         )
@@ -182,51 +189,55 @@
 
     async def get_thumb_url(
         self, path: Union[str, BytesIO], for_document: bool = False, *args, **kwargs
     ) -> str:
         if not path:
             return
         __remove = False
-        mime_type = mimetypes.guess_type(path)[0]
+        mime_type = (
+            mimetypes.guess_type(path.name if isinstance(path, BytesIO) else path)[0]
+            or "application/octet-stream"
+        )
         hw = 30 if for_document else 100
         if "video/" in mime_type:
             path = await self.generate_from_ffmpeg(path, hw)
             if not path:
                 return
             __remove = True
         elif not "image/" in mime_type:
             return
         content = None
         if isinstance(path, str):
             size = os.path.getsize(path)
             name = path
         else:
-            content = path.getvalue()
-            size = len(content)
+            size = path.getbuffer().nbytes
             name = path.name
 
         if size > MAX_THUMB_SIZE:
             try:
                 from PIL import Image
 
                 log.info(f"creating thumb for {path}")
 
                 img = Image.open(content or path)
                 img.thumbnail((hw, hw))
                 path = tempfile.gettempdir() + f"/{uuid.uuid1()}.png"
                 __remove = True
                 img.save(path)
             except ImportError:
-                log.warning("thumb size is greater than 20kb, ignoring thumb")
+                log.warning(
+                    "[Pillow is not installed] and [thumb size is greater than 20kb], ignoring thumb"
+                )
                 return
 
         _, ext = os.path.splitext(name)
         file_name = f"{uuid.uuid1()}{ext}"
 
-        file = await self.file_to_response(
+        path, file = await self.file_to_response(
             path, mime_type, file_name, content=content, remove=__remove
         )
         return f"https://f004.backblazeb2.com/file/switch-bucket/{file['fileName']}"
 
     async def upload_media(
         self,
         path: str | BytesIO,
@@ -239,14 +250,15 @@
         callback: UploadProgressCallback = None,
         callback_args: Optional[tuple] = None,
         auto_thumb: Optional[bool] = True,
         part_size: int = int(os.getenv("UPLOAD_PART_SIZE", 0)),
         task_count: int = int(os.getenv("UPLOAD_TASKS", 0)),
         min_file_size: int = None,
         for_document: bool = False,
+        retries: int = 10,
     ) -> Media:
         """Upload media to switch
 
         Args:
             path (str | BytesIO): path to upload
             caption (Optional[str], optional): caption of media Defaults to None.
             description (Optional[str], optional): file name of media. Defaults to None.
@@ -259,21 +271,21 @@
             task_count (int, optional): number of tasks while uploading, Defaults to None.
 
         Returns:
             Media:
         """
 
         if not min_file_size:
-            min_file_size = self._min_part_size
+            min_file_size = 100 * 1024 * 1024
 
         if not part_size:
             part_size = self._min_part_size
 
         if not task_count:
-            task_count = 1
+            task_count = 5
 
         if part_size < self._min_part_size:
             log.warning(
                 f"part_size cant be smaller than minimum [{self._min_part_size}]"
             )
             part_size = self._min_part_size
 
@@ -281,53 +293,59 @@
             if isinstance(path, BytesIO):
                 file_name = path.name
             else:
                 file_name = path
 
         if not mime_type:
             mime_type = mimetypes.guess_type(file_name)[0] or "application/octet-stream"
-
         log.debug(f"Sending request to backblaze: {path}")
         _is_bytesio = isinstance(path, BytesIO)
 
         if not _is_bytesio:
             size = os.path.getsize(path)
         else:
-            content = path.getvalue()
-            size = len(content)
-            path = BytesIO(content)
+            size = path.getbuffer().nbytes
 
         _, ext = os.path.splitext(path.name if _is_bytesio else path)
         file_name = f"{uuid.uuid1()}{ext}"
 
-        if size > min_file_size and size > self._min_part_size:
+        if (
+            size > min_file_size
+            and size > self._min_part_size
+            and (size // part_size) > 1
+        ):
             file_response = await self.upload_large_file(
                 path,
                 callback=callback,
                 content_type=mime_type,
                 file_name=file_name,
                 callback_args=callback_args,
                 part_size=part_size,
                 task_count=task_count,
                 file_size=size,
+                file_info={
+                    "timestamp": str(datetime.now().timestamp()),
+                    "uploaded_by": str(self.client.user.id),
+                },
+                retries=retries,
             )
         else:
-            file_response = await self.file_to_response(
-                path, mime_type, file_name, callback=callback
+            path, file_response = await self.file_to_response(
+                path, mime_type, file_name, callback=callback, file_size=size
             )
-
+        if not file_response.get("fileName"):
+            raise UnknownBackBlazeError(file_response)
         url = f"https://f004.backblazeb2.com/file/switch-bucket/{file_response['fileName']}"
         try:
             thumbUrl = await self.get_thumb_url(
                 thumb or (path if auto_thumb else None), for_document
             )
         except Exception as er:
             log.exception(er)
             thumbUrl = None
-
         media = {
             "caption": caption,
             "description": description,
             "mimeType": mime_type,
             "fileSize": file_response.get("size", size),
             "fileName": file_response["fileName"],
             "downloadUrl": url,
@@ -335,176 +353,285 @@
             "mediaType": media_type,
             "sourceUri": file_response["fileId"],
             "checksum": file_response["contentSha1"],
             "ownerId": self.client.app.user.id,
         }
         return self.client.build_object(Media, media)
 
+    async def request(self, url: str, method: str = "POST", **kwargs):
+        async with AsyncClient(
+            verify=False, timeout=None, headers=kwargs.get("headers")
+        ) as client:
+            resp = await (client.post if method == "POST" else client.get)(
+                url, **kwargs
+            )
+            message = resp.json()
+            if message.get("code") == "expired_auth_token":
+                log.error("Expired auth token, retrying")
+                token = await self.getAccountInfo()
+                headers = kwargs.get("headers") or {}
+                headers["Authorization"] = token
+                kwargs["headers"] = headers
+                return await self.request(url, method, **kwargs)
+            elif message.get("code") == "service_unavailable":
+                log.error(message)
+                randomTime = random.randint(self.MIN_WAIT, self.MAX_WAIT)
+                log.info(f"Waiting for {randomTime} before retry!")
+                await asyncio.sleep(randomTime)
+                return await self.request(url, method, **kwargs)
+            return resp
+
     async def __upload_file(
         self,
         token,
         part_number,
-        chunk,
+        path,
+        upl_size,
+        part_size,
         fileId: str,
         progress: UploadProgress,
-        partHash: Dict,
-        retries: int = 1,
+        retries: int = 10,
+        wait_factor: int = 6,
     ):
-        sha1_checksum = hashlib.sha1(chunk).hexdigest()
-
-        respp = await self._client.post(
-            f"https://api004.backblazeb2.com/b2api/v2/b2_get_upload_part_url",
-            json={"fileId": fileId},
-            headers={"Authorization": token},
-        )
-        resp_data = respp.json()
-        if respp.status_code != 200:
-            logger.error("on Part url")
-            logger.error(resp_data)
+        async with aiofiles.open(path, "rb") as f:
+            for _ in range(retries):
+                try:
+                    respp = await self.request(
+                        f"https://api004.backblazeb2.com/b2api/v2/b2_get_upload_part_url",
+                        json={"fileId": fileId},
+                        headers={"Authorization": token},
+                        timeout=30,
+                    )
+                    break
+                except Exception as er:
+                    log.debug(er)
+                    log.error(er)
+                    if _ == (retries - 1):
+                        raise er
 
-        token = resp_data["authorizationToken"]
-        upload_part_url = resp_data["uploadUrl"]
-        for _ in range(retries + 1):
-            try:
-                respp = await self._client.post(
-                    upload_part_url,
-                    data=chunk,
-                    headers={
-                        "Authorization": token,
-                        "X-Bz-Part-Number": str(part_number),
-                        "X-Bz-Content-Sha1": sha1_checksum,
-                    },
-                )
-                resp_data = respp.json()
-                if respp.status_code != 200:
-                    logger.error("onUpload")
-                    logger.error(resp_data)
-                break
-            except Exception as er:
-                log.exception(er)
-        hash = resp_data["contentSha1"]
-        partHash[hash] = resp_data["partNumber"]
-        await progress.bytes_readed(resp_data["contentLength"])
+            resp_data = respp.json()
+            if respp.status_code != 200:
+                logger.error("on Part url")
+                logger.error(resp_data)
+                raise UnknownBackBlazeError(resp_data)
+
+            token = resp_data["authorizationToken"]
+            upload_part_url = resp_data["uploadUrl"]
+
+            await f.seek(upl_size)
+            chunk = await f.read(part_size)
+
+            for _ in range(retries + 1):
+                if _:
+                    log.info(f"Retrying upload [{path}][{upl_size}:{part_size}]")
+                try:
+                    respp = await self.request(
+                        upload_part_url,
+                        data=chunk,
+                        headers={
+                            "Authorization": token,
+                            "X-Bz-Part-Number": str(part_number),
+                            "X-Bz-Content-Sha1": hashlib.sha1(chunk).hexdigest(),
+                        },
+                    )
+                    resp_data = respp.json()
+                    if resp_data.get("code") == "service_unavailable":
+                        log.error(resp_data)
+                        log.info(f"Waiting for {_ * wait_factor}")
+                        await asyncio.sleep(_ * wait_factor)
+                        continue
+                    if respp.status_code != 200:
+                        logger.error("onUpload")
+                        logger.error(resp_data)
+                    hash = resp_data["contentSha1"]
+                    await progress.bytes_readed(resp_data["contentLength"])
+                    return hash, resp_data["partNumber"]
+                except (httpx.WriteError, httpx.ReadError) as er:
+                    log.exception(er)
+                    log.error(er.request)
+                except Exception as er:
+                    log.exception(er)
 
     async def upload_large_file(
         self,
         path: str | BytesIO,
         callback,
         content_type,
         file_name,
         file_info=None,
         callback_args=None,
         part_size=None,
         task_count=None,
         file_size=None,
+        retries: int = None,
     ):
         log.info("getting account info")
-        await self.getAccountInfo()
+        token = await self.getAccountInfo()
 
-        client = IOClient()
         progress = UploadProgress(
             path=path,
             callback=callback,
             callback_args=callback_args,
-            client=client,
+            client=IOClient(),
             size=file_size,
         )
         if isinstance(path, BytesIO) and not file_name:
             file_name = path.name
+        upl_size = 0
+        head = {
+            "Content-Type": content_type,
+            "X-Bz-File-Name": file_name,
+            "Authorization": token,
+        }
+        data = {
+            "fileName": file_name,
+            "contentType": content_type,
+            "bucketId": bucket_id,
+            "fileInfo": file_info,
+        }
+        partHash = {}
+        logger.info("start large file")
+        respp = await self.request(
+            "https://api004.backblazeb2.com/b2api/v2/b2_start_large_file",
+            headers=head,
+            data=json.dumps(data),
+        )
+        if respp.status_code != 200:
+            logger.error("on large file")
+            logger.error(respp.json())
+            raise UnknownBackBlazeError(respp.json())
+
+        logger.debug(respp.json())
+
+        fileId = respp.json()
+
+        if not fileId.get("fileId"):
+            raise UnknownBackBlazeError(fileId)
+
+        fileId = fileId["fileId"]
+        part_number = 1
+        queue = asyncio.Queue()
+
+        async def runFromQueue():
+            while queue.qsize():
+                task = await queue.get()
+                try:
+                    hash, part_number = await task
+                except Exception as er:
+                    log.exception(er)
+                    continue
+                partHash[hash] = part_number
 
-        with open(path, "rb") if isinstance(path, str) else path as file:
-            head = {
-                "Content-Type": content_type,
-                "X-Bz-File-Name": file_name,
-                "Authorization": self.__token,
-            }
-            data = {
-                "fileName": file_name,
-                "contentType": content_type,
-                "bucketId": bucket_id,
-                "fileInfo": file_info,
-            }
-            partHash = {}
-            logger.info("start large file")
-            respp = await self._client.post(
-                "https://api004.backblazeb2.com/b2api/v2/b2_start_large_file",
-                headers=head,
-                data=json.dumps(data),
-            )
-            if respp.status_code != 200:
-                logger.error("on large file")
-                logger.error(respp.json())
-                raise UnknownBackBlazeError(respp.json())
-
-            logger.debug(respp.json())
-
-            fileId = respp.json()
-
-            if not fileId.get("fileId"):
-                raise UnknownBackBlazeError(fileId)
-
-            fileId = fileId["fileId"]
-            part_number = 1
-            tasks = []
-            while True:
-                chunk = file.read(part_size)
-                if not chunk:
-                    break
-
-                tsk = asyncio.create_task(
+        try:
+            while upl_size < file_size:
+                await queue.put(
                     self.__upload_file(
-                        self.__token,
+                        token,
                         part_number,
-                        chunk,
+                        path,
+                        upl_size,
+                        part_size,
                         fileId,
                         progress,
-                        partHash,
+                        retries=retries,
                     )
                 )
-                tasks.append(tsk)
-                if len(tasks) == task_count:
-                    await asyncio.gather(*tasks)
-                    tasks.clear()
-
                 part_number += 1
-        if tasks:
-            await asyncio.gather(*tasks)
+                upl_size += part_size
+        except Exception as er:
+            log.exception(er)
+        qTask = [asyncio.create_task(runFromQueue()) for _ in range(task_count)]
+
+        try:
+            await asyncio.wait(qTask)
+        except Exception as er:
+            log.exception(er)
+
+        for q in qTask:
+            if q.done() and (exc := q.exception()):
+                log.exception(exc)
+            if not q.done():
+                q.cancel()
+
+        if not partHash:
+            raise Exception("parts are not found!")
+        response = await self.__finish_large_file(
+            partHash, fileId, path, part_size=part_size, progress=progress, token=token
+        )
+        return response
+
+    async def __finish_large_file(
+        self, partHash, fileId, path, part_size, progress, token, retry_count: int = 0
+    ):
+        if retry_count > 3:
+            raise Exception("Max retries reached for finish file")
         hashes = list(map(lambda x: x[0], sorted(partHash.items(), key=lambda x: x[1])))
         try:
-            response = await self._client.post(
+            response = await self.request(
                 f"https://api004.backblazeb2.com/b2api/v2/b2_finish_large_file",
                 json={
                     "fileId": fileId,
                     "partSha1Array": hashes,
                 },
-                headers={"Authorization": self.__token},
+                headers={"Authorization": token},
             )
         except Exception as er:
             log.error("Error on finish large file")
             log.exception(er)
-
-        if response.status_code != 200:
-            logger.error(response.json())
-
-        return response.json()
+            log.info("canceling upload")
+            resp = await self.request(
+                f"https://api004.backblazeb2.com/b2api/v2/b2_cancel_large_file",
+                data={"fileId": fileId},
+                headers={"Authorization": token},
+            )
+            log.info(resp)
+            log.info(resp.json())
+        response = response.json()
+        if response.get("code") == "bad_request":
+            logger.info(response)
+            mtch = re.search(
+                "Part number (\d+) has not been uploaded", response.get("message")
+            )
+            if mtch:
+                part_number = int(mtch.group(1))
+                hash, part_number = await self.__upload_file(
+                    token,
+                    part_number,
+                    fileId,
+                    path,
+                    upl_size=part_size * (part_number - 1),
+                    part_size=part_size,
+                    progress=progress,
+                )
+                partHash[hash] = part_number
+                retry_count += 1
+                return await self.__finish_large_file(
+                    partHash,
+                    fileId,
+                    path,
+                    part_size,
+                    progress,
+                    token=token,
+                    retry_count=retry_count,
+                )
+        return response
 
     async def get_media(self, media_id: int) -> Media:
         response = await self.client.get(f"{BASE_PATH}/{media_id}")
         return self.client.build_object(Media, response.data)
 
-    async def update_media(
-        self,
-        media_id: int,
-        caption: Optional[str] = None,
-        description: Optional[str] = None,
-    ) -> Media:
+    async def update_media(self, media_id: int, media: Optional[Media] = None) -> Media:
+        data = media.to_update_request()
+
+        data["id"] = media_id
         response = await self.client.put(
             BASE_PATH,
-            data={"id": media_id, "caption": caption, "description": description},
+            data=data,
         )
+
         return self.client.build_object(Media, response.data)
 
     async def delete_media(self, media_id: int):
         await self.client.delete(
             "/v1/community/channel/media", data={"mediaId": media_id}
         )
         return True
```

## swibots/api/chat/controllers/message_controller.py

```diff
@@ -1,14 +1,13 @@
 import asyncio
 import mimetypes
 import os
 import json
-from inspect import iscoroutinefunction
 import logging
-from typing import TYPE_CHECKING, List, Optional
+from typing import TYPE_CHECKING, List, Optional, Tuple, Union
 from urllib.parse import urlencode
 from io import BytesIO
 from asyncio.tasks import Task
 from swibots.types import MediaType
 from swibots.errors import CancelError
 from swibots.api.chat.models import (
     Message,
@@ -17,20 +16,14 @@
     InlineQuery,
     InlineQueryAnswer,
 )
 from swibots.utils import isUrl
 from swibots.api.common.models import User, EmbeddedMedia, Media
 from swibots.api.community.models import Channel, Group
 
-from swibots.utils.types import (
-    IOClient,
-    ReadCallbackStream,
-    UploadProgress,
-)
-
 if TYPE_CHECKING:
     from swibots.api.chat import ChatClient
 
 log = logging.getLogger(__name__)
 
 BASE_PATH = "/v1/message"
 
@@ -135,20 +128,22 @@
             embed_message=embed_message,
             inline_markup=inline_markup,
             replied_to_id=reply_to_message_id,
             scheduled_at=scheduled_at,
             **kwargs,
         )
 
-        if new_message.embed_message and new_message.embed_message.thumbnail:
-            thumb = new_message.embed_message.thumbnail
-            if thumb and not isUrl(thumb):
-                new_message.embed_message.thumbnail = (
-                    await self.client.app.upload_media(thumb)
-                ).url
+        if new_message.embed_message:
+
+            if new_message.embed_message.thumbnail:
+                thumb = new_message.embed_message.thumbnail
+                if thumb and not isUrl(thumb):
+                    new_message.embed_message.thumbnail = (
+                        await self.client.app.upload_media(thumb)
+                    ).url
 
         data = new_message.to_json_request()
         log.debug("Sending message %s", json.dumps(data))
         response = await self.client.post(f"{BASE_PATH}/create", data=data)
         return self.client.build_object(Message, response.data["message"])
 
     async def send_media(
@@ -219,14 +214,73 @@
             return self.client.build_object(Message, response.data["message"])
 
         task = asyncio.create_task(_upload_media(media))
         if blocking:
             return await task
         return task
 
+    async def edit_media(
+        self,
+        message_id: int,
+        media_id: Optional[int] = None,
+        message: Optional[str] = None,
+        document: Optional[str] = None,
+        thumb: Optional[str] = None,
+        inline_markup: InlineMarkup = None,
+        progress=None,
+        progress_args: Optional[Tuple] = None,
+        mime_type: Optional[str] = None,
+        file_name: Optional[str] = None,
+        **kwargs,
+    ) -> Union[Message, Media]:
+        msg = None
+        if message_id:
+            msg = await self.client.app.get_message(message_id)
+            media_id = msg.media_id
+            if not media_id:
+                raise ValueError("Message does'nt contain any media!")
+        if document:
+            media = await self.client.app.upload_media(
+                path=document,
+                caption=message,
+                thumb=thumb,
+                callback=progress,
+                callback_args=progress_args,
+                part_size=kwargs.get("part_size"),
+                task_count=kwargs.get("task_count"),
+                mime_type=mime_type,
+                description=file_name or os.path.basename(document)
+                if document
+                else None,
+            )
+        else:
+            media = Media(
+                app=self.client.app,
+                description=file_name,
+                file_name=file_name,
+                thumbnail_url=thumb,
+                mime_type=mime_type,
+            )
+        log.debug(f"response from [upload_media]: {media}")
+        response = await self.client.app.update_media_info(
+            media_id=media_id, media=media
+        )
+        log.debug(f"response from [update_media_info]:{response}")
+        if not message_id:
+            return response
+        response = await self.edit_message(
+            message_id=message_id,
+            text=message,
+            inline_markup=inline_markup,
+            media_id=media_id,
+            **kwargs,
+        )
+        response.media_info = await self.client.app.get_media(media_id)
+        return response
+
     async def edit_message(
         self,
         message_id: int,
         text: str,
         embed_message: EmbeddedMedia = None,
         inline_markup: InlineMarkup = None,
         **kwargs,
@@ -238,23 +292,23 @@
 
         Returns:
             ``~switch.api.chat.models.Message``: The message
 
         Raises:
             ``~switch.error.SwitchError``: If the message could not be edited
         """
-        new_message = Message(
-            self.client.app,
-            message=text,
-            inline_markup=inline_markup,
-            id=message_id,
-            **kwargs,
-        )
+        new_message = await self.client.app.get_message(message_id)
+        if text is not None:
+            new_message.message = text
+        if inline_markup:
+            new_message.inline_markup = inline_markup
+        for key, value in kwargs.items():
+            setattr(new_message, key, value)
 
-        if embed_message:
+        if embed_message is not None:
             if embed_message.thumbnail and os.path.exists(embed_message.thumbnail):
                 response_media = await self.client.app.upload_media(
                     embed_message.thumbnail
                 )
                 embed_message.thumbnail = response_media.url
             new_message.embed_message = embed_message
 
@@ -474,15 +528,14 @@
         if user_id is None:
             user_id = self.client.user.id
 
         response = await self.client.get(
             f"{BASE_PATH}/group/{user_id}/{channel_id}?{urlencode(data)}"
         )
         return self.client.build_object(GroupChatHistory, response.data)
-        # return GroupChatHistory.build_from_json(response.data)
 
     async def get_community_media_files(self, community_id: str) -> List[Message]:
         """Get community media files
 
         Parameters:
             community_id (``str``): The community id
 
@@ -492,37 +545,59 @@
         Raises:
             ``~switch.error.SwitchError``: If the community media files could not be retrieved
         """
         log.debug("Getting community media files for community %s", community_id)
         response = await self.client.get(
             f"{BASE_PATH}/media?communityId={community_id}"
         )
-        return self.client.build_list(Message, response.data)
+        return self.client.build_list(Message, response.data.get("result"))
 
     async def get_community_media_files_by_status(
-        self, community_id: str, status: str
+        self,
+        *,
+        status: Union[str, List[str]],
+        community_id: str = None,
+        channel_id: str = None,
+        user_id: int = None,
+        group_id: str = None,
     ) -> List[Message]:
         """Get community media files by status
 
         Parameters:
             community_id (``str``): The community id
+            channel_id (``str``)
+            group_id (``str``)
+            user_id (``int``)
             status (``str``): The status of the media files
 
         Returns:
             ``List[~switch.api.chat.models.Message]``: The community media files
 
 
         Raises:
             ``~switch.error.SwitchError``: If the community media files could not be retrieved
         """
         log.debug("Getting community media files for community %s", community_id)
-        response = await self.client.get(
-            f"{BASE_PATH}/media?communityId={community_id}&status={status}"
+        if not isinstance(status, list):
+            status = [status]
+        params = urlencode(
+            {
+                x: y
+                for x, y in {
+                    "communityId": community_id,
+                    "groupId": group_id,
+                    "receiverId": user_id,
+                    "status": ",".join(list(map(str, status))),
+                    "channelId": channel_id,
+                }.items()
+                if y
+            }
         )
-        return self.client.build_list(Message, response.data)
+        response = await self.client.get(f"{BASE_PATH}/mediabystatus?{params}")
+        return self.client.build_list(Message, response.data.get("result"))
 
     async def get_user_media_files(self, user_id: int = None) -> List[Message]:
         """Get user media files
 
 
         Parameters:
             user_id (``int``, *optional*): The user id. Defaults to the current user id.
@@ -669,19 +744,19 @@
         return response.data
 
     async def get_user(self, user_id: int | str = None, username: str = None) -> User:
         """Get user from user id or username"""
         if username and user_id:
             raise ValueError("'username' and 'user_id' both were provided!")
         elif user_id:
-            response = await self.client.get(f"{BASE_PATH}/user/info?userId={username}")
+            response = await self.client.get(f"{BASE_PATH}/user/info?userId={user_id}")
         elif username:
             if username.startswith("@"):
                 username = username[1:]
             response = await self.client.app.auth_service.get(
-                f"/api/users/getUserByUsername?username={username.lower()}"
+                f"/api/users/getUserByUsername?username={username}"
             )
             if not response.data:
                 return
         else:
             raise ValueError("Either provide 'user_id' or 'username' to get user info.")
         return self.client.build_object(User, response.data)
```

## swibots/api/chat/events/callback_query_event.py

```diff
@@ -1,14 +1,15 @@
-from typing import Optional
+from typing import Optional, Dict
 import swibots
 from swibots.api.common.events.event import Event
 from swibots.api.community.models.channel import Channel
 from swibots.api.community.models.community import Community
 from swibots.api.community.models.group import Group
 from swibots.api.common.models.user import User
+from swibots.api.callback import AppPage
 from swibots.api.chat.models.message import Message
 from swibots.types import EventType
 from swibots.utils.types import JSONDict
 from .command_event import CommandEvent
 
 
 class CallbackQueryEvent(CommandEvent):
@@ -30,14 +31,15 @@
         user_id: Optional[str] = None,
         user: Optional[User] = None,
         message: Optional[Message] = None,
         command: Optional[str] = None,
         params: Optional[str] = None,
         callback_data: Optional[JSONDict] = None,
         query_id: Optional[str] = None,
+        details: Optional[Dict] = None
     ):
         super().__init__(
             app=app,
             type=type or EventType.CALLBACK_QUERY,
             community_id=community_id,
             community=community,
             group_id=group_id,
@@ -51,30 +53,35 @@
             user=user,
             message=message,
             command=command,
             params=params,
         )
         self.callback_data = callback_data
         self.query_id = query_id
+        self.details = details
 
     def from_json(self, data: JSONDict) -> "CallbackQueryEvent":
         super().from_json(data)
         if data is not None:
             self.callback_data = self.data.get("callbackData")
             self.query_id = self.data.get("callbackQueryId")
+            self.details = self.data.get("additionalDetails")
             return self
 
     async def answer(
         self,
-        text: str,
+        text: str = None,
         url: Optional[str] = None,
         show_alert: Optional[bool] = False,
         cache_time: Optional[int] = None,
+        callback: Optional[AppPage] = None,
     ) -> bool:
         """Answer callback query"""
+        if callback:
+            return await self.app.answer_ui_query(self.query_id, callback=callback)
         return await self.app.answer_callback_query(
             self.query_id,
             text=text,
             url=url,
             show_alert=show_alert,
             cache_time=cache_time,
         )
```

## swibots/api/chat/events/command_event.py

```diff
@@ -53,10 +53,13 @@
         )
         self.command = command
         self.params = params
 
     def from_json(self, data: JSONDict) -> "CommandEvent":
         super().from_json(data)
         if self.data is not None:
+            details = self.data.get("commandDetails")
             self.command = self.data.get("command")
+            if  not self.command and details:
+                self.command = details.get("command")
             self.params = self.data.get("commandParams")
         return self
```

## swibots/api/chat/events/message_event.py

```diff
@@ -58,15 +58,12 @@
                 self.data.get("message"), self.app
             )
 
             self.message.user = self.user
             self.message.community = self.community
             self.message.group = self.group
             self.message.channel = self.channel
-            self.message.receiver_id = (
-                self.message.receiver_id or self.data.get("receiverId") or 0
-            )
             self.message.receiver = User.build_from_json(
                 self.data.get("receiver") or {}, self.app
             )
 
         return self
```

## swibots/api/chat/methods/__init__.py

```diff
@@ -17,14 +17,15 @@
 from .get_unread_messages_count import GetUnreadMessagesCount
 from .get_user_media_files import GetUserMediaFiles
 from .send_message import SendMessage
 from .answer_inline_query import AnswerInlineQuery
 from .download_media import DownloadMedia
 from .upload_media import UploadMedia
 from .sticker_methods import StickerMethods
+from .organization_methods import OrganizationMethods
 
 
 class ChatMethods(
     ClearConversation,
     DeleteMessage,
     DeleteMessagesFromUser,
     EditMessage,
@@ -42,9 +43,10 @@
     GetUserMediaFiles,
     SendMessage,
     AnswerInlineQuery,
     DownloadMedia,
     UploadMedia,
     GetUser,
     StickerMethods,
+    OrganizationMethods
 ):
     pass
```

## swibots/api/chat/methods/edit_message.py

```diff
@@ -1,8 +1,8 @@
-from typing import TYPE_CHECKING, Type, TypeVar
+from typing import TYPE_CHECKING, Type, TypeVar, Optional, Tuple
 import swibots
 from swibots.api.chat.models import Message, InlineMarkup
 from swibots.api.common.models import EmbeddedMedia
 
 if TYPE_CHECKING:
     from swibots.api import ApiClient
 
@@ -34,7 +34,50 @@
             text=text,
             embed_message=embed_message,
             inline_markup=inline_markup,
             **kwargs
         )
 
     edit_message_text = edit_message
+
+    async def edit_media(
+        self: "swibots.ApiClient",
+        message_id: Optional[int] = None,
+        media_id: Optional[int] = None,
+        message: Optional[str] = None,
+        document: Optional[str] = None,
+        thumb: Optional[str] = None,
+        inline_markup: InlineMarkup = None,
+        progress=None,
+        progress_args: Optional[Tuple] = None,
+        mime_type: Optional[str] = None,
+        file_name: Optional[str] = None,
+    ) -> Message:
+        """Edit media of message
+
+        Args:
+            message_id (Optional[int], optional): message id to edit
+            media_id (Optional[int], optional): media id to update
+            message (Optional[str], optional): message or caption
+            document (Optional[str], optional): path to new media
+            thumb (Optional[str], optional): thumbnail path
+            inline_markup (InlineMarkup, optional):
+            progress (_type_, optional): progress callback
+            progress_args (Optional[Tuple], optional): progress callback args
+            mime_type (Optional[str], optional): mime type of file
+            file_name (Optional[str], optional): file name
+
+        Returns:
+            Media
+        """
+        return await self.chat_service.messages.edit_media(
+            message_id=message_id,
+            media_id=media_id,
+            message=message,
+            progress=progress,
+            progress_args=progress_args,
+            inline_markup=inline_markup,
+            file_name=file_name,
+            mime_type=mime_type,
+            thumb=thumb,
+            document=document,
+        )
```

## swibots/api/chat/methods/get_channel_chat_history.py

```diff
@@ -12,18 +12,18 @@
         page_limit: int = 100,
         page_offset=0,
     ) -> GroupChatHistory:
         """Get channel chat history
 
 
         Parameters:
-            channel_id (``int``): The channel id
+            channel_id (``str``): The channel id
             limit (``int``, *optional*): The maximum number of messages to return. Defaults to 100.
             offset (``int``, *optional*): The offset. Defaults to 0.
-            community_id (``int``): The community id
+            community_id (``str``): The community id
             user_id (``int``, *optional*): The user id. Defaults to the current user id.
 
         Returns:
             ``List[~switch.api.chat.models.GroupChatHistory]``: The messages
 
         Raises:
             ``~switch.error.SwitchError``: If the messages could not be retrieved
```

## swibots/api/chat/methods/get_community_media_files.py

```diff
@@ -16,8 +16,8 @@
             ``List[~switch.api.chat.models.Message]``: The messages
 
         Raises:
             ``~switch.error.SwitchError``: If the messages could not be retrieved
 
         This function does the same as :meth:`~switch.api.chat.controllers.MessageController.get_messages`.
         """
-        return await self.chat_service.messages.get_messages(community_id)
+        return await self.chat_service.messages.get_community_media_files(community_id)
```

## swibots/api/chat/methods/get_community_media_files_by_status.py

```diff
@@ -1,26 +1,34 @@
-from typing import List
+from typing import List, Union
 import swibots
 from swibots.api.chat.models import Message
 
 
 class GetCommunityMediaFilesByStatus:
     async def get_community_media_files_by_status(
-        self: "swibots.ApiClient", community_id: str, status: str
+        self: "swibots.ApiClient", status: Union[str, List[str]],
+        community_id: str = None,
+        group_id: str = None,
+        channel_id: str = None,
+        user_id: int = None,
     ) -> List[Message]:
         """Get community media files by status
 
         Parameters:
             community_id (``int``): The community id
-            status (``str``): The status
+            status (``str`` | `List[str]`): The status
 
         Returns:
             ``List[~switch.api.chat.models.Message]``: The messages
 
         Raises:
             ``~switch.error.SwitchError``: If the messages could not be retrieved
 
         This function does the same as :meth:`~switch.api.chat.controllers.MessageController.get_community_media_files_by_status`.
         """
         return await self.chat_service.messages.get_community_media_files_by_status(
-            community_id, status
+            community_id=community_id,
+            user_id=user_id,
+            channel_id=channel_id,
+            group_id=group_id,
+            status=status
         )
```

## swibots/api/chat/methods/upload_media.py

```diff
@@ -147,25 +147,37 @@
             inline_markup=inline_markup,
             **kwargs,
         )
 
     async def update_media_info(
         self: "swibots.ApiClient",
         media_id: int,
-        caption: Optional[str] = None,
-        description: Optional[str] = None,
+        thumb_url: Optional[str] = None,
+        url: Optional[str] = None,
+        media_type: Optional[str] = None,
+        media: Media = None,
+        file_name: Optional[str] = None
     ):
         """Update Info of uploaded media
 
         media_id: int: Media Id
-        caption: str: Caption of media
-        description: str: Description of media
+        media: Media
         """
+        if not media:
+            media = Media(
+                app=self.chat_service.app,
+                id=media_id,
+                description=file_name,
+                thumbnail_url=thumb_url,
+                media_type=media_type,
+                url=url
+            )
         return await self.chat_service.media.update_media(
-            media_id=media_id, caption=caption, description=description
+            media_id=media_id,
+            media=media
         )
 
     async def delete_media(self: "swibots.ApiClient", media_id: int):
         """Delete existing uploaded media!
 
         Arguments:
           media_id: media id to delete"""
```

## swibots/api/chat/models/__init__.py

```diff
@@ -1,6 +1,7 @@
 from .message import Message
-from .inline_markup import InlineMarkup, InlineMarkupRemove
+from .inline_markup import InlineMarkup
 from .inline_keyboard_button import InlineKeyboardButton
 from .group_chat_history import GroupChatHistory
 from .inline import *
 from .sticker import Sticker, StickerPack
+from .organization import Organization, OrgApp
```

## swibots/api/chat/models/inline_markup.py

```diff
@@ -5,21 +5,26 @@
 from swibots.utils.types import JSONDict
 
 from .inline_keyboard_button import InlineKeyboardButton
 
 if TYPE_CHECKING:
     from .inline_keyboard_button import InlineKeyboardButton
 
+MAX_ROWS = 10
+MAX_COLUMNS = 8
+
 
 class InlineMarkup(SwitchObject):
     def __init__(
         self,
         inline_keyboard: List[List["InlineKeyboardButton"]] = None,
     ):
         super().__init__()
+        if isinstance(inline_keyboard, InlineKeyboardButton):
+            inline_keyboard = [[inline_keyboard]]
         self._inline_keyboard = inline_keyboard
 
     @property
     def inline_keyboard(self) -> List[List["InlineKeyboardButton"]]:
         if self._inline_keyboard is None:
             self._inline_keyboard = []
         return self._inline_keyboard
@@ -29,15 +34,16 @@
             self.inline_keyboard.append(list(buttons))
 
     def to_json(self) -> JSONDict:
         if self._inline_keyboard is None:
             return None
         return {
             "inlineKeyboard": [
-                [x.to_json() for x in row] for row in self._inline_keyboard
+                [x.to_json() for x in row[:MAX_COLUMNS]]
+                for row in self._inline_keyboard[:MAX_ROWS]
             ],
         }
 
     def to_form_data(self):
         form_data = {}
         for i, kb in enumerate(self._inline_keyboard):
             for j, b in enumerate(kb):
@@ -57,14 +63,7 @@
     def from_json(self, data: JSONDict) -> "InlineMarkup":
         if data is not None and data.get("inlineKeyboard") is not None:
             self._inline_keyboard = [
                 [InlineKeyboardButton.build_from_json(x, self.app) for x in row]
                 for row in data.get("inlineKeyboard") or []
             ]
         return self
-
-
-class InlineMarkupRemove(InlineMarkup):
-    """InlineMarkupRemove: InlineMarkup class to remove inline buttons"""
-
-    def __init__(self):
-        ...
```

## swibots/api/chat/models/message.py

```diff
@@ -2,15 +2,15 @@
 import swibots
 from io import BytesIO
 from swibots.base import SwitchObject
 from swibots.api.common import User, Media, EmbeddedMedia
 from swibots.api.community import Community, Channel, Group
 from swibots.utils.types import JSONDict
 from swibots.types import MediaType
-from .inline_markup import InlineMarkup, InlineMarkupRemove
+from .inline_markup import InlineMarkup
 
 
 class Message(
     SwitchObject,
 ):
     def __init__(
         self,
@@ -58,14 +58,15 @@
         reply_count: int = None,
         media_id: int = None,
         link: str = None,
         media_info: Media = None,
         cached_media: Media = None,
         scheduled_at: Optional[int] = None,
         sticker_pack_id: Optional[str] = None,
+        command_details: Optional[dict] = None,
         **kwargs,
     ):
         super().__init__(app=app)
         self.id = id
         self.user_id = user_id
         self.user = user
         self.receiver_id = receiver_id
@@ -108,14 +109,15 @@
         self.cached_media = cached_media
         self.link = link
         self.embed_message = embed_message
         self.is_embed_message = is_embed_message
         self.scheduled_at = scheduled_at
         self.user_session_id = user_session_id
         self.sticker_pack_id = sticker_pack_id
+        self.command_details = command_details
 
         self.__dict__.update(**kwargs)
 
     def to_json_request(self) -> JSONDict:
         return {
             "id": self.id,
             "message": self.message,
@@ -137,14 +139,15 @@
             else None,
             "isEmbedMessage": self.is_embed_message or bool(self.embed_message),
             "cachedMedia": self.cached_media.to_json() if self.cached_media else None,
             "mediaId": self.media_id,
             "mediaInfo": self.media_info.to_json() if self.media_info else None,
             "userSessionId": self.user_session_id,
             "link": self.link,
+            "commandDetails": self.command_details
         }
 
     def to_form_data(self):
         form_data = {}
         if self.user_session_id is not None:
             form_data["userSessionId"] = self.user_session_id
         if self.user_id is not None:
@@ -220,14 +223,15 @@
             "replyCount": self.reply_count,
             "requestId": self.request_id,
             "sentDate": self.sent_date,
             "status": self.status,
             "userId": self.user_id,
             "userSessionId": self.user_session_id,
             "link": self.link,
+            "commandDetails": self.command_details
         }
 
     def from_json(self, data: Optional[JSONDict]) -> "Message":
         if data is not None:
             self.button_name = data.get("buttonName")
             self.button_pressed_id = data.get("buttonPressedId")
             self.callback_data = data.get("callback_data")
@@ -263,14 +267,15 @@
                     self.media_link = self.media_info.url
             self.cached_media = Media.build_from_json(data.get("cachedMedia"), self.app)
             self.mentioned_ids = data.get("mentionedIds")
             self.message = data.get("message")
             self.personal_chat = data.get("personalChat")
             self.pinned = data.get("pinned")
             self.reactions = data.get("reactions")
+            self.command_details = data.get("commandDetails")
             receiver_id = data.get("receiverId")
             if receiver_id == "null":
                 receiver_id = 0
             self.receiver_id = receiver_id
             self.replied_to = Message.build_from_json(
                 data.get("repliedMessage"), self.app
             )
@@ -298,15 +303,37 @@
         # 1 = IMAGE
         # 2 = Video
         # 3 = AUDIO
         # 7 = FILE
         return self.status in [1, 2, 3, 7]
 
     @property
-    def is_sticker(self):
+    def video(self):
+        """Whether message includes video"""
+        return self.media_info and self.media_info.media_type == MediaType.VIDEO.value
+
+    @property
+    def photo(self):
+        """Whether message includes photo"""
+        return self.media_info and self.media_info.media_type == MediaType.IMAGE.value
+
+    @property
+    def audio(self):
+        """Whether message includes audio as media"""
+        return self.media_info and self.media_info.media_type == MediaType.AUDIO.value
+
+    @property
+    def document(self):
+        """Whether message includes document"""
+        return (
+            self.media_info and self.media_info.media_type == MediaType.DOCUMENT.value
+        )
+
+    @property
+    def sticker(self):
         """Whether message is sticker"""
         return bool(self.sticker_pack_id)
 
     async def get_replies(self) -> List["Message"]:
         if self.reply_count <= 0:
             return []
         if self.replies is None:
@@ -355,104 +382,142 @@
         return await self.app.delete_message(self)
 
     async def reply_text(
         self,
         message: str,
         embed_message: EmbeddedMedia = None,
         inline_markup: InlineMarkup = None,
+        quote: bool = None,
         **kwargs,
     ) -> "Message":
+        if quote == None:
+            quote = True if self.personal_chat else False
+
         return await self.app.send_message(
             message,
             community_id=self.community_id,
             group_id=self.group_id,
             channel_id=self.channel_id,
             user_id=self._get_receiver_id(),
-            reply_to_message_id=self.id,
+            reply_to_message_id=self.id if quote else None,
             user_session_id=self.user_session_id,
             embed_message=embed_message,
             inline_markup=inline_markup,
             **kwargs,
         )
 
     async def reply_media(
         self,
         document: Union[str, BytesIO],
         message: str = "",
         thumb: Union[str, BytesIO] = None,
         progress=None,
         progress_args=None,
         inline_markup: InlineMarkup = None,
+        quote: bool = None,
         **kwargs,
     ) -> "Message":
         """reply media to the message"""
+        if quote == None:
+            quote = True if self.personal_chat else False
         return await self.app.send_media(
             message=message,
             document=document,
             community_id=self.community_id,
             group_id=self.group_id,
             channel_id=self.channel_id,
             user_id=self._get_receiver_id(),
             thumb=thumb,
             user_session_id=self.user_session_id,
-            reply_to_message_id=self.id,
+            reply_to_message_id=self.id if quote else None,
             progress=progress,
             progress_args=progress_args,
             inline_markup=inline_markup,
             **kwargs,
         )
 
+    async def edit_inline_markup(self, inline_markup: InlineMarkup = None):
+        """Edit inline markup of message"""
+        if not inline_markup:
+            inline_markup = InlineMarkup()
+        return await self.edit_text(text=None, inline_markup=inline_markup)
+
+    async def edit_media(
+        self,
+        document: str,
+        message: Optional[str] = None,
+        inline_markup: Optional[InlineMarkup] = None,
+        **kwargs,
+    ):
+        """Bound method of client.edit_media
+
+        Args:
+           document: path to file
+           message: message caption
+           inline_markup: InlineMarkup
+        """
+        return await self.app.edit_media(
+            message_id=self.id,
+            media_id=self.media_id,
+            document=document,
+            message=message,
+            inline_markup=inline_markup,
+            **kwargs,
+        )
+
     async def reply_document(
         self,
         document: Union[str, BytesIO],
         message: str = "",
         thumb: Union[str, BytesIO] = None,
         progress=None,
         progress_args=None,
         inline_markup: InlineMarkup = None,
+        quote: bool = None,
         **kwargs,
     ) -> "Message":
         """Reply document to the message"""
         return await self.reply_media(
             message=message,
             document=document,
             media_type=MediaType.DOCUMENT.value,
             thumb=thumb,
             progress=progress,
             progress_args=progress_args,
             inline_markup=inline_markup,
+            quote=quote,
             **kwargs,
         )
 
     async def reply_audio(
         self,
         audio: Union[str, BytesIO],
         caption: str = "",
         inline_markup: InlineMarkup = None,
+        quote: bool = None,
         **kwargs,
     ):
         """Reply audio to message!"""
         return await self.reply_media(
             message=caption,
             document=audio,
             media_type=MediaType.AUDIO.value,
             inline_markup=inline_markup,
+            quote=quote,
             **kwargs,
         )
 
     async def edit_text(
         self,
         text: str,
         embed_message: EmbeddedMedia = None,
         inline_markup: Optional[InlineMarkup] = None,
         **kwargs,
     ) -> "Message":
-        if isinstance(inline_markup, InlineMarkupRemove):
-            inline_markup = None
-        elif not inline_markup:
+        if not inline_markup:
             inline_markup = self.inline_markup
 
         return await self.app.edit_message_text(
             self.id,
             text,
             embed_message=embed_message,
             inline_markup=inline_markup,
```

## swibots/api/common/models/media.py

```diff
@@ -1,25 +1,26 @@
 import swibots
-from typing import Optional
+from typing import Optional, Union
 from swibots.utils.types import JSONDict
 from swibots.base.switch_object import SwitchObject
+from swibots.types import GetMediaType
 
 
 class Media(SwitchObject):
     def __init__(
         self,
         app: "swibots.App" = None,
         id: Optional[int] = None,
         caption: Optional[str] = None,
         checksum: Optional[str] = None,
         description: Optional[str] = None,
         thumbnail_url: Optional[str] = None,
         type_name: Optional[str] = None,
         source_id: Optional[bool] = None,
-        media_type: Optional[int] = None,
+        media_type: Optional[Union[str, int]] = None,
         mime_type: Optional[str] = 0,
         file_name: Optional[bool] = None,
         file_size: Optional[bool] = None,
         url: Optional[bool] = None,
         owner_id: Optional[int] = None,
         owner_type: Optional[str] = None,
     ):
@@ -72,14 +73,15 @@
                 "mimeType": self.mime_type,
                 "fileName": self.file_name,
                 "fileSize": self.file_size,
                 "typeName": self.type_name,
                 "ownerId": self.owner_id,
                 "ownerType": self.owner_type,
                 "downloadUrl": self.url,
+                "url": self.url
             }.items()
             if y
         }
 
     def from_json(self, data: Optional[JSONDict] = None) -> "Media":
         if data is not None:
             self.id = data.get("id")
@@ -96,19 +98,43 @@
             self.owner_id = data.get("ownerId")
             self.owner_type = data.get("ownerType")
             if isinstance(self.owner_id, str) and self.owner_id.isdigit():
                 self.owner_id = int(self.owner_id)
 
         return self
 
+    def to_update_request(self):
+        return {
+            "id": self.id,
+            "checksum": self.checksum,
+            "description": self.description,
+            "thumbnailUrl": self.thumbnail_url,
+            "sourceUri": self.source_id,
+            "mediaType": GetMediaType(self.media_type),
+            "mimeType": self.mime_type,
+            "fileName": self.file_name,
+            "fileSize": self.file_size,
+            "url": self.url,
+        }
+
     async def edit(
-        self, caption: Optional[str] = None, description: Optional[str] = None
+        self,
+        thumb_url: Optional[str] = None,
+        url: Optional[str] = None,
+        media_type: Optional[str] = None,
+        file_name: Optional[str] = None,
+        media: "Media" = None,
     ):
         """Update media Info
 
         Args:
-          caption: Caption of media
-          description: Description to update.
+          file_name: Caption of media
+          media: Media: new media object
         """
         return await self.app.update_media_info(
-            self.id, caption=caption, description=description
+            self.id,
+            media=media,
+            thumb_url=thumb_url,
+            url=url,
+            file_name=file_name,
+            media_type=media_type,
         )
```

## swibots/api/community/controllers/channel_controller.py

```diff
@@ -19,16 +19,16 @@
     async def get_channel(self, channel_id: str):
         """Get a channel by id"""
         response = await self.client.get(f"{BASE_PATH}?channelId={channel_id}")
         return self.client.build_object(Channel, response.data.get("result"))
 
     async def create_channel(self, channel: Channel) -> str:
         response = await self.client.post(BASE_PATH, data=channel.to_json_request())
-        return response.data.get("channelId")
+        return response.data.get("result", {}).get("channelId")
 
     async def update_channel(self, channel: Channel) -> str:
         response = await self.client.put(BASE_PATH, data=channel.to_json_request())
-        return response.data.get("channelId")
+        return response.data.get("result", {}).get("channelId")
 
     async def get_all_channels(self, community_id: str) -> List[Channel]:
         response = await self.client.get(f"{BASE_PATH}/all?communityId={community_id}")
         return self.client.build_list(Channel, response.data.get("result"))
```

## swibots/base/switch_object.py

```diff
@@ -38,18 +38,25 @@
         return self.__dict__
 
     def from_json(self, data: Optional[JSONDict]) -> T:
         for key, value in data.items():
             setattr(self, key, value)
         return self
 
+    def update(self, data: Optional[JSONDict]) -> T:
+        new_data = self.to_json()
+        new_data.update(data)
+        return self.__class__.build_from_json(new_data, self.app)
+
     def copy(self):
         """Create a copy of object"""
         return self.__class__.build_from_json(self.to_json(), self.app)
 
     def __repr__(self) -> str:
         filter_dict = {
-            x: y.to_json() if hasattr(y, "to_json") else y
-            for x, y in self.to_json().items()
+            x: y.to_json()
+            if hasattr(y, "to_json")
+            else (y if isinstance(y, (str, dict, int)) else str(y))
+            for x, y in self.__dict__.items()
             if y and x != "_app"
         }
         return f"{self.__class__.__name__} {json.dumps(filter_dict, indent=1)}"
```

## swibots/bots/filters/filter.py

```diff
@@ -20,15 +20,15 @@
     callback = None
     value: bool = None
     onFailure = None
 
     async def __call__(self, ctx: BotContext) -> bool:
         if not self.callback:
             raise NotImplemented
-        self.value = await self.callback(ctx)
+        self.value = await sync_or_async(self.callback(ctx))
         return self.value
 
     async def check_failure(self, ctx: BotContext):
         if self.onFailure and self.value is False:
             await sync_or_async(self.onFailure(ctx))
 
     def __invert__(self):
@@ -160,14 +160,20 @@
 
 
 communities = create(communities_filter, name="communities")
 
 channels = create(lambda _, ctx: ctx.event.message.channel_chat)
 groups = create(lambda _, ctx: ctx.event.message.group_chat)
 
+video = create(lambda _, ctx: ctx.event.message.video)
+photo = create(lambda _, ctx: ctx.event.message.photo)
+document = create(lambda _, ctx: ctx.event.message.document)
+audio = create(lambda _, ctx: ctx.event.message.audio)
+sticker = create(lambda _, ctx: ctx.event.message.sticker)
+
 
 async def me_filter(self, ctx: BotContext[MessageEvent]):
     return ctx.event.message is not None and ctx.event.message.user_id == ctx.user.id
 
 
 me = create(me_filter)
 """Filter messages coming from your user."""
```

## swibots/utils/types.py

```diff
@@ -1,9 +1,10 @@
 import os, asyncio
 from enum import Enum
+from io import BytesIO
 from typing import Any, Callable, Collection, Coroutine, Dict, TypeVar, Union
 from inspect import iscoroutinefunction
 from swibots.errors import CancelError
 from threading import Thread
 
 
 class IOClient:
@@ -36,16 +37,20 @@
         client: IOClient = None,
         readed: int = 0,
         current: int = 0,
         size: int = 0,
     ) -> None:
         super().__init__()
         self.callback = callback
-        self.path = path
-        self.total = size or os.path.getsize(path)
+        _bytesio = isinstance(path, BytesIO)
+        self.obj = path
+        self.total = size
+        if not size:
+            self.total = path.getbuffer().nbytes if _bytesio else os.path.getsize(path)
+        self.path = path.name if _bytesio else path
         self.callback_args = callback_args
         self.readed, self.current = readed, current
         self.client = client
 
     def update(self, bytes):
         self.current = bytes
         self.readed += bytes
```

## swibots/utils/ws/asyncstomp/async_ws_client.py

```diff
@@ -30,16 +30,17 @@
         self.tasks: List[asyncio.Task] = []
         self._heartbeatTask = None
         self.subscriptions: dict[str, AsyncWsSubscription] = {}
         self._connect_args = {}
         self._connectCallback = None
         self.errorCallback = None
         self._connectIntents = 0
-        self._connectInterval = 10
-        self._maxConnectIntents = 20
+        self._connectInterval = 7
+        self._incrementalDelay = 3
+        self._maxConnectIntents = 50
         self._connecting = False
         self._gracefully_disconnect = False
 
     async def _start_heartbeat(self):
         elapsed = 0
         while self.connected:
             await asyncio.sleep(0.1)
@@ -60,37 +61,43 @@
         await self._clean_up()
         if (
             self._connectIntents >= self._maxConnectIntents
             and self._maxConnectIntents > 0
         ):
             log.error("Max connection attempts reached. Aborting.")
             raise SwitchError("Max connection attempts reached. Aborting.")
-        await asyncio.sleep(self._connectInterval)
-        self._connectIntents = self._connectIntents + 1
+        wait_time = self._connectInterval
+        if self._connectIntents:
+            wait_time += (self._connectIntents * self._incrementalDelay)
+        log.info(f"Waiting for {wait_time}s before retry!")
+        await asyncio.sleep(wait_time)
+        self._connectIntents += 1
         await self.connect(**self._connect_args)
 
     async def _on_error(self, ws_app, error, *args):
         await self._clean_up()
         await self._on_close(ws_app, *args)
-        log.error(error)
+        if error:
+            log.error(error)
 
     async def _on_message(self, ws_app, message, *args):
         frame = WsFrame.unmarshall_single(message)
 
         if frame.command != "PONG":
             log.debug("\n<<< " + str(message))
         else:
             log.debug("\n<<< " + frame.command)
 
         _results = []
         if frame.command == "CONNECTED":
+            if self._connectIntents:
+                log.info("connected to server " + self.url)
             self.connected = True
             self._connecting = False
             self._connectIntents = 0
-            log.debug("connected to server " + self.url)
             self._heartbeatTask = self._loop.create_task(self._start_heartbeat())
             # resubscribe
             for sub in self.subscriptions.values():
                 await self._start_subscription(sub)
 
             # if self._connectCallback is not None:
             #     _results.append(await self._send_heartbeat(frame))
@@ -116,22 +123,18 @@
                 frame.nack = nack
 
                 _results.append(self._loop.create_task(sub.receive(frame)))
             else:
                 info = "Unhandled received MESSAGE: " + str(frame)
                 log.debug(info)
                 _results.append(info)
-        elif frame.command == "RECEIPT":
-            pass
         elif frame.command == "ERROR":
             if self.errorCallback is not None:
                 _results.append(self.errorCallback(frame))
-        elif frame.command == "PONG":
-            pass
-        else:
+        elif frame.command not in ["PONG", "RECEIPT"]:
             info = "Unhandled received MESSAGE: " + frame.command
             log.debug(info)
             _results.append(info)
 
         return _results
 
     async def _transmit(self, command, headers, body=None):
```

## Comparing `swibots-1.4.9.dist-info/LICENSE.md` & `swibots-1.4.9b0.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `swibots-1.4.9.dist-info/METADATA` & `swibots-1.4.9b0.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,31 +1,35 @@
 Metadata-Version: 2.1
 Name: swibots
-Version: 1.4.9
+Version: 1.4.9b0
 Summary: Bots Library for Switch
 Home-page: https://github.com/switchcollab/Switch-Bots-Python-Library
 Author: switchadmin
 Author-email: support@switch.pe
 License: LGPLv3
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE.md
-Requires-Dist: httpx (<=0.25.0)
+Requires-Dist: httpx (>=0.25.1)
 Requires-Dist: websockets (<=11.0.3)
+Requires-Dist: aiofiles
+Requires-Dist: pillow
 
 <p align="center">
   <img src="https://raw.githubusercontent.com/switchcollab/Switch-Bots-Python-Library/main/docs/static/img/switch-logo.png" alt="Logo">
 </p>
 
 ![GitHub stars](https://img.shields.io/github/stars/switchcollab/Switch-Bots-Python-Library)
 ![GitHub Forks](https://img.shields.io/github/forks/switchcollab/Switch-Bots-Python-Library)
-![Version](https://img.shields.io/badge/version-0.3.30-teal.svg)
+![Version](https://img.shields.io/badge/version-1.4.22-red.svg)
 ![PyPI - Downloads](https://img.shields.io/pypi/dm/swibots)
 
-# SwiBots: Python Library for Switch App
+### SwiBots: Python Library for [Switch: Chats and Communities](https://switch.pe)
+
+---
 
 SwiBots is a Python library designed to simplify the development of apps for the
 Switch platform. With SwiBots, you can create interactive and engaging bots for
 the Switch app effortlessly.
 
 For detailed information and documentation, please visit our
 [documentation website](https://switchcollab.github.io/Switch-Bots-Python-Library).
@@ -34,16 +38,18 @@
 
 - [Getting Started](#getting-started)
 - [Installation](#installation)
 - [Usage example](#usage-example)
 - Quick Guide
   - [Embedded message](#sending-embedded-messages)
   - [Sending media](#sending-media)
+  - [Editing media](#editing-media)
   - [Sending buttons](#sending-buttons)
   - [Handling keyboard callbacks](#handling-keyboard-callbacks)
+  - [Sending UI based callbacks](#send-ui-based-callbacks)
 - [More samples](#explore-bot-samples)
 - [Code Contribution](#ðŸš€-contributing)
 
 ## Getting Started
 
 You can start building your first app with SwiBots in less than 5 minutes.
 
@@ -53,19 +59,15 @@
 
 ```bash
 pip install swibots
 ```
 
 ### Usage Example
 
-Let's create a simple echo bot to get you started quickly. Follow these steps:
-
-1. Create a Python file, e.g., `echobot.py`.
-
-2. Add the following code to your `echobot.py` file:
+Create a simple echo bot
 
 ```python
 from swibots import (
     BotApp,
     BotContext,
     MessageEvent
 )
@@ -75,33 +77,31 @@
 # Initialize the app and register commands
 app = BotApp(
     TOKEN, "A cool bot with annotations and everything you could possibly want :)"
 )
 
 @app.on_message()
 async def message_handler(ctx: BotContext[MessageEvent]):
-    # Easy way to prepare a message that is a response to an incoming message
     message = ctx.event.message
     response_text = f"Thank you! I received your message: {message.message}"
     # Send the message back to the user
     await message.respond(response_text)
 
 app.run()
 ```
-
-3. Open your Switch app and send a message to the bot, e.g., `Hello world!`
-
-4. Your bot will reply with: `Thank you! I received your message: Hello world!`
+Open your Switch app, send a message (e.g., `Hello world!`), and your bot will reply!
 
 ### Explore Bot Samples
 
 For more examples and sample bots, please check out our [Bot samples](./samples)
 directory.
- ## Other bot samples
- - [ComBot - Community management bot](https://github.com/New-dev0/Combot)
+
+## Other bot samples
+
+- [ComBot - Community management bot](https://github.com/New-dev0/Combot)
 
 ## Examples
 
 ### Sending Buttons
 
 You can easily send interactive buttons in your messages using SwiBots:
 
@@ -153,15 +153,32 @@
                 EmbedInlineField("https://icon.png", "Nice Meeting You", "Hello ðŸ‘‹")
             ]
         ]
     )
 )
 ```
 
+### Editing Media
+
+```python
+# send media/document
+message = await bot.send_document(
+    document="file.pdf",
+    thumb="image.png",
+    user_id=100
+)
+# use the message reference to edit
+await message.edit_media(
+    document="file2.pdf",
+    thumb="thumb.png"
+)
+```
+
 ### Handling Keyboard Callbacks
+
 ```python
 from swibots import CallbackQueryEvent, BotContext
 from swibots import regexp, InlineMarkup, InlineKeyboardButton
 
 # send message with callback button
 await bot.send_message("Hi", user_id=0, inline_markup=InlineMarkup([[
     InlineKeyboardButton("Callback Button", callback_data="clb")
@@ -173,14 +190,42 @@
     # display callback answer to user
     await ctx.event.answer(
         "Hello, this is a callback answer",
         show_alert=True
     )
 ```
 
+### Send UI Based Callbacks
+
+```python
+from swibots import CallbackQueryEvent, BotContext
+from swibots import AppPage, AppBar, Dropdown, ListItem
+
+# handle callback query
+@app.on_callback_query()
+async def onCallback(ctx: BotContext[CallbackQueryEvent]):
+    # create a callback component
+    await ctx.event.answer(
+        callback=AppPage(
+            app_bar=AppBar(title="Hello from Swibots"),
+            components=[
+                Dropdown(
+                    placeholder="Choose Option",
+                    options=[
+                        ListItem("1. Orange", callback_data="option1"),
+                        ListItem("2. Yellow", callback_data="option2"),
+                        ListItem("3. Green", callback_data="option3"),
+                        ListItem("4. Green", callback_data="option4"),
+                    ],
+                )
+            ],
+        )
+    )
+```
+
 Feel free to explore more features and capabilities of SwiBots in our
 documentation.
 
 Happy bot development!
 
 ## ðŸš€ Contributing
```

## Comparing `swibots-1.4.9.dist-info/RECORD` & `swibots-1.4.9b0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 swibots/__init__.py,sha256=nqoXPg959xX-IlLoJ5_-5F0zo4f6VixA3g2ZWM7XZ6I,250
-swibots/bot_app.py,sha256=JkSQC8ZXBacEMCfYrCmCDwfxz-8LBQMZtdRUL0jf8Xo,12897
-swibots/config.py,sha256=rt6rnngqxWgJkZ4ahfjgxmD-smvfSGOVg339nExI81Y,2441
-swibots/errors.py,sha256=DEve6-l1UxnU9MNA-2nhhsrGGX1m1vKWoclB1rXqva4,1696
+swibots/bot_app.py,sha256=jFbq4sezuiVCy28lC72wX3zo3vE4WZwgu1K6X3Mp_xU,14647
+swibots/config.py,sha256=WAQlACB7aP0lPV4SlA3GTUXpv5ikdotVl6OtAuvQiAw,2430
+swibots/errors.py,sha256=nmLzosaFSBUCn-67sbnkgM3KqSSoLNLQjsQ5-FQEvb4,1752
 swibots/responses.py,sha256=79RVPPUpYeRCPETKC57NtW-U8q1elZoEbyfCgzXcwns,856
-swibots/types.py,sha256=h2YsYMublXj-fYrnN6pgs89msBx8NM9qxZq2KqjZFl0,1116
-swibots/api/__init__.py,sha256=RJMJTqoBeR8WVasIXEdZP7zYY-BXMA1DrHcmkGxabgA,170
+swibots/types.py,sha256=fNj-OJIjgL8SsKst-i857P0eEjbPL1Nip9i0r1m4YhQ,1480
+swibots/api/__init__.py,sha256=UtpyLYZ11aCccKhqRovyJ0iqcwQqar5X6LLvJU_AHKs,193
 swibots/api/api_client.py,sha256=1MCKi2YK3gP0lx1840OqRC9cm-I2zhLnW8Z2yt7TNJU,2681
 swibots/api/airdrop/__init__.py,sha256=8PNiw-x3AfdNo_1lzgWp43USiUxYmUsqG_7V7WIZ8IY,110
 swibots/api/airdrop/client.py,sha256=35R-uZZMIGbXtxzXt5kXyoTeeAFqmZWhXRxRSChpUcU,941
 swibots/api/airdrop/controllers/__init__.py,sha256=AJJyoFc7TayWSWO8Eqbp0O_Y4_mxrMaLkgw0CnzQeL8,57
 swibots/api/airdrop/controllers/tournament_controller.py,sha256=rzz3DovkeS6ZYYQFb4JzqDGmX3oRExFSbnr0CkLWnJo,1201
 swibots/api/airdrop/methods/__init__.py,sha256=9h9fJfeEnvWqXH1Ck6thZ_1V1aTPaz1DSJo4Vjw3mWs,151
 swibots/api/airdrop/methods/get_referral.py,sha256=223uGJRmCS-QkPlisVbCN6Ch691v389-N0q6Q2F2qn0,608
@@ -21,68 +21,77 @@
 swibots/api/auth/methods/__init__.py,sha256=XA0IBNm5hedBPCwfTZdaUGCVVVe0IuYKLoktB9Q-ULc,67
 swibots/api/auth/methods/get_me.py,sha256=tMMgG08nf7QeXal1mFHUHaj2imDb30eI-x_G23RyvSo,669
 swibots/api/auth/models/__init__.py,sha256=OgpIhLsqh3pQyi3ne_0aU1sL7H1uF3PMQaWuzTYQrcI,59
 swibots/api/auth/models/auth_user.py,sha256=hZ7hmacu6_mk_waNhKouA4jVyBA6bj-smLIg3k0ToIU,4435
 swibots/api/bot/__init__.py,sha256=NpbR-NVuGaDlfGBlH3BQvDlKE7NhoeCip7rMJnUCDT0,86
 swibots/api/bot/bot_client.py,sha256=TQ7ivT6ZVE3V7mDgyL8A7n37f7Yq7NO6G1-4dwv--vo,1403
 swibots/api/bot/controllers/__init__.py,sha256=AjLKxk4un2pO8wwSzby8SOtLfwbFT7bZGbGs7Kiw6OE,137
-swibots/api/bot/controllers/bot_controller.py,sha256=ZX58mnAkeocQT_oSwtNwFgOfniU7VbFNJerCzg6y0_Q,2481
+swibots/api/bot/controllers/bot_controller.py,sha256=zSMxD-xAXUGMC-2GHngJrD_HLT09q005seyHy-zo0Sk,3408
 swibots/api/bot/controllers/game_controller.py,sha256=504xGiRrEKwXP0zCw1zTt7aFniKt12HIoRFq-1CRp38,2988
 swibots/api/bot/methods/__init__.py,sha256=z2-iDM8h2L9DxEc6kgf-XaU1Ok4Fx1IwKvVRz6-9aZ8,320
-swibots/api/bot/methods/answer_callback_query.py,sha256=EUcnB-tjXdflnNDKIs_NdszWnl2I0ZS40y887uj-i-g,858
+swibots/api/bot/methods/answer_callback_query.py,sha256=A54YMmQz4y1yzgKqnS5Ebihh3Z6GW4OP8zx6ROlaCqU,1290
 swibots/api/bot/methods/delete_bot_info.py,sha256=ZIc0UNMXmrnPzQV1Ah9ByZV0MUBH7YF20inkxz07PJo,557
 swibots/api/bot/methods/game_methods.py,sha256=8rdOkfeycXrX6MZfK370BXZjxCDpZj1XJ9E5EBNR4gM,1744
-swibots/api/bot/methods/get_bot_info.py,sha256=XguJr51H0txWhPLJ36YS7j4eRjeonT0eKAeGrbfTrs8,600
-swibots/api/bot/methods/update_bot_info.py,sha256=5kSuC_GP07Ag4il-s_bai6bU73J3H_cgY3q0X4YpkgA,633
-swibots/api/bot/models/__init__.py,sha256=4PFBWdqVGKkkMgm76HAEQEob38SFyZZXWxWsDy3FTAw,152
-swibots/api/bot/models/bot_command.py,sha256=F5P2pVi_NV-sFpj23WZjvOeN4jM8XiKmzGlgvZrvDbw,1087
-swibots/api/bot/models/bot_info.py,sha256=Bu6TIfxiAL1WBcWglQS0aek3y2jsnYg83FDpal3GNtc,1929
+swibots/api/bot/methods/get_bot_info.py,sha256=FQXHfIIr2KxVKXIsJhzxIcuCI92T5yWMi4mdtpjM_HM,598
+swibots/api/bot/methods/update_bot_info.py,sha256=PaNxyGnhwF-k2pzlre1EXvzJ0tlzVCrN5d0FKXNHvRY,1293
+swibots/api/bot/models/__init__.py,sha256=WrYmsk3Ho6RBfY49om_MAAZpdWJ2TR1nUw2rr8m_UAg,210
+swibots/api/bot/models/bot_command.py,sha256=gG8Bhz2o99FlOzGiQjW7KAFUp35E5wKfWCoMn67MK70,2182
+swibots/api/bot/models/bot_info.py,sha256=SYUo3ZAYcppfdBPgtTf2bZhxGmHPQeJ9G3znxEW1to4,3538
 swibots/api/bot/models/game_info.py,sha256=EMd5Kz4XlqXymFwtgmwqVb2fImjOBkTPR0Su4Qn4aAQ,1617
+swibots/api/callback/AppPage.py,sha256=2fOZAxwXbf5aAro7mjcWrLjGOJPp72kk41BV_Ban-5A,1308
+swibots/api/callback/Dropdown.py,sha256=6r-ZojEVMRq3uws6SUX3LIQr1dQsgfdP-fC4GGcgoqY,886
+swibots/api/callback/Grid.py,sha256=SmTzPork81PyKOVXq9wAr3c68_UWcHslQodwcbMHquI,1404
+swibots/api/callback/ListItem.py,sha256=3GrxnmKgHGTRMK6qCfSznRavsoUWUJpSwaoSG4oCnIU,1249
+swibots/api/callback/__init__.py,sha256=2uYXkWWEkp5qFkfBLOkZPBvS5c7mz47ZL_TjudVPd0c,217
+swibots/api/callback/types.py,sha256=4UFFQX5O00aiJ08P12J2AqQr3FVq1B96QEUPozmzwwI,211
 swibots/api/chat/__init__.py,sha256=FWfMnyTSF7s4wIPRkpJoEC16rsiu6Q1pfg_0SEECzlc,111
-swibots/api/chat/chat_client.py,sha256=n6wSeqK4Fdh0p3WSotVm68hLF0KsdIpLWGH72Q3Vtyw,6901
-swibots/api/chat/controllers/__init__.py,sha256=hfL0PG3Io3P5g2jjhQD53Ty_ajv71fFtqdgWJHs6CyE,311
+swibots/api/chat/chat_client.py,sha256=-fbg5fqnyIiRjKT3oGw0P1T-vlFDSMuUYBtX7bDpqN4,7198
+swibots/api/chat/controllers/__init__.py,sha256=ME8vXDZuP_px-J8IooNYkuYrhFzUnKJAi94wjw3kXVk,402
 swibots/api/chat/controllers/chat_controller.py,sha256=9YqGCURT0oqEQEO5N0lwQ77ZhX73QkXDDB6dtNM9S4s,1412
-swibots/api/chat/controllers/media_controller.py,sha256=CWtIE_PNkIN4c2DgJG4iZQhjmTIggtv68WL1sr3mCdY,17713
-swibots/api/chat/controllers/message_controller.py,sha256=XnlCOyXPvkW7PgSyC3OVy50h2-5phTWVBIW7Mjtle_s,24594
+swibots/api/chat/controllers/media_controller.py,sha256=S3UDNtV6dCiIJ7idTkTKOhFwdbXixsVGk2vgE5f6Iog,22934
+swibots/api/chat/controllers/message_controller.py,sha256=ZjqBAaE0bMiTGET8nijba9wzWlLZ51VPJ1uG9q_Xieo,27411
+swibots/api/chat/controllers/organization_controller.py,sha256=8nufj7Poth9PUrHsZAQslCMn0fNNR3pg9XYsU6mtPNM,1451
 swibots/api/chat/controllers/sticker_controller.py,sha256=4sB4ootun-RyKjx0FXjnipf2mCJvRmUBRLjnomVx6R8,3849
 swibots/api/chat/events/__init__.py,sha256=mDNNXD7BMBXRJxORkbvvTW4JsXn7uwHmPYfumhtCka4,351
-swibots/api/chat/events/callback_query_event.py,sha256=193Zk8pPbezxnFHfyw08uuarMSYSqj2l8SDsZS836wM,2723
+swibots/api/chat/events/callback_query_event.py,sha256=c7zx43qyG-H9FkYbgaH8SqbYZQweUY7-FegZ4ZktSXg,3065
 swibots/api/chat/events/chat_event.py,sha256=n2Xzs7UUzh5tgEcx7sRJHi4KF8gsVvNomv2NmL4rMEQ,2838
-swibots/api/chat/events/command_event.py,sha256=nOVQuQN2PanoxSu5P7OULqwgs5ekWeFYNuhz-s1l4Bo,2155
+swibots/api/chat/events/command_event.py,sha256=_EDANwcOlweVvaxGoU9Ew4skCyjwKh_79sNS_30cxfw,2312
 swibots/api/chat/events/inline_query_event.py,sha256=Sj8tviOqzIesMmwWD59WChcGUr6LQATw0BQ5wkVBsEg,2180
-swibots/api/chat/events/message_event.py,sha256=rNq6xhUPsHNppK74OsZXUpaT-4qgpiKlr6DtRhOWbng,2547
-swibots/api/chat/methods/__init__.py,sha256=dkUhDIQHzfpaxgdLsmJDr2Osq2vI7JJGmn86W4gSuxE,1678
+swibots/api/chat/events/message_event.py,sha256=Qw-3AlrHyPKYQD4TPEP3ecO2MMkRMJZzl12-dJwikoQ,2412
+swibots/api/chat/methods/__init__.py,sha256=l8ZyOQWkcrj-gMlRw0NwAnzHB3d_Jf8_8Fz1vWI0x0M,1758
 swibots/api/chat/methods/answer_inline_query.py,sha256=-7pZxZxhfVCB7cmCAwp-j6h0ZuTCxxJgNI7Xljh482Y,684
 swibots/api/chat/methods/clear_conversation.py,sha256=wDaveqhYH6nAyEpPlBlnStV6Xtpm9hKzMjfRToeqLXQ,714
 swibots/api/chat/methods/delete_message.py,sha256=BcsBtIDWKJnspOtfkZsNiFN4aYDiXs0I46Uis6Mbs0o,726
 swibots/api/chat/methods/delete_messages_from_user.py,sha256=JI2pJuD39hZzHDHluKksGKUdCC_MPo5DOBoDvGlWsAE,744
 swibots/api/chat/methods/download_media.py,sha256=P5Az2Kp2Gz27GJiwYqwmsTmGzb66H7JBg2pWjLo4cag,1683
-swibots/api/chat/methods/edit_message.py,sha256=JWmof2nv7NT5Z7ujxCt03V0qG3t-zaz1ul9BR8_FMxQ,1204
+swibots/api/chat/methods/edit_message.py,sha256=WLEQVv5dNU6OvjkXnLlS7TGvd8x4sqo1ejUdDOqxg6s,2877
 swibots/api/chat/methods/flag_message.py,sha256=nliir6GQn3VmrzJc0heBHGyEgbXrBHvGZtYaBnlbLDI,714
 swibots/api/chat/methods/forward_message.py,sha256=ZNSL3yr0YaZ_LCI0cCFawzI7X-0vDjSlliKcAP-F6XM,1276
-swibots/api/chat/methods/get_channel_chat_history.py,sha256=0TFK4xth_K1TUXCBkzN_XE__w-xCY_ivTB7MXax5Gf0,1172
-swibots/api/chat/methods/get_community_media_files.py,sha256=bVyyLcrMiciQMkj6sKyjbe_Il1PTi6o1YoymwV7T-iE,748
-swibots/api/chat/methods/get_community_media_files_by_status.py,sha256=839VOsrJTJS1yHxLVDO432IYWhYrypAS-ioXjcPI8G4,909
+swibots/api/chat/methods/get_channel_chat_history.py,sha256=6-l_tZSwNZCYjUiXbSA5bNHe-l0XxcSmVWYObiJtnE8,1172
+swibots/api/chat/methods/get_community_media_files.py,sha256=cXKZUBS6XL8yg1OYzKF9x2oTak9EJiBhZDxr4yjKYAA,761
+swibots/api/chat/methods/get_community_media_files_by_status.py,sha256=1Q1ctJAyChf7Phtb_18xbh08nxrxzlha0qYfrFVXTuY,1190
 swibots/api/chat/methods/get_flag_messages.py,sha256=izmZ9Ut0Y5gFjJmdCX24yzLIXPPa--GfLfHwSHXRncQ,671
 swibots/api/chat/methods/get_group_chat_history.py,sha256=L0Oho3m8GPRd99QcmypI7ZiYIYxNowMkOkqWo1Hp73I,1122
 swibots/api/chat/methods/get_message.py,sha256=WXvmp9UxtRqhnf6mzt6tn3z0VbW-CJ3xaofssOR7llg,1002
 swibots/api/chat/methods/get_messages.py,sha256=wpTdPNUJYutKZmXKAgL7ShA36mp3y-vCc13vA3_WLHc,744
 swibots/api/chat/methods/get_messages_between_users.py,sha256=8icgmmOLnQNhotHQ4D1NzlKlnM9xS8yDRFcqF1Y982c,1134
 swibots/api/chat/methods/get_unread_messages_count.py,sha256=mchCYn7aTZIjUke0-FBJYJXmKPMEavO0JEuKfggRsr8,576
 swibots/api/chat/methods/get_user.py,sha256=dcQdPxf8_xSNCDrAL-ve6FocL2k11wzPhmNXW018tz0,947
 swibots/api/chat/methods/get_user_media_files.py,sha256=-bLjM8_EWIOfpk5SThfiCV5jI3H_OpueE4srWsj0PmE,810
+swibots/api/chat/methods/organization_methods.py,sha256=CXPDFFW3ty6Rp4Mdwtxxoiq9ZvHNrl4_6gaXgxhK700,2604
 swibots/api/chat/methods/pin_message.py,sha256=INdECRzaBXIJ1SUhGrsQCDps3JiCeah5sQ5kxcEOwiY,870
 swibots/api/chat/methods/send_message.py,sha256=ygDXIUo5W86uOKQL7UF6VpfTqiSwRNzvGmlCFMTcrGU,4580
 swibots/api/chat/methods/sticker_methods.py,sha256=cNf-EU0pUZm_L6NsjP6_BZ0lA70RaiafeIAz9Y2VM6o,4836
-swibots/api/chat/methods/upload_media.py,sha256=LyxTqL-2FS2Z9c9-soALohJVTGWpF1j9m-oLZrZOLXM,5679
-swibots/api/chat/models/__init__.py,sha256=0v4XOdEC19Fgr6Pfn-aHZI28Qii6TIIZOX2sfdVTfDw,265
+swibots/api/chat/methods/upload_media.py,sha256=6v1hKyclWgF4rnsL-Ix5ZnTUeiL4vn38mU8RuQlxEgM,5992
+swibots/api/chat/models/__init__.py,sha256=TkoBCunLUzxZfWf0dHZfsO7Cg9q56hzFEoDde3y_obo,291
 swibots/api/chat/models/group_chat_history.py,sha256=IT1hK5Ob9QUnWEihputSRQt4PzhWqO8MeBNAtWo3oB8,922
 swibots/api/chat/models/inline_keyboard_button.py,sha256=DegmuF-vhbp-8P_346hRrHQynKMFzXtU5f1NlTGsb74,1025
-swibots/api/chat/models/inline_markup.py,sha256=7LGrrQCP_dK_2tZqt8GwWO_pmFT6ieXFtEzgXcDqgjA,2440
-swibots/api/chat/models/message.py,sha256=S2GI4ivCXsOoZY5upe_ir1vZMdvQWIuFIJhsTQv5S4s,17930
+swibots/api/chat/models/inline_markup.py,sha256=p8H7WJH5LzXPTcA8gv2EJ_bwq-wU8WJmbBRhcV5lRJs,2470
+swibots/api/chat/models/message.py,sha256=E6tlQl3l5_iejLcMTCioofyjo7uXU_xbR8Cwg0kKB4w,20097
+swibots/api/chat/models/organization.py,sha256=Od5W_60hL_f5NT3iE6jIdfaa_y-mCG9QuXRZPFBrjDE,4564
 swibots/api/chat/models/sticker.py,sha256=xXHKP9zl-FRj39hsnQUeLQ5peA_rxkN7gadry_-YRXc,4047
 swibots/api/chat/models/inline/__init__.py,sha256=CKZg9QI-CGUnoinh46SyWWkgiQa-XO1PLr8-e3UE_Ds,575
 swibots/api/chat/models/inline/base_typed_inline_query_result.py,sha256=QR3zfVjsjtfhfhTdFh_8fhOWqgsMMvuyzf_-8zgWpqk,1374
 swibots/api/chat/models/inline/inline_query.py,sha256=59j3unjeEnfS0fsXWus1z_gdUSiKgB2j7J6mgtJto_g,2569
 swibots/api/chat/models/inline/inline_query_answer.py,sha256=nrtsywO0WQJOOMWvzScZI7dG95TRdqGZJxYv9EBMclE,1929
 swibots/api/chat/models/inline/inline_query_result.py,sha256=eLUvvYFenVMxO5sfEjSqDtCql6J0qdaOFRSDHV3LWos,982
 swibots/api/chat/models/inline/inline_query_result_article.py,sha256=9G0KJciPAzUWpZ2INp6bajad8yoOU8vGJAHqP-QoPC8,1241
@@ -93,22 +102,22 @@
 swibots/api/chat/models/inline/types.py,sha256=5lj8aDqIXTsBuOTnN1tqju5JgRVfWw9u6fyn5-VO32w,211
 swibots/api/common/__init__.py,sha256=nJU3_6JnSBFON9SemlznSgBPDfoeZMm46Jx3q_zNZug,46
 swibots/api/common/events/__init__.py,sha256=F2FSkeAgkcSoG68Gf0D5KjSirR2X3PqzDLfzHFCYk48,49
 swibots/api/common/events/event.py,sha256=8EOO631ZzJUiryoHrR7kDucDCODFZLMefhODZ6v2n9Q,3001
 swibots/api/common/models/__init__.py,sha256=AhsIoo_WJNdWM7_nZVDX0q0d5ymKYRhREpScVjPGibg,187
 swibots/api/common/models/embed_inline_field.py,sha256=KudfJM7xHvqg3lp6tWcXfuv6Ses22wkUcj5l7vLqP74,538
 swibots/api/common/models/embedded_media.py,sha256=7DOAwJk_aKe8nWEvx1RfAio5WCDDs0h6GJ_d1pIsiuU,3291
-swibots/api/common/models/media.py,sha256=k-3u9iJkpbiFdNf1lqwhiEzjjIGl2sLjfiU4d3qv5TU,4139
+swibots/api/common/models/media.py,sha256=GL9tvFDVYDs22qFtnW2tU9eGMywCfv32sQRyLnPOQag,4949
 swibots/api/common/models/user.py,sha256=JqCX-DJNynqcKGP9DTHcOL4vqaPfJ1xtS4wnzivDwoo,2950
 swibots/api/common/models/usertournament.py,sha256=iVaDvZuVzjRn4N4u5U5AB3gLhNdUj7KcaRLMVOJKvbI,1205
 swibots/api/community/__init__.py,sha256=L_gtL_HfE08Nst9ccpkMhnmASvaQKzq8CAXfNNFdqto,93
 swibots/api/community/community_client.py,sha256=IdEHWCjTC5eLQ5WfF1HJvqM70K2VmIYywEOl_vQPKk4,6412
 swibots/api/community/controllers/__init__.py,sha256=GGmPnnliGfFWHm2Pehj4M5q_nPQfbVFhl3yiCmP1-3Q,315
 swibots/api/community/controllers/ban_controller.py,sha256=5QhZ_klCuD1YmqHTKvlfLC_huDYyIVVtmALMd5hCeGA,1082
-swibots/api/community/controllers/channel_controller.py,sha256=2QEzf5w645XN8-GGB9VnQNe9nPtd9qSWeVOVFJob1i8,1258
+swibots/api/community/controllers/channel_controller.py,sha256=gbImcaMyZHDUA-7xnUiYegV370evh7YngoF4HV7Po3Y,1294
 swibots/api/community/controllers/community_controller.py,sha256=i4TNd8yNKk4vV2glMejuzqTqbzcequz8-Lr-1jkYN9g,5039
 swibots/api/community/controllers/group_controller.py,sha256=1pAnPrYkR5mfLtrNUmPFRCSXs5dX7DWYQgizNMbvgLE,839
 swibots/api/community/controllers/permissions_controller.py,sha256=8e3bMn-xlEJEmBvD13UVjFSAN0oho8OtKgUtDc7zJEE,2286
 swibots/api/community/controllers/quest_controller.py,sha256=WLSid6kamlPxWNSfUqAgK1KUV63dHYLLrutDRvYL0eU,3980
 swibots/api/community/controllers/restrict_controller.py,sha256=ApUDpLRBAHgU0wGzFxZ3po2XYfeSzrbW2WUH45jZU5M,1971
 swibots/api/community/controllers/rolemember_controller.py,sha256=VhbYPXlijwr4Cp4YLaPIG8El_LU1eu-gB4GFm-UjCyM,1789
 swibots/api/community/controllers/roles_controller.py,sha256=227JK6UG5SfGFPhbOthSxfoG1DPRcNajbQKon9dMDuQ,1925
@@ -150,15 +159,15 @@
 swibots/api/community/models/rolemember.py,sha256=ZASW7ifyN5X8CoHNlZZNgE99ctF30HrchhpzgUJQeto,1510
 swibots/api/community/models/rolepermission.py,sha256=W_XotKDCIanICriHz0Sl_9B3Yz6tttv5Bj5EVC_gA40,3256
 swibots/base/__init__.py,sha256=rjIbuXLLehoAQrtTV9tCGHHL0-VeY8cUQHgBAa67DXQ,268
 swibots/base/rest_controller.py,sha256=Q35s7TkTZ7q51LBjOXcxPM31NdTkAiJKvKh03K-rsEc,67
 swibots/base/rest_request.py,sha256=6MwcxVPmdfVhvHcCmFpKl5uAj3BVv3isc6Z3csMweL0,423
 swibots/base/rest_response.py,sha256=fTC3uyu258T6OOqNNvaLqBh3bDzIU2semchNfB7W53U,695
 swibots/base/switch_client.py,sha256=25qHWovhgEyxAd38R6kulfqs3A5hFpl7rdhEpWseRCQ,5310
-swibots/base/switch_object.py,sha256=MdJQ50_R5io2tdxg-rp9PRsbcEVBZsecFcGC91AZxgo,1621
+swibots/base/switch_object.py,sha256=EV9voYrt0SaYjFSR2R5vqA68O4jzFfdu37qpu0t6I6s,1884
 swibots/base/switch_ws_async_client.py,sha256=xYlDs8xeR9H675cvYS3A1-xzFPCm7Qq2chHzd8OdMxY,563
 swibots/bots/__init__.py,sha256=KVaOjF-dHLMKeqrzz5uSzHAAb2mjdK4JeoG4Sptami8,135
 swibots/bots/bot.py,sha256=PPkeEN2khTTpNMujKh67RQuwRUpjURPAb4cixDHtMzc,2924
 swibots/bots/bot_context.py,sha256=uQRJ42WRqJz87ifBQdwuy5a8gRc-VlVRu4cculAye7Y,2112
 swibots/bots/decorators/__init__.py,sha256=FsxkZEMV__PgjxlEHeHYbUkGEpoFLaxDV4FwJ191o9Y,1034
 swibots/bots/decorators/on_callback_query.py,sha256=hD8L4O8qPGsovH65nz8QvLnG8r1D1VizNX25UCohb_w,598
 swibots/bots/decorators/on_channel_created.py,sha256=pbZ6tWaZ-r7qLLIKXrWoK7TKQbfA9vFzA8Q20HrOxyI,582
@@ -172,15 +181,15 @@
 swibots/bots/decorators/on_inline_query.py,sha256=RMhnicLmCEN_xYaNIZYwYFKjzB9Dl14apDYZ02fPdQc,548
 swibots/bots/decorators/on_member_joined.py,sha256=pgdqztLoRtGE3LBeQybQ6AALHIJ9Vi4_9CmzkpCcz-I,592
 swibots/bots/decorators/on_member_left.py,sha256=78dWlC00HGGMBw5ocbk5bZUjWxmD6t8vcsypoyPHkAs,546
 swibots/bots/decorators/on_message.py,sha256=uuBKuBBNGQ0xImXVyGhW41lORAkE7UklVaOo5jE01W4,535
 swibots/bots/decorators/on_unknown_command.py,sha256=fkvONkRnXXyU8nxXObKZ2UyvHQVmwPATZVpzUetor3A,601
 swibots/bots/decorators/on_user_banned.py,sha256=56CBYr3lajBDUa7cRrNXpdTdiyXjEvgjpcXskHaM2ms,541
 swibots/bots/filters/__init__.py,sha256=9QviEekw4wNRJgdpK2nD8TbFWgFKTig_egM1kgpQpps,23
-swibots/bots/filters/filter.py,sha256=uQEmQluVX04w4TbZ97CnfBYcv7_u5m6XG-zBvzCo1bo,10341
+swibots/bots/filters/filter.py,sha256=CsZMlvI0_a0LjjKOjR3f5AMUuWifIrNMoonftjykY7E,10648
 swibots/bots/handlers/__init__.py,sha256=mUR-06fKnW4L3xAc1B6MFLM6ml2rNvywkfpHNdrZkmY,1337
 swibots/bots/handlers/base_handler.py,sha256=fNSEr0jPSc2kp7k8rJ3wWv-PaivSPh5YcV5aIQVRATg,1087
 swibots/bots/handlers/callback_query_handler.py,sha256=G-sSsBAr8Fw9dGtTGlLcFGcTemq730iOwvGTeQVkYA4,1016
 swibots/bots/handlers/channel_created_handler.py,sha256=RDkDZANCSCLrzUALjRv7dsX4Ch4_IPKq3NMfR5wuHZ0,704
 swibots/bots/handlers/channel_deleted_handler.py,sha256=VfAP85AwpnQMsnu7amCOs4W-ow5gh8qDSgwPZavBhBo,711
 swibots/bots/handlers/channel_updated_handler.py,sha256=LsEttHvEy-GXNNNirMa7tjS65Y1ADo8D2seFVBfDViw,758
 swibots/bots/handlers/command_handler.py,sha256=8Lkmp7wpazQpy8vWzGm3hsJFv1h8b_cZj_kEa8fxK8Y,1621
@@ -193,20 +202,20 @@
 swibots/bots/handlers/member_joined_handler.py,sha256=gfMrCRUrxjE8Luph3LrsDv8MtOrlYNuxbwMh5hPMAQU,702
 swibots/bots/handlers/member_left_handler.py,sha256=qrkibfbpxoTdEaqrdYYeG91xQOhBlumIy_w6MI-5Liw,697
 swibots/bots/handlers/message_handler.py,sha256=RpTfj4uvnekQvkvayd4BE0UzOgtKGPL46We0fOvCutA,996
 swibots/bots/handlers/unknown_command_handler.py,sha256=l-3hL-WRjpb8mRLs3Q6uGaAdvf4x0RZbYkyQir-9fUk,897
 swibots/bots/handlers/user_banned_handler.py,sha256=bGhq6iefkXc8aDqXTxlObHhQSVIORyIPiyrl38Naauw,693
 swibots/utils/__init__.py,sha256=pC9lvDy4VgEuub2xjObv8zEq3znI4v4JQvOgxbpNI2M,242
 swibots/utils/rest_client.py,sha256=MTaBIDpg2z6nsj8zY8zuzk0EI3HHhame7mH8EepFcB8,6075
-swibots/utils/types.py,sha256=uKm-PqZR_vNeBRglJmX-llmMocAvuc2BkLJ_N6KFSG8,4740
+swibots/utils/types.py,sha256=yhRKEAsd-1OdPijhiH8f66jfVBiQtdLzuc4PxADz2ew,4948
 swibots/utils/ws/__init__.py,sha256=JhJrTkP0H3id28PwAEKKZPERMAGrhIJn_AqDCTwwnuQ,50
 swibots/utils/ws/asyncstomp/__init__.py,sha256=SsfNbSHj_wkD2Q0yvNahVGm8NSXf7aAiRYgw9l1sSH8,154
-swibots/utils/ws/asyncstomp/async_ws_client.py,sha256=dizyW2vKEVMuMdTfHGQnDEjq5cJ9AqfphO76oI-XFjg,10196
+swibots/utils/ws/asyncstomp/async_ws_client.py,sha256=Eu9Y5wfrksEfoWXXGKan2NYXiri6-2NIaESjT8DRSS8,10397
 swibots/utils/ws/asyncstomp/async_ws_subscription.py,sha256=Feg7mxIdTFj2HWlC4xIpNKcXGLqXoUpEjCU38nfrQfE,1054
 swibots/utils/ws/common/__init__.py,sha256=_hzhPpjCriACuAXEV3cmzSD-BK6gn3PMLYf70L4lGkM,104
 swibots/utils/ws/common/ws_frame.py,sha256=HLvqFu97eeIdIH84NIKxVSF00yg4hfpju2tB8Q41sQE,1699
 swibots/utils/ws/common/ws_message.py,sha256=Rv0LNtis7GQkreXYTOLIUMHOWoFUWOQkRoEC_uwo0t8,439
-swibots-1.4.9.dist-info/LICENSE.md,sha256=vrjkLp1rQoTgMwTQWoGgdVIAqWX8jQpeCuoehM-AXW4,1361
-swibots-1.4.9.dist-info/METADATA,sha256=SQo_AvKe3nVntV8dX6COSmqSeDeZpQRpgFouU7bA8OE,6046
-swibots-1.4.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-swibots-1.4.9.dist-info/top_level.txt,sha256=qOeBtK0yOFT2JC7k6eCuwnkjcRkmWmjHKTMXIjy3HqU,8
-swibots-1.4.9.dist-info/RECORD,,
+swibots-1.4.9b0.dist-info/LICENSE.md,sha256=vrjkLp1rQoTgMwTQWoGgdVIAqWX8jQpeCuoehM-AXW4,1361
+swibots-1.4.9b0.dist-info/METADATA,sha256=Nq1Cb3nODgBEAbxyifWH9gA2umW7a8CUFIl4JyMJUaE,7138
+swibots-1.4.9b0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+swibots-1.4.9b0.dist-info/top_level.txt,sha256=qOeBtK0yOFT2JC7k6eCuwnkjcRkmWmjHKTMXIjy3HqU,8
+swibots-1.4.9b0.dist-info/RECORD,,
```

