# Comparing `tmp/OctoBot-Trading-2.4.85.tar.gz` & `tmp/OctoBot-Trading-2.4.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "OctoBot-Trading-2.4.85.tar", last modified: Fri May 31 22:19:11 2024, max compression
+gzip compressed data, was "OctoBot-Trading-2.4.9.tar", last modified: Sun Jul 23 14:16:07 2023, max compression
```

## Comparing `OctoBot-Trading-2.4.85.tar` & `OctoBot-Trading-2.4.9.tar`

### file list

```diff
@@ -1,586 +1,576 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.739644 OctoBot-Trading-2.4.85/
--rw-r--r--   0 runner    (1001) docker     (127)    40838 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/CHANGELOG.md
--rw-r--r--   0 runner    (1001) docker     (127)     7652 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)      141 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/MANIFEST.in
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.671645 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     1807 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    25029 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (127)      241 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       39 2024-05-31 22:19:11.000000 OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)     1807 2024-05-31 22:19:11.739644 OctoBot-Trading-2.4.85/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     1172 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.671645 OctoBot-Trading-2.4.85/octobot_trading/
--rw-r--r--   0 runner    (1001) docker     (127)      793 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/api/
--rw-r--r--   0 runner    (1001) docker     (127)    11795 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1506 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/channels.py
--rw-r--r--   0 runner    (1001) docker     (127)     1241 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/contracts.py
--rw-r--r--   0 runner    (1001) docker     (127)    12179 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     3051 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/modes.py
--rw-r--r--   0 runner    (1001) docker     (127)     3856 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/orders.py
--rw-r--r--   0 runner    (1001) docker     (127)     4079 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     1521 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/positions.py
--rw-r--r--   0 runner    (1001) docker     (127)     3278 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/profitability.py
--rw-r--r--   0 runner    (1001) docker     (127)     2811 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     4867 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     2535 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/trader.py
--rw-r--r--   0 runner    (1001) docker     (127)     3418 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/api/trades.py
--rw-r--r--   0 runner    (1001) docker     (127)     8854 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/constants.py
--rw-r--r--   0 runner    (1001) docker     (127)    15516 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/enums.py
--rw-r--r--   0 runner    (1001) docker     (127)     5868 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/errors.py
--rw-r--r--   0 runner    (1001) docker     (127)     9214 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_channel.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/
--rw-r--r--   0 runner    (1001) docker     (127)     7200 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/
--rw-r--r--   0 runner    (1001) docker     (127)     1316 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2776 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/contract_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     5365 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/future_contract.py
--rw-r--r--   0 runner    (1001) docker     (127)     3366 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/margin_contract.py
--rw-r--r--   0 runner    (1001) docker     (127)     7915 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/exchange_symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     1856 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/exchange_symbols_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/
--rw-r--r--   0 runner    (1001) docker     (127)     1220 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1382 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3130 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding.py
--rw-r--r--   0 runner    (1001) docker     (127)     7966 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     2919 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     1850 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/funding_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/
--rw-r--r--   0 runner    (1001) docker     (127)     1187 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1343 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2675 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline.py
--rw-r--r--   0 runner    (1001) docker     (127)     3952 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     2776 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     2968 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/kline_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.675645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/
--rw-r--r--   0 runner    (1001) docker     (127)     1953 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4740 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/candles_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)    10436 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1342 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2862 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py
--rw-r--r--   0 runner    (1001) docker     (127)    15576 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     8745 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     5226 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/
--rw-r--r--   0 runner    (1001) docker     (127)     1469 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1562 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4907 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book.py
--rw-r--r--   0 runner    (1001) docker     (127)     4028 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     2642 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     7930 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/order_book_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/
--rw-r--r--   0 runner    (1001) docker     (127)     1525 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1382 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3046 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/price.py
--rw-r--r--   0 runner    (1001) docker     (127)     7729 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/prices_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     2313 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     7179 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/price_events_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/prices_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/
--rw-r--r--   0 runner    (1001) docker     (127)     1502 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1593 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4238 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py
--rw-r--r--   0 runner    (1001) docker     (127)     3903 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     6637 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     2366 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/
--rw-r--r--   0 runner    (1001) docker     (127)     1301 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.679645 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1458 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8225 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker.py
--rw-r--r--   0 runner    (1001) docker     (127)     5312 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     5787 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     3023 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/ticker_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.683645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/
--rw-r--r--   0 runner    (1001) docker     (127)     6086 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29121 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/abstract_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     8019 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/abstract_websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.683645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/adapters/
--rw-r--r--   0 runner    (1001) docker     (127)      909 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/adapters/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9240 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/adapters/abstract_adapter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.683645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/
--rw-r--r--   0 runner    (1001) docker     (127)     1125 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1023 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/backtesting_exchange_config.py
--rw-r--r--   0 runner    (1001) docker     (127)    16606 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/exchange_config_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.683645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/
--rw-r--r--   0 runner    (1001) docker     (127)     1229 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.683645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/
--rw-r--r--   0 runner    (1001) docker     (127)     1309 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    22961 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)    10113 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1157 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_clients_cache.py
--rw-r--r--   0 runner    (1001) docker     (127)    41005 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
--rw-r--r--   0 runner    (1001) docker     (127)    46956 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
--rw-r--r--   0 runner    (1001) docker     (127)      761 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/constants.py
--rw-r--r--   0 runner    (1001) docker     (127)     3541 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/enums.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/
--rw-r--r--   0 runner    (1001) docker     (127)     1216 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1130 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/ccxt_client_simulation.py
--rw-r--r--   0 runner    (1001) docker     (127)     1462 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)    13173 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
--rw-r--r--   0 runner    (1001) docker     (127)    11541 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_builder.py
--rw-r--r--   0 runner    (1001) docker     (127)     8439 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_channels.py
--rw-r--r--   0 runner    (1001) docker     (127)      877 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_details.py
--rw-r--r--   0 runner    (1001) docker     (127)     6574 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    15482 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     3694 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_websocket_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     3329 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchanges.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/
--rw-r--r--   0 runner    (1001) docker     (127)     1366 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1483 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/default_rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     1964 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/default_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     6636 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/exchange_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/
--rw-r--r--   0 runner    (1001) docker     (127)     1042 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    44121 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/trader.py
--rw-r--r--   0 runner    (1001) docker     (127)     1684 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/trader_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/
--rw-r--r--   0 runner    (1001) docker     (127)     1068 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    49968 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     9555 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/
--rw-r--r--   0 runner    (1001) docker     (127)     2874 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15651 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/exchange_market_status_fixer.py
--rw-r--r--   0 runner    (1001) docker     (127)    20859 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/exchange_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1313 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/symbol_details.py
--rw-r--r--   0 runner    (1001) docker     (127)     2212 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/websockets_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.687645 OctoBot-Trading-2.4.85/octobot_trading/modes/
--rw-r--r--   0 runner    (1001) docker     (127)     3232 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    22902 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/abstract_trading_mode.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/modes/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1414 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14732 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/channel/abstract_mode_consumer.py
--rw-r--r--   0 runner    (1001) docker     (127)    27193 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/channel/abstract_mode_producer.py
--rw-r--r--   0 runner    (1001) docker     (127)     5567 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/channel/mode.py
--rw-r--r--   0 runner    (1001) docker     (127)     1123 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/mode_activity.py
--rw-r--r--   0 runner    (1001) docker     (127)     6469 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/mode_config.py
--rw-r--r--   0 runner    (1001) docker     (127)     5468 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/modes_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     9942 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/modes_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/
--rw-r--r--   0 runner    (1001) docker     (127)     2615 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/
--rw-r--r--   0 runner    (1001) docker     (127)     2838 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6854 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
--rw-r--r--   0 runner    (1001) docker     (127)     4964 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/amount.py
--rw-r--r--   0 runner    (1001) docker     (127)     2992 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/configuration.py
--rw-r--r--   0 runner    (1001) docker     (127)     2317 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/position.py
--rw-r--r--   0 runner    (1001) docker     (127)     3358 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/price.py
--rw-r--r--   0 runner    (1001) docker     (127)     1723 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py
--rw-r--r--   0 runner    (1001) docker     (127)      995 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
--rw-r--r--   0 runner    (1001) docker     (127)     4763 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    25786 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/context_management.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/
--rw-r--r--   0 runner    (1001) docker     (127)      943 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2550 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/quantity.py
--rw-r--r--   0 runner    (1001) docker     (127)     1429 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/values.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/modes/scripted_trading_mode/
--rw-r--r--   0 runner    (1001) docker     (127)     1063 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/scripted_trading_mode/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16335 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py
--rw-r--r--   0 runner    (1001) docker     (127)     5502 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/octobot_channel_consumer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.691645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/
--rw-r--r--   0 runner    (1001) docker     (127)    12502 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19668 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/exchange_personal_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.695645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/
--rw-r--r--   0 runner    (1001) docker     (127)     7568 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.695645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1361 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15334 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders.py
--rw-r--r--   0 runner    (1001) docker     (127)    10695 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     1819 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)    15250 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/decimal_order_adapter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.695645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/
--rw-r--r--   0 runner    (1001) docker     (127)     1573 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9936 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py
--rw-r--r--   0 runner    (1001) docker     (127)     1973 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/group_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     3475 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py
--rw-r--r--   0 runner    (1001) docker     (127)    44943 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order.py
--rw-r--r--   0 runner    (1001) docker     (127)    10764 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)     6438 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     2352 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_group.py
--rw-r--r--   0 runner    (1001) docker     (127)     4999 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)    30741 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    11706 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/orders_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     5564 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/orders_storage_operations.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.695645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/
--rw-r--r--   0 runner    (1001) docker     (127)     2133 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5472 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/cancel_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     2911 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/close_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     5823 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/fill_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     4964 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/open_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     2199 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/order_state_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     1166 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     4900 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/pending_creation_order_state.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.695645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/
--rw-r--r--   0 runner    (1001) docker     (127)     2031 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.699645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/
--rw-r--r--   0 runner    (1001) docker     (127)     2172 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      987 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     6128 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)      989 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     2214 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     2088 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     2074 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     2091 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/take_profit_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.699645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/
--rw-r--r--   0 runner    (1001) docker     (127)     1335 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      997 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/buy_market_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     1922 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/market_order.py
--rw-r--r--   0 runner    (1001) docker     (127)      999 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/sell_market_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.699645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/
--rw-r--r--   0 runner    (1001) docker     (127)     1204 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2048 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     8595 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py
--rw-r--r--   0 runner    (1001) docker     (127)      971 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/unknown_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     1400 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/unsupported_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.699645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/
--rw-r--r--   0 runner    (1001) docker     (127)     4264 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4780 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/asset.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.699645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/
--rw-r--r--   0 runner    (1001) docker     (127)     1283 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8724 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/future_asset.py
--rw-r--r--   0 runner    (1001) docker     (127)     4424 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/margin_asset.py
--rw-r--r--   0 runner    (1001) docker     (127)     2162 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/spot_asset.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1690 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5023 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance.py
--rw-r--r--   0 runner    (1001) docker     (127)     6447 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     1006 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/
--rw-r--r--   0 runner    (1001) docker     (127)     1536 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2391 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_asset_value.py
--rw-r--r--   0 runner    (1001) docker     (127)     1090 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    18387 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)    14707 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     1368 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    15883 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     7893 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_profitability.py
--rw-r--r--   0 runner    (1001) docker     (127)    10238 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    18764 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_value_holder.py
--rw-r--r--   0 runner    (1001) docker     (127)     3270 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/sub_portfolio.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/
--rw-r--r--   0 runner    (1001) docker     (127)     1325 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10111 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/future_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     1430 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/margin_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     4915 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/spot_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)    19817 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/value_converter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/
--rw-r--r--   0 runner    (1001) docker     (127)     2669 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1351 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5080 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions.py
--rw-r--r--   0 runner    (1001) docker     (127)    11218 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     4971 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)    39331 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position.py
--rw-r--r--   0 runner    (1001) docker     (127)     2266 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     3297 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_state.py
--rw-r--r--   0 runner    (1001) docker     (127)      950 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    12317 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/positions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/
--rw-r--r--   0 runner    (1001) docker     (127)     1616 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1187 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/active_position_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     4093 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/idle_position_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     2897 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/liquidate_position_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     1821 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/position_state_factory.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.703645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/
--rw-r--r--   0 runner    (1001) docker     (127)     1126 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8679 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/inverse_position.py
--rw-r--r--   0 runner    (1001) docker     (127)     7069 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/linear_position.py
--rw-r--r--   0 runner    (1001) docker     (127)     8783 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/state.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/
--rw-r--r--   0 runner    (1001) docker     (127)     1897 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1135 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2808 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/trades.py
--rw-r--r--   0 runner    (1001) docker     (127)     4664 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/trades_updater.py
--rw-r--r--   0 runner    (1001) docker     (127)     9768 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade.py
--rw-r--r--   0 runner    (1001) docker     (127)     2687 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     6842 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade_pnl.py
--rw-r--r--   0 runner    (1001) docker     (127)     6837 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trades_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     4702 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trades_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/
--rw-r--r--   0 runner    (1001) docker     (127)     1877 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1647 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transaction.py
--rw-r--r--   0 runner    (1001) docker     (127)     5136 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transaction_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     3896 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transactions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/
--rw-r--r--   0 runner    (1001) docker     (127)     1615 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2401 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/blockchain_transaction.py
--rw-r--r--   0 runner    (1001) docker     (127)     1790 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/fee_transaction.py
--rw-r--r--   0 runner    (1001) docker     (127)     2166 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py
--rw-r--r--   0 runner    (1001) docker     (127)     1171 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/transfer_transaction.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/signals/
--rw-r--r--   0 runner    (1001) docker     (127)     1983 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.707645 OctoBot-Trading-2.4.85/octobot_trading/signals/channel/
--rw-r--r--   0 runner    (1001) docker     (127)     1570 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/channel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6250 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/channel/remote_trading_signal.py
--rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     2790 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/channel/signal_producer.py
--rw-r--r--   0 runner    (1001) docker     (127)     5926 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/signal_creation.py
--rw-r--r--   0 runner    (1001) docker     (127)    12700 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/trading_signal_bundle_builder.py
--rw-r--r--   0 runner    (1001) docker     (127)     4622 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/signals/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.711645 OctoBot-Trading-2.4.85/octobot_trading/storage/
--rw-r--r--   0 runner    (1001) docker     (127)     2241 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7462 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/abstract_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     4457 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/candles_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)    10919 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/orders_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     5390 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/portfolio_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     5195 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/storage_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     9530 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/trades_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     4734 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/transactions_storage.py
--rw-r--r--   0 runner    (1001) docker     (127)     2231 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/storage/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.711645 OctoBot-Trading-2.4.85/octobot_trading/supervisors/
--rw-r--r--   0 runner    (1001) docker     (127)     1150 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/supervisors/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2036 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/supervisors/abstract_portfolio_supervisor.py
--rw-r--r--   0 runner    (1001) docker     (127)     3385 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/supervisors/abstract_supervisor.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.711645 OctoBot-Trading-2.4.85/octobot_trading/util/
--rw-r--r--   0 runner    (1001) docker     (127)     2175 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6026 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/config_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1234 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/initializable.py
--rw-r--r--   0 runner    (1001) docker     (127)     1158 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/initialization_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2025 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/simulator_updater_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.711645 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/
--rw-r--r--   0 runner    (1001) docker     (127)      715 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4531 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/exchange_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     9623 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/exchanges_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (127)     6672 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (127)     3809 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/websocket_test_tools.py
--rw-r--r--   0 runner    (1001) docker     (127)      652 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-31 22:19:11.739644 OctoBot-Trading-2.4.85/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)     1985 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.667645 OctoBot-Trading-2.4.85/tests/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/api/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1854 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_channels.py
--rw-r--r--   0 runner    (1001) docker     (127)     2148 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_modes.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_orders.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_profitability.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_symbol_data.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_trader.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/api/test_trades.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/cli/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/cli/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/
--rw-r--r--   0 runner    (1001) docker     (127)     1486 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/contracts/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/contracts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3697 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/contracts/test_future_contract.py
--rw-r--r--   0 runner    (1001) docker     (127)     3044 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/contracts/test_margin_contract.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/funding/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/funding/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2834 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/funding/test_funding_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/kline/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/kline/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4470 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/kline/test_kline_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6941 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/test_candles_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)     8970 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/test_candles_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/order_book/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/order_book/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9729 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/order_book/test_order_book_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/prices/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/prices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10397 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/prices/test_price_events_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     9662 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/prices/test_prices_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/recent_trades/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/recent_trades/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5439 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/recent_trades/test_recent_trades_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     1866 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/test_exchange_symbols_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.715644 OctoBot-Trading-2.4.85/tests/exchange_data/ticker/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/ticker/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4436 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchange_data/ticker/test_ticker_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/
--rw-r--r--   0 runner    (1001) docker     (127)    13726 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/connectors/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/connectors/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    90643 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/mock_exchanges_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     8935 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/test_ccxt_connector.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/implementations/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/implementations/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2191 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/implementations/test_default_rest_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     5924 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/implementations/test_default_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     3346 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_abstract_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     2908 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_abstract_websocket_exchange.py
--rw-r--r--   0 runner    (1001) docker     (127)     2379 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_builder.py
--rw-r--r--   0 runner    (1001) docker     (127)     8274 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_config_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     2363 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     4833 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     7326 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     7399 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/test_exchanges.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/traders/
--rw-r--r--   0 runner    (1001) docker     (127)     4719 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/traders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    52865 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/traders/test_trader.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/types/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1496 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/types/test_websocket_exchange.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/exchanges/util/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14405 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/util/test_exchange_market_status_fixer.py
--rw-r--r--   0 runner    (1001) docker     (127)    12443 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/exchanges/util/test_exchange_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/modes/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.719645 OctoBot-Trading-2.4.85/tests/modes/script_keywords/
--rw-r--r--   0 runner    (1001) docker     (127)     3068 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    12758 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/test_account_balance.py
--rw-r--r--   0 runner    (1001) docker     (127)    15267 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/test_amount.py
--rw-r--r--   0 runner    (1001) docker     (127)     2536 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/test_position.py
--rw-r--r--   0 runner    (1001) docker     (127)     7386 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/test_price.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/modes/script_keywords/dsl/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/dsl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6845 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/script_keywords/dsl/test_quantity.py
--rw-r--r--   0 runner    (1001) docker     (127)     7567 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/test_abstract_mode_consumer.py
--rw-r--r--   0 runner    (1001) docker     (127)    16791 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/test_abstract_trading_mode.py
--rw-r--r--   0 runner    (1001) docker     (127)    14480 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/modes/test_modes_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/personal_data/
--rw-r--r--   0 runner    (1001) docker     (127)     1311 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/personal_data/orders/
--rw-r--r--   0 runner    (1001) docker     (127)     4852 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/
--rw-r--r--   0 runner    (1001) docker     (127)     1157 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19148 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py
--rw-r--r--   0 runner    (1001) docker     (127)     1292 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_group_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     6753 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.723645 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3919 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_cancel_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     1439 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_close_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     2808 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_fill_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     1626 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_open_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     4160 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     5907 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_order_state_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     1837 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     2024 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_pending_creation_order_state.py
--rw-r--r--   0 runner    (1001) docker     (127)    29540 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_decimal_order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)     5685 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_double_filled_order.py
--rw-r--r--   0 runner    (1001) docker     (127)    23120 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order.py
--rw-r--r--   0 runner    (1001) docker     (127)    20330 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_adapter.py
--rw-r--r--   0 runner    (1001) docker     (127)    12074 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    30774 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    11223 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_orders_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     3809 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/test_orders_storage_operations.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.727645 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.727645 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2912 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_buy_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     5975 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     5127 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_sell_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     3242 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     4868 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_stop_loss_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     3281 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     5061 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_take_profit_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.727645 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1650 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/test_buy_market_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     1732 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/test_sell_market_order.py
--rw-r--r--   0 runner    (1001) docker     (127)      717 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/test_unknown_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.727645 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      717 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     8964 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.727645 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8347 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_future_asset.py
--rw-r--r--   0 runner    (1001) docker     (127)     4557 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_margin_asset.py
--rw-r--r--   0 runner    (1001) docker     (127)     3401 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_spot_asset.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3265 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    31482 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     2543 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_asset.py
--rw-r--r--   0 runner    (1001) docker     (127)    58545 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     8045 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)     5661 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio_profitability.py
--rw-r--r--   0 runner    (1001) docker     (127)    20383 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio_value_holder.py
--rw-r--r--   0 runner    (1001) docker     (127)    10260 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_value_converter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    85551 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_future_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     1807 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_margin_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (127)     4838 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_spot_portfolio.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/positions/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/positions/channel/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/channel/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/positions/states/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    67901 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/test_position.py
--rw-r--r--   0 runner    (1001) docker     (127)     3185 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/test_position_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     6235 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/test_positions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/positions/types/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    37450 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/types/test_inverse_position.py
--rw-r--r--   0 runner    (1001) docker     (127)    45257 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/positions/types/test_linear_position.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/trades/
--rw-r--r--   0 runner    (1001) docker     (127)     1583 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/trades/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10322 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     3653 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)    15157 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_pnl.py
--rw-r--r--   0 runner    (1001) docker     (127)     3843 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.731644 OctoBot-Trading-2.4.85/tests/personal_data/transactions/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/transactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6321 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/transactions/test_transaction_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    12957 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/personal_data/transactions/test_transactions_manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.735644 OctoBot-Trading-2.4.85/tests/signals/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/signals/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    31580 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/signals/test_trading_signal_bundle_builder.py
--rw-r--r--   0 runner    (1001) docker     (127)    10299 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/signals/test_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.735644 OctoBot-Trading-2.4.85/tests/test_utils/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/test_utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1031 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/test_utils/order_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     4860 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/test_utils/random_numbers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.735644 OctoBot-Trading-2.4.85/tests/util/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9443 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests/util/test_config_util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.735644 OctoBot-Trading-2.4.85/tests_additional/
--rw-r--r--   0 runner    (1001) docker     (127)      716 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-31 22:19:11.739644 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/
--rw-r--r--   0 runner    (1001) docker     (127)     4033 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14136 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/real_exchange_tester.py
--rw-r--r--   0 runner    (1001) docker     (127)     3410 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/real_futures_exchange_tester.py
--rw-r--r--   0 runner    (1001) docker     (127)     7643 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_ascendex.py
--rw-r--r--   0 runner    (1001) docker     (127)     8341 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_binance.py
--rw-r--r--   0 runner    (1001) docker     (127)     8312 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_binance_futures.py
--rw-r--r--   0 runner    (1001) docker     (127)     9459 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bingx.py
--rw-r--r--   0 runner    (1001) docker     (127)     9232 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitfinex.py
--rw-r--r--   0 runner    (1001) docker     (127)     8142 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitget.py
--rw-r--r--   0 runner    (1001) docker     (127)     7703 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bithumb.py
--rw-r--r--   0 runner    (1001) docker     (127)     7461 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitso.py
--rw-r--r--   0 runner    (1001) docker     (127)     7504 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitstamp.py
--rw-r--r--   0 runner    (1001) docker     (127)     7987 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bybit.py
--rw-r--r--   0 runner    (1001) docker     (127)    10469 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bybit_futures.py
--rw-r--r--   0 runner    (1001) docker     (127)     8049 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_coinbase.py
--rw-r--r--   0 runner    (1001) docker     (127)     7626 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_coinex.py
--rw-r--r--   0 runner    (1001) docker     (127)     7707 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_cryptocom.py
--rw-r--r--   0 runner    (1001) docker     (127)     7614 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_gateio.py
--rw-r--r--   0 runner    (1001) docker     (127)     7803 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_hitbtc.py
--rw-r--r--   0 runner    (1001) docker     (127)     7717 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_hollaex.py
--rw-r--r--   0 runner    (1001) docker     (127)     7603 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_htx.py
--rw-r--r--   0 runner    (1001) docker     (127)     8492 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kraken.py
--rw-r--r--   0 runner    (1001) docker     (127)     9074 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kucoin.py
--rw-r--r--   0 runner    (1001) docker     (127)     9478 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kucoin_futures.py
--rw-r--r--   0 runner    (1001) docker     (127)     7207 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_mexc.py
--rw-r--r--   0 runner    (1001) docker     (127)     8039 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_ndax.py
--rw-r--r--   0 runner    (1001) docker     (127)     3508 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okcoin.py
--rw-r--r--   0 runner    (1001) docker     (127)     8930 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okx.py
--rw-r--r--   0 runner    (1001) docker     (127)     8530 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okx_futures.py
--rw-r--r--   0 runner    (1001) docker     (127)     8797 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_phemex.py
--rw-r--r--   0 runner    (1001) docker     (127)     7257 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_poloniex.py
--rw-r--r--   0 runner    (1001) docker     (127)     7416 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_upbit.py
--rw-r--r--   0 runner    (1001) docker     (127)     9086 2024-05-31 22:18:23.000000 OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_wavesexchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.708534 OctoBot-Trading-2.4.9/
+-rw-r--r--   0 runner    (1001) docker     (123)    33500 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7652 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      141 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/MANIFEST.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.624534 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    24477 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)      220 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-07-23 14:16:07.000000 OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-07-23 14:16:07.708534 OctoBot-Trading-2.4.9/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.624534 OctoBot-Trading-2.4.9/octobot_trading/
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.624534 OctoBot-Trading-2.4.9/octobot_trading/api/
+-rw-r--r--   0 runner    (1001) docker     (123)    11247 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1506 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1241 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/contracts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12097 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2941 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/modes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3658 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3532 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/positions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3278 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2811 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4644 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2535 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2829 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/api/trades.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7342 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15253 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/enums.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5208 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/errors.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9264 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_channel.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     7200 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)     1316 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2776 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/contract_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5365 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/future_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3366 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/margin_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7915 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/exchange_symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1856 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/exchange_symbols_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/
+-rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3130 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7966 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2919 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1850 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/funding_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1343 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2628 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3952 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3060 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2968 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/kline_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.628534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/
+-rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4740 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/candles_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10366 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2862 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14900 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8368 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5226 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/
+-rw-r--r--   0 runner    (1001) docker     (123)     1469 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1562 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4907 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4028 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2884 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7930 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/order_book_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/
+-rw-r--r--   0 runner    (1001) docker     (123)     1525 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3046 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/price.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7729 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/prices_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2313 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6900 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/price_events_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7723 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/prices_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.632534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4238 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6871 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2366 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/
+-rw-r--r--   0 runner    (1001) docker     (123)     1301 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8225 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5312 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6039 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3023 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/ticker_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)     5810 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27517 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/abstract_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8019 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/abstract_websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/adapters/
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/adapters/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/adapters/abstract_adapter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/
+-rw-r--r--   0 runner    (1001) docker     (123)     1125 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/backtesting_exchange_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16393 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/exchange_config_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.636534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/
+-rw-r--r--   0 runner    (1001) docker     (123)     1229 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/
+-rw-r--r--   0 runner    (1001) docker     (123)     1309 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18079 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7879 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37015 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45448 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3541 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/enums.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/
+-rw-r--r--   0 runner    (1001) docker     (123)     1216 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      840 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11817 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10719 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8211 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)      877 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_details.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8701 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13982 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3694 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_websocket_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3329 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchanges.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/
+-rw-r--r--   0 runner    (1001) docker     (123)     1366 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1483 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/default_rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1964 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/default_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4548 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/exchange_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/
+-rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42964 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/trader_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45451 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9555 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.640534 OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/
+-rw-r--r--   0 runner    (1001) docker     (123)     2478 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15292 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/exchange_market_status_fixer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17636 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/exchange_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2212 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/websockets_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.644534 OctoBot-Trading-2.4.9/octobot_trading/modes/
+-rw-r--r--   0 runner    (1001) docker     (123)     2665 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16710 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/abstract_trading_mode.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.644534 OctoBot-Trading-2.4.9/octobot_trading/modes/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1414 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11425 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/channel/abstract_mode_consumer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23458 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/channel/abstract_mode_producer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5567 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/channel/mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5949 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/mode_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5251 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/modes_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/modes_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.644534 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     2395 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.644534 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     2463 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5823 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3030 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/amount.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2992 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1723 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py
+-rw-r--r--   0 runner    (1001) docker     (123)      995 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4763 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25931 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/context_management.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.648534 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/
+-rw-r--r--   0 runner    (1001) docker     (123)      943 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/quantity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1301 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/values.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.648534 OctoBot-Trading-2.4.9/octobot_trading/modes/scripted_trading_mode/
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/scripted_trading_mode/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16335 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5502 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/octobot_channel_consumer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.648534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/
+-rw-r--r--   0 runner    (1001) docker     (123)    11980 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19668 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/exchange_personal_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.648534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/
+-rw-r--r--   0 runner    (1001) docker     (123)     7174 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.652534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1361 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14381 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10637 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1727 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13034 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/decimal_order_adapter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.652534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/
+-rw-r--r--   0 runner    (1001) docker     (123)     1573 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9936 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1973 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/group_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3475 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40970 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10764 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5874 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2352 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4875 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22239 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11706 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/orders_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/orders_storage_operations.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.652534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/
+-rw-r--r--   0 runner    (1001) docker     (123)     2133 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5298 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/cancel_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2600 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/close_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5433 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/fill_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4835 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/open_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1777 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/order_state_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4769 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/pending_creation_order_state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.656534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     2031 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.656534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/
+-rw-r--r--   0 runner    (1001) docker     (123)     2172 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      987 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4154 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      989 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2084 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1958 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1944 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1961 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/take_profit_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.656534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/
+-rw-r--r--   0 runner    (1001) docker     (123)     1335 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      997 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/buy_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1995 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      999 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/sell_market_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.656534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/
+-rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1978 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8484 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      971 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/unknown_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1400 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/unsupported_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.660534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/
+-rw-r--r--   0 runner    (1001) docker     (123)     4168 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4780 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.660534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/
+-rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8724 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/future_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4424 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/margin_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2162 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/spot_asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.660534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5023 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6141 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.660534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/
+-rw-r--r--   0 runner    (1001) docker     (123)     1536 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2391 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_asset_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17826 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14685 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1368 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15012 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7238 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9169 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16679 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_value_holder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3270 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/sub_portfolio.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.660534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1325 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10007 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/future_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1430 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/margin_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3615 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/spot_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17489 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/value_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.664534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/
+-rw-r--r--   0 runner    (1001) docker     (123)     2669 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.664534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1351 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5080 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11218 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4971 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39331 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2266 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3297 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)      950 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12317 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/positions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.664534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/
+-rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/active_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4093 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/idle_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2897 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/liquidate_position_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1821 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/position_state_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.664534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1126 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8679 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/inverse_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7069 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/linear_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8783 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.668534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1865 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.668534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1135 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2808 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/trades.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4664 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/trades_updater.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8957 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3863 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6788 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade_pnl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6885 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trades_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3232 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trades_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.668534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/
+-rw-r--r--   0 runner    (1001) docker     (123)     1877 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5136 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transaction_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3896 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transactions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.668534 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1615 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2401 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/blockchain_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/fee_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2166 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/transfer_transaction.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.668534 OctoBot-Trading-2.4.9/octobot_trading/signals/
+-rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.672534 OctoBot-Trading-2.4.9/octobot_trading/signals/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/channel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6250 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/channel/remote_trading_signal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1791 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2790 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/channel/signal_producer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5926 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/signal_creation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12181 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/trading_signal_bundle_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4481 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/signals/util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.672534 OctoBot-Trading-2.4.9/octobot_trading/storage/
+-rw-r--r--   0 runner    (1001) docker     (123)     2159 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6625 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/abstract_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4385 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/candles_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9890 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/orders_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5071 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/portfolio_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5195 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/storage_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8367 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/trades_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4662 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/transactions_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2231 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/storage/util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.672534 OctoBot-Trading-2.4.9/octobot_trading/supervisors/
+-rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/supervisors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2036 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/supervisors/abstract_portfolio_supervisor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3385 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/supervisors/abstract_supervisor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.672534 OctoBot-Trading-2.4.9/octobot_trading/util/
+-rw-r--r--   0 runner    (1001) docker     (123)     2079 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5539 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/config_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1234 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/initializable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/initialization_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1983 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/simulator_updater_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.676534 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/
+-rw-r--r--   0 runner    (1001) docker     (123)      715 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3416 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/exchange_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6927 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/exchanges_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6672 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3809 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/websocket_test_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)      585 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-07-23 14:16:07.708534 OctoBot-Trading-2.4.9/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.620535 OctoBot-Trading-2.4.9/tests/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.676534 OctoBot-Trading-2.4.9/tests/api/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_channels.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2148 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_modes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_orders.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_symbol_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_trader.py
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/api/test_trades.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.676534 OctoBot-Trading-2.4.9/tests/cli/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/cli/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.676534 OctoBot-Trading-2.4.9/tests/exchange_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.676534 OctoBot-Trading-2.4.9/tests/exchange_data/contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/contracts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3697 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/contracts/test_future_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3044 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/contracts/test_margin_contract.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/funding/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/funding/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2834 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/funding/test_funding_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/kline/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/kline/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4470 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/kline/test_kline_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6941 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/test_candles_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8970 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/test_candles_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/order_book/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/order_book/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9729 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/order_book/test_order_book_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/prices/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/prices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10397 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/prices/test_price_events_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9662 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/prices/test_prices_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/recent_trades/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/recent_trades/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5439 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/recent_trades/test_recent_trades_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1866 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/test_exchange_symbols_data.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.680534 OctoBot-Trading-2.4.9/tests/exchange_data/ticker/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/ticker/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4436 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchange_data/ticker/test_ticker_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)    12609 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/connectors/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/connectors/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    90633 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/mock_exchanges_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7906 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/test_ccxt_connector.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/implementations/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/implementations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2191 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/implementations/test_default_rest_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5889 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/implementations/test_default_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3346 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_abstract_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_abstract_websocket_exchange.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2379 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8157 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_config_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2363 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4826 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4508 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7399 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/test_exchanges.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/traders/
+-rw-r--r--   0 runner    (1001) docker     (123)     4719 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/traders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    50875 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/traders/test_trader.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1496 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/types/test_websocket_exchange.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/exchanges/util/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14461 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/util/test_exchange_market_status_fixer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11875 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/exchanges/util/test_exchange_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/modes/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.684534 OctoBot-Trading-2.4.9/tests/modes/script_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)     3033 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.688534 OctoBot-Trading-2.4.9/tests/modes/script_keywords/basic_keywords/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/basic_keywords/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10968 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/basic_keywords/test_account_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7179 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/basic_keywords/test_amount.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.688534 OctoBot-Trading-2.4.9/tests/modes/script_keywords/dsl/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/dsl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6069 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/script_keywords/dsl/test_quantity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8929 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/test_abstract_mode_consumer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14658 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/modes/test_abstract_trading_mode.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.688534 OctoBot-Trading-2.4.9/tests/personal_data/
+-rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.688534 OctoBot-Trading-2.4.9/tests/personal_data/orders/
+-rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.688534 OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/
+-rw-r--r--   0 runner    (1001) docker     (123)     1157 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19148 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_group_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6753 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.692534 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3919 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_cancel_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_close_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2808 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_fill_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_open_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4160 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5046 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_order_state_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2024 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_pending_creation_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25332 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_decimal_order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5685 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_double_filled_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19264 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20330 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_adapter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10685 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27711 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11223 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_orders_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3809 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/test_orders_storage_operations.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.692534 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.692534 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2912 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_buy_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5127 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_sell_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3242 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4868 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_stop_loss_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_take_profit_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.692534 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1650 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/test_buy_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1732 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/test_sell_market_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/test_unknown_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.696534 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8964 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.696534 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.696534 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8347 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_future_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4557 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_margin_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3401 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_spot_asset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.696534 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3265 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31055 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2543 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_asset.py
+-rw-r--r--   0 runner    (1001) docker     (123)    53074 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5687 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5661 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio_profitability.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11149 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio_value_holder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8684 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_value_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.696534 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    85551 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_future_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_margin_portfolio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4838 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_spot_portfolio.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/positions/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/positions/channel/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/channel/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/positions/states/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    67901 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/test_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3185 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/test_position_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6235 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/test_positions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/positions/types/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37450 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/types/test_inverse_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45257 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/positions/types/test_linear_position.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/trades/
+-rw-r--r--   0 runner    (1001) docker     (123)     1408 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/trades/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10750 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3653 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14243 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_pnl.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/personal_data/transactions/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/transactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/transactions/test_transaction_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12957 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/personal_data/transactions/test_transactions_manager.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.700534 OctoBot-Trading-2.4.9/tests/signals/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/signals/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29924 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/signals/test_trading_signal_bundle_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9979 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/signals/test_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.704534 OctoBot-Trading-2.4.9/tests/test_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/test_utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/test_utils/order_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4860 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/test_utils/random_numbers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.704534 OctoBot-Trading-2.4.9/tests/util/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9443 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests/util/test_config_util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.704534 OctoBot-Trading-2.4.9/tests_additional/
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-23 14:16:07.708534 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/
+-rw-r--r--   0 runner    (1001) docker     (123)     3953 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10318 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/real_exchange_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2952 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/real_futures_exchange_tester.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7562 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_ascendex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7549 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_binance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9025 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_binance_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9080 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitfinex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8395 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitget.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7725 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bithumb.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7483 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitso.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7526 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitstamp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8041 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bittrex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8007 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bybit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9037 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bybit_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7131 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_coinbase.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7653 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_coinex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7674 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_cryptocom.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7374 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_gateio.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7670 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_hitbtc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7671 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_hollaex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7253 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_huobi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_huobipro.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8376 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kraken.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7920 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kucoin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9309 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kucoin_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7454 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_mexc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8053 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_ndax.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3628 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okcoin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7589 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okx.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8042 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okx_futures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8360 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_phemex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7282 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_poloniex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7438 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_upbit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9275 2023-07-23 14:14:57.000000 OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_wavesexchange.py
```

### Comparing `OctoBot-Trading-2.4.85/CHANGELOG.md` & `OctoBot-Trading-2.4.9/CHANGELOG.md`

 * *Files 13% similar despite different names*

```diff
@@ -1,356 +1,13 @@
 # Changelog
 All notable changes to this project will be documented in this file.
 
 The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
-## [2.4.85] - 2024-05-31
-### Added
-- [Exchanges] Fix permission issue false positive
-
-## [2.4.84] - 2024-05-26
-### Added
-- [ExchangeData] IncompatibleAssetDetails
-
-## [2.4.83] - 2024-05-16
-### Updated
-- [Orders] log unparsable orders 
-
-## [2.4.82] - 2024-05-15
-### Updated
-- [Exchanges] auto-remove leading and trailing whitespaces 
-
-## [2.4.81] - 2024-05-10
-### Updated
-- [Exchanges] wrap NotSupported and RateLimit ccxt errors
-
-## [2.4.80] - 2024-05-10
-### Fixed
-- [Orders] missing trading permission error
-
-## [2.4.79] - 2024-04-24
-### Updated
-- [Keywords] add ignored orders to amount keyword
-
-## [2.4.78] - 2024-04-15
-### Added
-- [Exchanges] key adapter
-### Updated
-- CCXT to 4.2.95
-
-## [2.4.77] - 2024-04-13
-### Added
-- [Exchanges] Handle inactive markets
-
-## [2.4.76] - 2024-04-12
-### Added
-- [Exchanges] Handle order type open status for symbol
-### Updated
-- [Exchanges] Handle portfolio optimization using limit orders
-
-## [2.4.75] - 2024-04-11
-### Fixed
-- [Exchanges] Properly handle order not found errors
-- [Order] Rare synch issues on creation
-- [Order] Missing ungrouped stop orders when restarting
-
-## [2.4.74] - 2024-04-07
-### Added
-- [Exchanges] ExchangeCompliancyError error
-
-## [2.4.73] - 2024-04-04
-### Added
-- [Exchanges] BinanceUS to full history exchanges
-
-## [2.4.72] - 2024-04-03
-### Added
-- [Exchanges] IS_SKIPPING_EMPTY_CANDLES_IN_OHLCV_FETCH
-
-## [2.4.71] - 2024-04-03
-### Added
-- [API] is_api_permission_error
-
-## [2.4.70] - 2024-03-28
-### Added
-- [API] get_minimal_order_cost
-
-## [2.4.69] - 2024-03-26
-### Added
-- [TradingMode] update activity from consumer
-
-## [2.4.68] - 2024-03-25
-### Added
-- [TradingMode] last_activity
-
-## [2.4.67] - 2024-03-23
-### Updated
-- [TradingMode] Requirements for indexes
-- [Orders] Use creation_time in to_dict
-
-## [2.4.66] - 2024-03-19
-### Updated
-- [CCXT] to 4.2.77
-### Fixed
-- non trading exchange error
-
-## [2.4.65] - 2024-03-19
-### Updated
-- [CCXT] to 4.2.76
-
-## [2.4.64] - 2024-03-17
-### Added
-- [ScriptingKeywords] add allow_holdings_adaptation to get_amount_from_input_amount
-
-## [2.4.63] - 2024-03-15
-### Added
-- [ScriptingKeywords] DELTA_QUOTE price offset
-
-## [2.4.62] - 2024-03-15
-### Added
-- [ScriptingKeywords] price offsets
-
-## [2.4.61] - 2024-03-12
-### Fixed
-- [Orders] chained orders quantity after fees decimals
-
-## [2.4.60] - 2024-03-12
-### Updated
-- [TradingModes] add exchange order ids to cancel_symbol_open_orders
-- [Orders] handle "b" order quantity type
-
-## [2.4.59] - 2024-03-11
-### Fixed
-- [TradingModes] Fix convert_asset_to_target_asset to properly handle fees
-
-## [2.4.58] - 2024-03-07
-### Fixed
-- [ChainedOrders] Outdated limit price
-- [Backtesting] Invalid order fill price
-
-## [2.4.57] - 2024-03-06
-### Updated
-- [Exchange] log last request url on failed retry
-
-## [2.4.56] - 2024-03-05
-### Updated
-- [Exchanges] add details to retrier errors
-
-## [2.4.55] - 2024-02-14
-### Updated
-- [Exchanges] support tentacle exchange market status fixes
-
-## [2.4.54] - 2024-02-13
-### Updated
-- [TradingMode] integrate tags in orders creation
-### Fixed
-- [Orders] cancel_symbol_open_orders return value
-
-## [2.4.53] - 2024-02-02
-### Fixed
-- [Orders] Handle quote-based fees in exchange simulator
-
-## [2.4.52] - 2024-01-30
-### Added
-- [API] Trades utility
-### Fixed
-- [Exchanges] Unidentified auth error in market status loading
-- [Exchanges] Fetch balance error spam on auth error
-
-## [2.4.51] - 2024-01-18
-### Added
-- [CoinEx] Support CoinEx exchange
-
-## [2.4.50] - 2024-01-18
-### Updated
-- [Websocket] Fix websocket reconnection after binance auto disconnect
-
-## [2.4.49] - 2024-01-08
-### Updated
-- [Exchanges] replace Huobi by HTX
-- [CCXT] 4.2.10
-
-## [2.4.48] - 2023-12-15
-### Fixed
-- [Orders] futures orders quantity parsing
-
-## [2.4.47] - 2023-12-11
-### Fixed
-- candles fetch IndexError
-
-## [2.4.46] - 2023-12-11
-### Updated
-- [Kline] always updated database
-- [Candles] fix fetch issues
-
-## [2.4.45] - 2023-12-10
-### Updated
-- [CCXT] 4.1.82
-
-## [2.4.44] - 2023-12-08
-### Added
-- [TradingMode] Health check
-
-## [2.4.43] - 2023-12-06
-### Added
-- [Exchanges] Market status cache
-- [Orders] decimal_adapt_order_quantity_because_fees
-### Updated
-- [CCXT] 4.1.77
-
-## [2.4.42] - 2023-11-17
-### Added
-- [Portfolio] parse_decimal_portfolio: as_decimal param
-
-## [2.4.41] - 2023-11-15
-### Fixed
-- [Orders] Fix parsing issues
-
-## [2.4.40] - 2023-11-01
-### Fixed
-- [Context] Fix rare desynched symbol attribute and remove signal_symbol 
-
-## [2.4.39] - 2023-10-30
-### Fixed
-- [Config] Realtime timeframe issues
-
-## [2.4.38] - 2023-10-29
-### Fixed
-- [Config] handle malformed pairs in get_all_currencies
-
-## [2.4.37] - 2023-10-27
-### Added
-- [API] get_candles_as_list
-
-## [2.4.36] - 2023-10-24
-### Added
-- [Stats] skip history on simulated trading
-
-## [2.4.35] - 2023-10-18
-### Added
-- [TradingModes] add are_initialization_orders_pending
-
-## [2.4.34] - 2023-10-15
-### Added
-- [Orders] add ALLOW_SIMULATED_ORDERS_INSTANT_FILL env var
-- [Backtesting] handle accurate price timeframe when available
-
-## [2.4.33] - 2023-10-11
-### Updated
-- [TradingModes] Missing funds log
-
-## [2.4.32] - 2023-10-11
-### Added
-- [TradingModes] Portfolio optimization basis
-
-## [2.4.31] - 2023-10-04
-### Added
-- [Signals] Sorting
-### Updated
-- [Orders] Chained orders creation issues log
-### Fixed
-- [Orders] Rare filled order crash
-
-## [2.4.30] - 2023-09-26
-### Updated
-- [Storage] increase storage update interval
-
-## [2.4.29] - 2023-09-25
-### Updated
-- [Storage] push open orders
-
-## [2.4.28] - 2023-09-24
-### Updated
-- [Trades] push USD-like volume
-
-## [2.4.27] - 2023-09-12
-### Fixed
-- [Orders] get_split_orders_count_and_increment: take exchange precision into account
-
-## [2.4.26] - 2023-09-07
-### Fixed
-- [PNL] Division error
-- [Exchanges] Stop issues
-
-## [2.4.25] - 2023-09-05
-### Updated
-- [Signals] set UPDATE_WITH_TRIGGERING_ORDER_FEES
-
-## [2.4.24] - 2023-09-03
-### Updated
-- [Backtesting] use local time channel name
-
-## [2.4.23] - 2023-09-01
-### Fixed
-- [ExchangeData] format
-
-## [2.4.22] - 2023-09-01
-### Added
-- [Credentials] warning when sandboxed exchange in credential check
-### Updated
-- [Tickers] ensure seconds in timestamp
-
-## [2.4.21] - 2023-08-30
-### Added
-- [Trades] exchange side trade id handling
-- [Trades] trades aggregate by order id
-### Updated
-- [Orders] raise AuthenticationError on missing trading permissions
-
-## [2.4.20] - 2023-08-25
-### Updated
-- [Dataclasses] use FlexibleDataclass
-
-## [2.4.19] - 2023-08-23
-### Updated
-- [Exchanges] support info and parsed forced markets
-
-## [2.4.18] - 2023-08-17
-### Updated
-- [CCXT] to version 4.0.65
-### Fixed
-- [Storage] handle corrupted db files auto fix
-
-## [2.4.17] - 2023-08-16
-### Added
-- [Orders] %s and %t amounts
-### Fixed
-- [Backtesting] fees on small amounts
-
-## [2.4.16] - 2023-08-14
-### Fixed
-- [Exchanges] unwanted market status load
-
-## [2.4.15] - 2023-08-14
-### Updated
-- [Backtesting] handle forced market statuses
-### Fixed
-- [Exchanges] randomness in symbols processing
-
-## [2.4.14] - 2023-08-07
-### Updated
-- [PortfolioStorage] update profitability
-
-## [2.4.13] - 2023-08-05
-### Updated
-- [Orders][TradingMode] Improve flexibility
-- logs clarity
-
-## [2.4.12] - 2023-07-28
-### Updated
-- [Orders] include minimal info in storage
-
-## [2.4.11] - 2023-07-26
-### Fixed
-- [Portfolio] simulated portfolio history load
-
-## [2.4.10] - 2023-07-24
-### Updated
-- [ExchangeData] default value and typing
-
 ## [2.4.9] - 2023-07-23
 ### Updated
 - [Tests] testing tools
 - [TradingModes] logs on minimum trading volumes
 ### Fixed
 - [Websockets] Reconnection issues
```

### Comparing `OctoBot-Trading-2.4.85/LICENSE` & `OctoBot-Trading-2.4.9/LICENSE`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/PKG-INFO` & `OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: OctoBot-Trading
-Version: 2.4.85
+Version: 2.4.9
 Summary: OctoBot project trading package
 Home-page: https://github.com/Drakkar-Software/OctoBot-Trading
 Author: Drakkar-Software
 Author-email: contact@drakkar.software
 License: LGPL-3.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python :: 3.8
@@ -12,15 +12,15 @@
 Classifier: Operating System :: OS Independent
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX
 Requires-Python: >=3.8
 License-File: LICENSE
 
-# OctoBot-Trading [2.4.85](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.9](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
 OctoBot trading package.
```

### Comparing `OctoBot-Trading-2.4.85/OctoBot_Trading.egg-info/SOURCES.txt` & `OctoBot-Trading-2.4.9/OctoBot_Trading.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -96,21 +96,19 @@
 octobot_trading/exchanges/config/__init__.py
 octobot_trading/exchanges/config/backtesting_exchange_config.py
 octobot_trading/exchanges/config/exchange_config_data.py
 octobot_trading/exchanges/connectors/__init__.py
 octobot_trading/exchanges/connectors/ccxt/__init__.py
 octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py
 octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py
-octobot_trading/exchanges/connectors/ccxt/ccxt_clients_cache.py
 octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py
 octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py
 octobot_trading/exchanges/connectors/ccxt/constants.py
 octobot_trading/exchanges/connectors/ccxt/enums.py
 octobot_trading/exchanges/connectors/simulator/__init__.py
-octobot_trading/exchanges/connectors/simulator/ccxt_client_simulation.py
 octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py
 octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py
 octobot_trading/exchanges/implementations/__init__.py
 octobot_trading/exchanges/implementations/default_rest_exchange.py
 octobot_trading/exchanges/implementations/default_websocket_exchange.py
 octobot_trading/exchanges/implementations/exchange_simulator.py
 octobot_trading/exchanges/traders/__init__.py
@@ -118,34 +116,30 @@
 octobot_trading/exchanges/traders/trader_simulator.py
 octobot_trading/exchanges/types/__init__.py
 octobot_trading/exchanges/types/rest_exchange.py
 octobot_trading/exchanges/types/websocket_exchange.py
 octobot_trading/exchanges/util/__init__.py
 octobot_trading/exchanges/util/exchange_market_status_fixer.py
 octobot_trading/exchanges/util/exchange_util.py
-octobot_trading/exchanges/util/symbol_details.py
 octobot_trading/exchanges/util/websockets_util.py
 octobot_trading/modes/__init__.py
 octobot_trading/modes/abstract_trading_mode.py
-octobot_trading/modes/mode_activity.py
 octobot_trading/modes/mode_config.py
 octobot_trading/modes/modes_factory.py
 octobot_trading/modes/modes_util.py
 octobot_trading/modes/channel/__init__.py
 octobot_trading/modes/channel/abstract_mode_consumer.py
 octobot_trading/modes/channel/abstract_mode_producer.py
 octobot_trading/modes/channel/mode.py
 octobot_trading/modes/script_keywords/__init__.py
 octobot_trading/modes/script_keywords/context_management.py
 octobot_trading/modes/script_keywords/basic_keywords/__init__.py
 octobot_trading/modes/script_keywords/basic_keywords/account_balance.py
 octobot_trading/modes/script_keywords/basic_keywords/amount.py
 octobot_trading/modes/script_keywords/basic_keywords/configuration.py
-octobot_trading/modes/script_keywords/basic_keywords/position.py
-octobot_trading/modes/script_keywords/basic_keywords/price.py
 octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py
 octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py
 octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py
 octobot_trading/modes/script_keywords/dsl/__init__.py
 octobot_trading/modes/script_keywords/dsl/quantity.py
 octobot_trading/modes/script_keywords/dsl/values.py
 octobot_trading/modes/scripted_trading_mode/__init__.py
@@ -343,21 +337,18 @@
 tests/exchanges/types/test_websocket_exchange.py
 tests/exchanges/util/__init__.py
 tests/exchanges/util/test_exchange_market_status_fixer.py
 tests/exchanges/util/test_exchange_util.py
 tests/modes/__init__.py
 tests/modes/test_abstract_mode_consumer.py
 tests/modes/test_abstract_trading_mode.py
-tests/modes/test_modes_util.py
 tests/modes/script_keywords/__init__.py
 tests/modes/script_keywords/basic_keywords/__init__.py
 tests/modes/script_keywords/basic_keywords/test_account_balance.py
 tests/modes/script_keywords/basic_keywords/test_amount.py
-tests/modes/script_keywords/basic_keywords/test_position.py
-tests/modes/script_keywords/basic_keywords/test_price.py
 tests/modes/script_keywords/dsl/__init__.py
 tests/modes/script_keywords/dsl/test_quantity.py
 tests/personal_data/__init__.py
 tests/personal_data/orders/__init__.py
 tests/personal_data/orders/test_decimal_order_adapter.py
 tests/personal_data/orders/test_double_filled_order.py
 tests/personal_data/orders/test_order.py
@@ -379,15 +370,14 @@
 tests/personal_data/orders/states/test_order_state_factory.py
 tests/personal_data/orders/states/test_pending_creation_chained_order_state.py
 tests/personal_data/orders/states/test_pending_creation_order_state.py
 tests/personal_data/orders/types/__init__.py
 tests/personal_data/orders/types/test_unknown_order.py
 tests/personal_data/orders/types/limit/__init__.py
 tests/personal_data/orders/types/limit/test_buy_limit_order.py
-tests/personal_data/orders/types/limit/test_limit_order.py
 tests/personal_data/orders/types/limit/test_sell_limit_order.py
 tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py
 tests/personal_data/orders/types/limit/test_stop_loss_order.py
 tests/personal_data/orders/types/limit/test_take_profit_limit_order.py
 tests/personal_data/orders/types/limit/test_take_profit_order.py
 tests/personal_data/orders/types/market/__init__.py
 tests/personal_data/orders/types/market/test_buy_market_order.py
@@ -422,15 +412,14 @@
 tests/personal_data/positions/types/__init__.py
 tests/personal_data/positions/types/test_inverse_position.py
 tests/personal_data/positions/types/test_linear_position.py
 tests/personal_data/trades/__init__.py
 tests/personal_data/trades/test_trade_factory.py
 tests/personal_data/trades/test_trade_manager.py
 tests/personal_data/trades/test_trade_pnl.py
-tests/personal_data/trades/test_trade_util.py
 tests/personal_data/transactions/__init__.py
 tests/personal_data/transactions/test_transaction_factory.py
 tests/personal_data/transactions/test_transactions_manager.py
 tests/signals/__init__.py
 tests/signals/test_trading_signal_bundle_builder.py
 tests/signals/test_util.py
 tests/test_utils/__init__.py
@@ -441,29 +430,30 @@
 tests_additional/__init__.py
 tests_additional/real_exchanges/__init__.py
 tests_additional/real_exchanges/real_exchange_tester.py
 tests_additional/real_exchanges/real_futures_exchange_tester.py
 tests_additional/real_exchanges/test_ascendex.py
 tests_additional/real_exchanges/test_binance.py
 tests_additional/real_exchanges/test_binance_futures.py
-tests_additional/real_exchanges/test_bingx.py
 tests_additional/real_exchanges/test_bitfinex.py
 tests_additional/real_exchanges/test_bitget.py
 tests_additional/real_exchanges/test_bithumb.py
 tests_additional/real_exchanges/test_bitso.py
 tests_additional/real_exchanges/test_bitstamp.py
+tests_additional/real_exchanges/test_bittrex.py
 tests_additional/real_exchanges/test_bybit.py
 tests_additional/real_exchanges/test_bybit_futures.py
 tests_additional/real_exchanges/test_coinbase.py
 tests_additional/real_exchanges/test_coinex.py
 tests_additional/real_exchanges/test_cryptocom.py
 tests_additional/real_exchanges/test_gateio.py
 tests_additional/real_exchanges/test_hitbtc.py
 tests_additional/real_exchanges/test_hollaex.py
-tests_additional/real_exchanges/test_htx.py
+tests_additional/real_exchanges/test_huobi.py
+tests_additional/real_exchanges/test_huobipro.py
 tests_additional/real_exchanges/test_kraken.py
 tests_additional/real_exchanges/test_kucoin.py
 tests_additional/real_exchanges/test_kucoin_futures.py
 tests_additional/real_exchanges/test_mexc.py
 tests_additional/real_exchanges/test_ndax.py
 tests_additional/real_exchanges/test_okcoin.py
 tests_additional/real_exchanges/test_okx.py
```

### Comparing `OctoBot-Trading-2.4.85/PKG-INFO` & `OctoBot-Trading-2.4.9/PKG-INFO`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: OctoBot-Trading
-Version: 2.4.85
+Version: 2.4.9
 Summary: OctoBot project trading package
 Home-page: https://github.com/Drakkar-Software/OctoBot-Trading
 Author: Drakkar-Software
 Author-email: contact@drakkar.software
 License: LGPL-3.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python :: 3.8
@@ -12,15 +12,15 @@
 Classifier: Operating System :: OS Independent
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: POSIX
 Requires-Python: >=3.8
 License-File: LICENSE
 
-# OctoBot-Trading [2.4.85](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.9](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
 OctoBot trading package.
```

### Comparing `OctoBot-Trading-2.4.85/README.md` & `OctoBot-Trading-2.4.9/README.md`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# OctoBot-Trading [2.4.85](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
+# OctoBot-Trading [2.4.9](https://github.com/Drakkar-Software/OctoBot-Trading/blob/master/CHANGELOG.md)
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/903b6b22bceb4661b608a86fea655f69)](https://app.codacy.com/gh/Drakkar-Software/OctoBot-Trading?utm_source=github.com&utm_medium=referral&utm_content=Drakkar-Software/OctoBot-Trading&utm_campaign=Badge_Grade_Dashboard)
 [![PyPI](https://img.shields.io/pypi/v/OctoBot-Trading.svg)](https://pypi.python.org/pypi/OctoBot-Trading/)
 [![Coverage Status](https://coveralls.io/repos/github/Drakkar-Software/OctoBot-Trading/badge.svg?branch=master)](https://coveralls.io/github/Drakkar-Software/OctoBot-Trading?branch=master)
 [![Github-Action-CI](https://github.com/Drakkar-Software/OctoBot-Trading/workflows/OctoBot-Trading-CI/badge.svg)](https://github.com/Drakkar-Software/OctoBot-Trading/actions)
 [![Build Status](https://cloud.drone.io/api/badges/Drakkar-Software/OctoBot-Trading/status.svg)](https://cloud.drone.io/Drakkar-Software/OctoBot-Trading)
 
 OctoBot trading package.
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/exchange_simulator_adapter.py`

 * *Files 13% similar despite different names*

```diff
@@ -10,9 +10,12 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
-PROJECT_NAME = "OctoBot-Trading"
-VERSION = "2.4.85"  # major.minor.revision
+import octobot_trading.exchanges.adapters as adapters
+
+
+class ExchangeSimulatorAdapter(adapters.AbstractAdapter):
+    pass
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,15 +28,14 @@
 
 from octobot_trading.api.symbol_data import (
     get_symbol_data,
     get_symbol_candles_manager,
     get_symbol_historical_candles,
     create_preloaded_candles_manager,
     are_symbol_candles_initialized,
-    get_candles_as_list,
     get_candle_as_list,
     has_symbol_klines,
     get_symbol_klines,
     get_symbol_candles_count,
     get_symbol_close_candles,
     get_symbol_open_candles,
     get_symbol_high_candles,
@@ -47,16 +46,14 @@
     force_set_mark_price,
     is_mark_price_initialized,
     get_config_symbols,
 )
 from octobot_trading.api.trades import (
     get_trade_history,
     get_completed_pnl_history,
-    is_executed_trade,
-    is_trade_after_or_at,
     get_total_paid_trading_fees,
     get_trade_exchange_name,
     parse_trade_type,
     trade_to_dict,
     get_win_rate,
 )
 from octobot_trading.api.channels import (
@@ -95,15 +92,15 @@
     get_backtesting_data_file,
     get_has_websocket,
     supports_websockets,
     is_compatible_account,
     get_new_ccxt_client,
     get_default_exchange_type,
     is_sponsoring,
-    is_broker_enabled,
+    is_valid_account,
     get_historical_ohlcv,
     get_bot_id,
     get_supported_exchange_types,
     get_trading_pairs,
     get_all_exchange_symbols,
     get_all_exchange_time_frames,
     get_trading_symbols,
@@ -122,15 +119,14 @@
     get_exchange_details,
     cancel_ccxt_throttle_task,
     stop_exchange,
 )
 from octobot_trading.api.modes import (
     get_trading_modes,
     get_trading_mode_symbol,
-    is_trading_mode_symbol_wildcard,
     get_trading_mode_followed_strategy_signals_identifier,
     get_trading_mode_current_state,
     get_activated_trading_mode,
     create_trading_modes,
     create_trading_mode,
 )
 from octobot_trading.api.trader import (
@@ -153,20 +149,16 @@
     get_portfolio,
     get_portfolio_historical_values,
     get_portfolio_currency,
     get_origin_portfolio,
     set_simulated_portfolio_initial_config,
     refresh_real_trader_portfolio,
     format_portfolio,
-    parse_decimal_portfolio,
     get_draw_down,
     get_coefficient_of_determination,
-    get_usd_like_symbol_from_symbols,
-    can_convert_symbol_to_usd_like,
-    is_usd_like_coin,
     get_global_portfolio_currencies_values,
 )
 from octobot_trading.api.profitability import (
     get_profitability_stats,
     get_origin_portfolio_value,
     get_current_portfolio_value,
     get_currency_ref_market_value,
@@ -178,15 +170,14 @@
 from octobot_trading.api.orders import (
     get_open_orders,
     get_order_exchange_name,
     order_to_dict,
     parse_order_type,
     parse_order_status,
     get_order_profitability,
-    get_minimal_order_cost,
     create_order,
     cancel_all_open_orders,
     cancel_all_open_orders_with_currency,
     cancel_order_with_id,
     LOGGER,
 )
 from octobot_trading.api.positions import (
@@ -213,15 +204,14 @@
 
 __all__ = [
     "get_symbol_data",
     "get_symbol_candles_manager",
     "get_symbol_historical_candles",
     "create_preloaded_candles_manager",
     "are_symbol_candles_initialized",
-    "get_candles_as_list",
     "get_candle_as_list",
     "has_symbol_klines",
     "get_symbol_klines",
     "get_symbol_candles_count",
     "get_symbol_close_candles",
     "get_symbol_open_candles",
     "get_symbol_high_candles",
@@ -230,16 +220,14 @@
     "get_symbol_time_candles",
     "create_new_candles_manager",
     "force_set_mark_price",
     "is_mark_price_initialized",
     "get_config_symbols",
     "get_trade_history",
     "get_completed_pnl_history",
-    "is_executed_trade",
-    "is_trade_after_or_at",
     "get_total_paid_trading_fees",
     "get_trade_exchange_name",
     "parse_trade_type",
     "trade_to_dict",
     "get_win_rate",
     "subscribe_to_ohlcv_channel",
     "subscribe_to_trades_channel",
@@ -274,15 +262,15 @@
     "get_backtesting_data_file",
     "get_has_websocket",
     "supports_websockets",
     "is_compatible_account",
     "get_new_ccxt_client",
     "get_default_exchange_type",
     "is_sponsoring",
-    "is_broker_enabled",
+    "is_valid_account",
     "get_historical_ohlcv",
     "get_bot_id",
     "get_supported_exchange_types",
     "get_trading_pairs",
     "get_all_exchange_symbols",
     "get_all_exchange_time_frames",
     "get_trading_symbols",
@@ -299,15 +287,14 @@
     "get_enabled_exchanges_names",
     "get_auto_filled_exchange_names",
     "get_exchange_details",
     "cancel_ccxt_throttle_task",
     "stop_exchange",
     "get_trading_modes",
     "get_trading_mode_symbol",
-    "is_trading_mode_symbol_wildcard",
     "get_trading_mode_followed_strategy_signals_identifier",
     "get_trading_mode_current_state",
     "get_activated_trading_mode",
     "create_trading_modes",
     "create_trading_mode",
     "get_trader",
     "has_trader",
@@ -327,35 +314,30 @@
     "get_portfolio_historical_values",
     "get_portfolio_currency",
     "get_origin_portfolio",
     "set_simulated_portfolio_initial_config",
     "refresh_real_trader_portfolio",
     "get_draw_down",
     "get_coefficient_of_determination",
-    "get_usd_like_symbol_from_symbols",
-    "can_convert_symbol_to_usd_like",
-    "is_usd_like_coin",
     "get_global_portfolio_currencies_values",
     "get_origin_portfolio_value",
     "get_profitability_stats",
     "format_portfolio",
-    "parse_decimal_portfolio",
     "get_current_portfolio_value",
     "get_currency_ref_market_value",
     "get_current_holdings_values",
     "get_current_crypto_currency_value",
     "get_reference_market",
     "get_initializing_currencies_prices",
     "get_open_orders",
     "get_order_exchange_name",
     "order_to_dict",
     "parse_order_type",
     "parse_order_status",
     "get_order_profitability",
-    "get_minimal_order_cost",
     "create_order",
     "cancel_all_open_orders",
     "cancel_all_open_orders_with_currency",
     "cancel_order_with_id",
     "get_positions",
     "close_position",
     "is_inverse_future_contract",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/channels.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/channels.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/contracts.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/contracts.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/exchange.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,16 +15,14 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
 import contextlib
 
 import trading_backend
 
-import octobot_commons.symbols as commons_symbols
-
 import octobot_trading.constants
 import octobot_trading.enums
 import octobot_trading.exchanges.connectors.ccxt.enums
 import octobot_trading.exchanges as exchanges
 import octobot_trading.exchange_data as exchange_data
 
 import octobot_backtesting.api as backtesting_api
@@ -202,27 +200,27 @@
     return exchange_manager.has_websocket
 
 
 def supports_websockets(exchange_name: str, tentacles_setup_config) -> bool:
     return exchanges.supports_websocket(exchange_name, tentacles_setup_config)
 
 
-def get_trading_pairs(exchange_manager) -> list[str]:
+def get_trading_pairs(exchange_manager) -> list:
     return exchange_manager.exchange_config.traded_symbol_pairs
 
 
 def get_all_exchange_symbols(exchange_manager) -> list:
     return exchange_manager.client_symbols
 
 
 def get_all_exchange_time_frames(exchange_manager) -> list:
     return exchange_manager.client_time_frames
 
 
-def get_trading_symbols(exchange_manager) -> list[commons_symbols.Symbol]:
+def get_trading_symbols(exchange_manager) -> list:
     return exchange_manager.exchange_config.traded_symbols
 
 
 def get_trading_timeframes(exchange_manager) -> list:
     return exchange_manager.exchange_config.traded_time_frames
 
 
@@ -277,16 +275,16 @@
     return exchanges.get_default_exchange_type(exchange_name)
 
 
 def is_sponsoring(exchange_name: str) -> bool:
     return trading_backend.is_sponsoring(exchange_name)
 
 
-def is_broker_enabled(exchange_manager) -> bool:
-    return exchange_manager.is_broker_enabled
+def is_valid_account(exchange_manager) -> bool:
+    return exchange_manager.is_valid_account
 
 
 def get_historical_ohlcv(
         exchange_manager, symbol, time_frame, start_time, end_time,
         request_retry_timeout=octobot_trading.constants.HISTORICAL_CANDLES_FETCH_DEFAULT_TIMEOUT
 ):
     return exchanges.get_historical_ohlcv(
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/modes.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/modes.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,18 +22,14 @@
     return exchange_manager.trading_modes
 
 
 def get_trading_mode_symbol(trading_mode) -> list:
     return trading_mode.symbol
 
 
-def is_trading_mode_symbol_wildcard(trading_mode) -> bool:
-    return trading_mode.get_is_symbol_wildcard()
-
-
 def get_trading_mode_followed_strategy_signals_identifier(trading_mode) -> str:
     if trading_mode.is_following_trading_signals():
         return trading_mode.trading_config.get(commons_constants.CONFIG_TRADING_SIGNALS_STRATEGY, "")
     return None
 
 
 def get_trading_mode_current_state(trading_mode) -> tuple:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/orders.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/orders.py`

 * *Files 7% similar despite different names*

```diff
@@ -76,13 +76,7 @@
 
 def get_order_profitability(exchange_manager, order_id) -> float:
     try:
         return exchange_manager.exchange_personal_data.orders_manager.get_order(order_id).get_profitability()
     except KeyError:
         # try in trades (order might be filled and stored in trades)
         return exchange_manager.exchange_personal_data.trades_manager.get_trade(order_id).trade_profitability
-
-
-def get_minimal_order_cost(exchange_manager, symbol) -> float:
-    return personal_data.get_minimal_order_cost(
-        exchange_manager.exchange.get_market_status(symbol, with_fixer=False)
-    )
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/portfolio.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/portfolio.py`

 * *Files 8% similar despite different names*

```diff
@@ -69,36 +69,20 @@
 
 def format_portfolio(portfolio, as_decimal) -> dict:
     if as_decimal:
         return portfolio
     return personal_data.portfolio_to_float(portfolio)
 
 
-def parse_decimal_portfolio(portfolio, as_decimal) -> dict:
-    return personal_data.parse_decimal_portfolio(portfolio, as_decimal=as_decimal)
-
-
 async def refresh_real_trader_portfolio(exchange_manager) -> bool:
     return await exchange_channel.get_chan(octobot_trading.constants.BALANCE_CHANNEL, exchange_manager.id). \
         get_internal_producer(). \
         refresh_real_trader_portfolio(True)
 
 
 def get_draw_down(exchange_manager) -> decimal.Decimal:
     return personal_data.get_draw_down(exchange_manager)
 
 
 async def get_coefficient_of_determination(exchange_manager, use_high_instead_of_end_balance=True):
     return await personal_data.get_coefficient_of_determination(exchange_manager,
                                                                 use_high_instead_of_end_balance)
-
-
-def get_usd_like_symbol_from_symbols(currency: str, symbols) -> str:
-    return personal_data.ValueConverter.get_usd_like_symbol_from_symbols(currency, symbols)
-
-
-def can_convert_symbol_to_usd_like(symbol: str) -> bool:
-    return personal_data.ValueConverter.can_convert_symbol_to_usd_like(symbol)
-
-
-def is_usd_like_coin(coin) -> bool:
-    return personal_data.ValueConverter.is_usd_like_coin(coin)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/positions.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/positions.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/profitability.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/profitability.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/storage.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/symbol_data.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/symbol_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,16 +9,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import decimal
-
 import octobot_commons.enums
 
 import octobot_trading.enums
 import octobot_trading.exchange_data as exchange_data
 import octobot_trading.util as util
 
 
@@ -47,21 +45,14 @@
             get_symbol_data(exchange_manager, symbol, allow_creation=False),
             time_frame
         ).candles_initialized
     except KeyError:
         return False
 
 
-def get_candles_as_list(candles_arrays) -> list:
-    return [
-        exchange_data.get_candle_as_list(candles_arrays, index)
-        for index in range(len(candles_arrays[0]))
-    ]
-
-
 def get_candle_as_list(candles_arrays, candle_index=0) -> list:
     return exchange_data.get_candle_as_list(candles_arrays, candle_index)
 
 
 def has_symbol_klines(symbol_data, time_frame) -> bool:
     return octobot_commons.enums.TimeFrames(time_frame) in symbol_data.symbol_klines
 
@@ -103,15 +94,15 @@
     if candles is not None:
         manager.replace_all_candles(candles)
     return manager
 
 
 def force_set_mark_price(exchange_manager, symbol, price):
     exchange_manager.exchange_symbols_data.get_exchange_symbol_data(symbol).prices_manager.\
-        set_mark_price(decimal.Decimal(str(price)), octobot_trading.enums.MarkPriceSources.EXCHANGE_MARK_PRICE.value)
+        set_mark_price(price, octobot_trading.enums.MarkPriceSources.EXCHANGE_MARK_PRICE.value)
 
 
 def is_mark_price_initialized(exchange_manager, symbol: str) -> bool:
     return exchange_manager.exchange_symbols_data.get_exchange_symbol_data(symbol).prices_manager.\
         valid_price_received_event.is_set()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/trader.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/trader.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/api/trades.py` & `OctoBot-Trading-2.4.9/octobot_trading/api/trades.py`

 * *Files 7% similar despite different names*

```diff
@@ -37,42 +37,25 @@
         )
     )
 
 
 def _trade_filter(trade, quote=None, symbol=None, timestamp=None, include_cancelled=False) -> bool:
     if trade.status is octobot_trading.enums.OrderStatus.CANCELED and not include_cancelled:
         return False
-    if timestamp is not None and not _is_trade_after_or_at(trade, timestamp):
+    if timestamp is not None and not _is_trade_after(trade, timestamp):
         return False
     if quote is not None and commons_symbols.parse_symbol(trade.symbol).quote != quote:
         return False
     elif symbol is not None and trade.symbol != symbol:
         return False
     return True
 
 
-def is_executed_trade(trade: dict) -> bool:
-    try:
-        return trade[octobot_trading.enums.ExchangeConstantsOrderColumns.STATUS.value] not in (
-            octobot_trading.enums.OrderStatus.CANCELED.value,
-            octobot_trading.enums.OrderStatus.EXPIRED.value,
-        )
-    except KeyError:
-        return False
-
-
-def is_trade_after_or_at(trade: dict, timestamp: float) -> bool:
-    try:
-        return trade[octobot_trading.enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] >= timestamp
-    except KeyError:
-        return False
-
-
-def _is_trade_after_or_at(trade: personal_data.Trade, timestamp: float) -> bool:
-    return trade.executed_time >= timestamp or trade.canceled_time >= timestamp
+def _is_trade_after(trade, timestamp) -> bool:
+    return trade.executed_time > timestamp or trade.canceled_time > timestamp
 
 
 def get_total_paid_trading_fees(exchange_manager) -> dict:
     return exchange_manager.exchange_personal_data.trades_manager.get_total_paid_fees()
 
 
 def get_trade_exchange_name(trade) -> str:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/constants.py` & `OctoBot-Trading-2.4.9/octobot_trading/constants.py`

 * *Files 25% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library
 import decimal
 import os
-import typing
 
 import octobot_trading.enums as enums
 import octobot_commons.enums as commons_enums
 import octobot_commons.constants as commons_constants
 import octobot_commons.os_util as os_util
 
 # Strings
@@ -30,35 +29,26 @@
 CONFIG_PORTFOLIO_MARGIN = "margin"
 REAL_TRADER_STR = "[Real Trader] "
 SIMULATOR_TRADER_STR = "[Simulator] "
 
 # Trader
 DEFAULT_REFERENCE_MARKET = "BTC"
 CURRENCY_DEFAULT_MAX_PRICE_DIGITS = 8
-ALLOW_SIMULATED_ORDERS_INSTANT_FILL = os_util.parse_boolean_environment_var(
-    "ALLOW_SIMULATED_ORDERS_INSTANT_FILL", "False"
-)
 
 # Order creation
 ORDER_DATA_FETCHING_TIMEOUT = 5 * commons_constants.MINUTE_TO_SECONDS
-CHAINED_ORDER_PRICE_FETCHING_TIMEOUT = 1    # should be instant or ignored
-CHAINED_ORDERS_OUTDATED_PRICE_ALLOWANCE = decimal.Decimal("0.005")  # allows 0.5% outdated price error
-# create instantly filled limit orders 0.5% beyond market
-INSTANT_FILLED_LIMIT_ORDER_PRICE_DELTA = decimal.Decimal("0.005")
-CREATED_ORDER_FORCED_UPDATE_PERIOD = 5
 
 # Tentacles
 TRADING_MODE_REQUIRED_STRATEGIES = "required_strategies"
 TRADING_MODE_REQUIRED_STRATEGIES_MIN_COUNT = "required_strategies_min_count"
 TENTACLES_TRADING_MODE_PATH = "Mode"
 CONFIG_CANDLES_HISTORY_SIZE_TITLE = "Candles history size"
 CONFIG_CANDLES_HISTORY_SIZE_KEY = CONFIG_CANDLES_HISTORY_SIZE_TITLE.replace(" ", "_")
 CONFIG_BUY_ORDER_AMOUNT = "buy_order_amount"
 CONFIG_SELL_ORDER_AMOUNT = "sell_order_amount"
-TRADING_MODE_ACTIVITY_REASON = "reason"
 
 # Exchange
 DEFAULT_EXCHANGE_TIME_LAG = 10
 DEFAULT_BACKTESTING_TIME_LAG = 0
 INFINITE_MAX_HANDLED_PAIRS_WITH_TIMEFRAME = -1
 DEFAULT_CANDLE_HISTORY_SIZE = 200
 NO_DATA_LIMIT = -1
@@ -67,81 +57,60 @@
 ENABLE_EXCHANGE_HTTP_PROXY_FROM_ENV = os_util.parse_boolean_environment_var(
     "ENABLE_EXCHANGE_HTTP_PROXY_FROM_ENV", "True")
 ENABLE_CCXT_VERBOSE = os_util.parse_boolean_environment_var("ENABLE_CCXT_VERBOSE", "False")
 ENABLE_CCXT_RATE_LIMIT = os_util.parse_boolean_environment_var("ENABLE_CCXT_RATE_LIMIT", "True")
 THROTTLED_WS_UPDATES = float(os.getenv("THROTTLED_WS_UPDATES", "0.1"))  # avoid spamming CPU
 ENABLE_LIVE_CANDLES_STORAGE = os_util.parse_boolean_environment_var("ENABLE_LIVE_CANDLES_STORAGE", "False")
 ENABLE_HISTORICAL_ORDERS_UPDATES_STORAGE = os_util.parse_boolean_environment_var("ENABLE_HISTORICAL_ORDERS_UPDATES_STORAGE", "False")
-MAX_CANDLES_IN_RAM = int(os.getenv("MAX_CANDLES_IN_RAM", "3000"))    # max candles per CandlesManager
 STORAGE_ORIGIN_VALUE = "origin_value"
 DISPLAY_TIME_FRAME = commons_enums.TimeFrames.ONE_HOUR
-DEFAULT_SUBACCOUNT_ID = "default_subaccount_id"
-DEFAULT_ACCOUNT_ID = "default_account_id"
 
 # Decimal default values (decimals are immutable, can be stored as constant)
 ZERO = decimal.Decimal(0)
 ONE = decimal.Decimal(1)
 ONE_HUNDRED = decimal.Decimal(100)
 NaN = decimal.Decimal("nan")
 
 # exchanges where test_get_historical_symbol_prices is successful can be listed here
 FULL_CANDLE_HISTORY_EXCHANGES = [
     "ascendex",
     "binance",
     "bitfinex2",
     "bitstamp",
     "bybit",
-    "bingx",
+    "gateio",
+    "hitbtc",
     "hollaex",
-    "htx",
+    "huobi",
+    "huobipro",
     "kucoin",
     "okcoin",
     "okx",
-    "mexc",
-    "coinbase",
-    "binanceus",
 ]
 
 DEFAULT_FUTURE_EXCHANGES = ["binanceusdm", "bybit"]
 TESTED_EXCHANGES = [
     "binance",
-    "kucoin",
     "okx",
-] + sorted([
-    "binanceus",
-    "coinbase",
-    "cryptocom",
-    "htx",
-    "bitget",
     "gateio",
+    "huobi",
+    "bitget",
     "ascendex",
+    "kucoin",
+    "coinbase",
     "bybit",
+    "cryptocom",
     "phemex",
     "hollaex",
     "mexc",
-    "bingx",
-    "coinex",
-])
-DEFAULT_FUTURE_EXCHANGES = sorted(["bybit"])
-SIMULATOR_TESTED_EXCHANGES = sorted(["bitfinex2", "bithumb", "bitstamp", "bittrex",
-                              "hitbtc", "kraken", "poloniex", "bitso", "ndax", "upbit",
-                              "wavesexchange"])
-
-# text content of errors due to exchange compliancy rules
-# Warning: should never be a false positive
-EXCHANGE_COMPLIANCY_ERRORS: typing.List[typing.Iterable[str]] = [
-    # OKX ex: Trading of this pair or contract is restricted due to local compliance requirements
-    ("restricted", "compliance"),
-]
-
-# text content of errors due to exchange local account permissions (ex: accounts from X country can't trade XYZ)
-EXCHANGE_ACCOUNT_TRADED_SYMBOL_PERMISSION_ERRORS: typing.List[typing.Iterable[str]] = [
-    # Binance ex: InvalidOrder binance {"code":-2010,"msg":"This symbol is not permitted for this account."}
-    ("symbol", "not permitted", "for this account"),
 ]
+DEFAULT_FUTURE_EXCHANGES = ["binanceusdm", "bybit"]
+SIMULATOR_TESTED_EXCHANGES = ["bitfinex2", "bithumb", "bitstamp", "bittrex", "coinex",
+                              "hitbtc", "kraken", "poloniex", "bitso", "ndax", "upbit",
+                              "wavesexchange"]
 
 CONFIG_DEFAULT_FEES = 0.001
 CONFIG_DEFAULT_SIMULATOR_FEES = 0
 
 DEFAULT_SYMBOL_LEVERAGE = ONE
 DEFAULT_SYMBOL_MAX_LEVERAGE = ONE_HUNDRED
 DEFAULT_SYMBOL_MARGIN_TYPE = enums.MarginType.ISOLATED
@@ -211,15 +180,14 @@
 CANCEL_ORDER_STATUS_SCOPE = [enums.OrderStatus.PENDING_CANCEL,
                              enums.OrderStatus.CANCELED,
                              enums.OrderStatus.EXPIRED,
                              enums.OrderStatus.REJECTED]
 
 DEFAULT_INITIALIZATION_EVENT_TOPICS = [
     commons_enums.InitializationEventExchangeTopics.BALANCE,
-    commons_enums.InitializationEventExchangeTopics.PROFITABILITY,
     commons_enums.InitializationEventExchangeTopics.ORDERS,
     commons_enums.InitializationEventExchangeTopics.TRADES,
     commons_enums.InitializationEventExchangeTopics.CANDLES,
     commons_enums.InitializationEventExchangeTopics.PRICE,
 ]
 
 DEFAULT_FUTURES_INITIALIZATION_EVENT_TOPICS = DEFAULT_INITIALIZATION_EVENT_TOPICS + [
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/enums.py` & `OctoBot-Trading-2.4.9/octobot_trading/enums.py`

 * *Files 1% similar despite different names*

```diff
@@ -255,15 +255,14 @@
     LIMITS_AMOUNT_MAX = "max"  # order amount should be < max
     LIMITS_PRICE = "price"  # same min/max limits for the price of the order
     LIMITS_PRICE_MIN = "min"  # order price should be > min
     LIMITS_PRICE_MAX = "max"  # order price should be < max
     LIMITS_COST = "cost"  # same limits for order cost = price * amount
     LIMITS_COST_MIN = "min"  # order cost should be > min
     LIMITS_COST_MAX = "max"  # order cost should be < max
-    TYPE = "type"
     INFO = "info"
 
 
 class ExchangeConstantsMarketStatusInfoColumns(enum.Enum):
     # binance specific
     FILTERS = "filters"
     FILTER_TYPE = "filterType"
@@ -297,15 +296,14 @@
     TIMESTAMP = "timestamp"
 
 
 class ExchangeConstantsOrderColumns(enum.Enum):
     INFO = "info"
     ID = "id"
     EXCHANGE_ID = "exchange_id"
-    EXCHANGE_TRADE_ID = "exchange_trade_id"
     ORDER_ID = "order_id"
     TIMESTAMP = "timestamp"
     DATETIME = 'datetime'
     LAST_TRADE_TIMESTAMP = "lastTradeTimestamp"
     SYMBOL = "symbol"
     MARKET = "market"
     QUANTITY_CURRENCY = "quantity_currency"
@@ -328,16 +326,14 @@
     STOP_PRICE = "stopPrice"
     STOP_LOSS_PRICE = "stopLossPrice"
     TAKE_PROFIT_PRICE = "takeProfitPrice"
     TRIGGER_ABOVE = "triggerAbove"
     TAG = "tag"
     SELF_MANAGED = "self-managed"
     ENTRIES = "entries"
-    VOLUME = "volume"
-    BROKER_APPLIED = "broker_applied"
 
 
 class TradeExtraConstants(enum.Enum):
     CREATION_TIME = "creation_time"
 
 
 class ExchangeConstantsPositionColumns(enum.Enum):
@@ -571,13 +567,7 @@
     EDIT = "edit"
     STATE_CHANGE = "state_transition"
 
 
 class ExchangeSupportedElements(enum.Enum):
     UNSUPPORTED_ORDERS = "unsupported_orders"
     SUPPORTED_BUNDLED_ORDERS = "supported_bundled_orders"
-
-
-class TradingModeActivityType(enum.Enum):
-    CREATED_ORDERS = "created_orders"
-    NOTHING_TO_DO = "nothing_to_do"
-    NO_ACTIVITY = None
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/errors.py` & `OctoBot-Trading-2.4.9/octobot_trading/errors.py`

 * *Files 9% similar despite different names*

```diff
@@ -89,45 +89,20 @@
 
 class FailedRequest(Exception):
     """
     Raised upon a failed request on an exchange API
     """
 
 
-class RateLimitExceeded(Exception):
-    """
-    Raised upon an exchange API rate limit error
-    """
-
-
-class UnavailableOrderTypeForMarketError(Exception):
-    """
-    Raised when an exchange refuses to create a given type of order that should normally be supported
-    """
-
-
 class AuthenticationError(Exception):
     """
     Raised when an exchange failed to authenticate
     """
 
 
-class ExchangeCompliancyError(Exception):
-    """
-    Raised when an exchange failed to execute the given request because of compliance rules for the current user account
-    """
-
-
-class ExchangeAccountSymbolPermissionError(Exception):
-    """
-    Raised when an exchange failed to execute the given request because of allowed traded symbols
-    on the current user account
-    """
-
-
 class PortfolioNegativeValueError(Exception):
     """
     Raised when the portfolio is being updated with a negative value
     """
 
 
 class PortfolioOperationError(Exception):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_channel.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_channel.py`

 * *Files 1% similar despite different names*

```diff
@@ -79,14 +79,15 @@
     SYMBOL_KEY = "symbol"
     DEFAULT_PRIORITY_LEVEL = channel_enums.ChannelConsumerPriorityLevels.HIGH.value
 
     def __init__(self, exchange_manager):
         super().__init__()
         self.logger = logging.get_logger(f"{self.__class__.__name__}[{exchange_manager.exchange_name}]")
         self.exchange_manager = exchange_manager
+        self.exchange = exchange_manager.exchange
 
         self.filter_send_counter = 0
         self.should_send_filter = False
 
     async def new_consumer(self,
                            callback: object = None,
                            consumer_instance: object = None,
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/contract_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/contract_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/future_contract.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/future_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/contracts/margin_contract.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/contracts/margin_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/exchange_symbol_data.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/exchange_symbol_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/exchange_symbols_data.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/exchange_symbols_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/channel/funding_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/funding/funding_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/funding/funding_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline.py`

 * *Files 5% similar despite different names*

```diff
@@ -22,18 +22,17 @@
 
 class KlineProducer(exchanges_channel.ExchangeChannelProducer):
     async def push(self, time_frame, symbol, kline):
         await self.perform(time_frame, symbol, kline)
 
     async def perform(self, time_frame, symbol, kline):
         try:
-            # always update kline db when possible
-            await self.channel.exchange_manager.get_symbol_data(symbol).handle_kline_update(time_frame, kline)
             if self.channel.get_filtered_consumers(symbol=constants.CHANNEL_WILDCARD) or \
                     self.channel.get_filtered_consumers(symbol=symbol, time_frame=time_frame.value):
+                await self.channel.exchange_manager.get_symbol_data(symbol).handle_kline_update(time_frame, kline)
                 await self.send(cryptocurrency=self.channel.exchange_manager.exchange.
                                 get_pair_cryptocurrency(symbol),
                                 symbol=symbol,
                                 time_frame=time_frame.value,
                                 kline=kline)
         except KeyError:
             pass
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/channel/kline_updater_simulator.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,18 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import async_channel.channels as channels
+
 import octobot_commons.errors as errors
+import octobot_commons.channels_name as channels_name
 
 import octobot_trading.exchange_data.kline.channel.kline_updater as kline_updater
 import octobot_trading.util as util
 
 
 class KlineUpdaterSimulator(kline_updater.KlineUpdater):
     def __init__(self, channel, importer):
@@ -49,15 +52,17 @@
             await self.pause()
             await self.stop()
         except IndexError as e:
             self.logger.warning(f"Failed to access kline_data : {e}")
 
     async def pause(self):
         if self.time_consumer is not None:
-            await util.get_time_channel(self).remove_consumer(self.time_consumer)
+            await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value) \
+                .remove_consumer(self.time_consumer)
 
     async def stop(self):
         await util.stop_and_pause(self)
 
     async def resume(self):
         if self.time_consumer is None and not self.channel.is_paused:
-            self.time_consumer = await util.get_time_channel(self).new_consumer(self.handle_timestamp)
+            self.time_consumer = await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.
+                                                         TIME_CHANNEL.value).new_consumer(self.handle_timestamp)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/kline/kline_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/kline/kline_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/candles_adapter.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/candles_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/candles_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/candles_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,19 +16,18 @@
 import numpy as np
 
 import octobot_commons.data_util as data_util
 import octobot_commons.enums as enums
 import octobot_commons.logging as logging
 
 import octobot_trading.util as util
-import octobot_trading.constants as constants
 
 
 class CandlesManager(util.Initializable):
-    MAX_CANDLES_COUNT = constants.MAX_CANDLES_IN_RAM
+    MAX_CANDLES_COUNT = 1000
 
     def __init__(self, max_candles_count=None):
         super().__init__()
         self.logger = logging.get_logger(self.__class__.__name__)
 
         self.candles_initialized = False
         self.max_candles_count = max_candles_count \
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater.py`

 * *Files 2% similar despite different names*

```diff
@@ -131,17 +131,14 @@
         """
         Manage timeframe OHLCV data refreshing for all pairs
         :return: a tuple with (trading pair, time_frame, fetched candles)
         """
         self._set_initialized(pair, time_frame, False)
         # fetch history
         candles = None
-        if self.channel.exchange_manager.exchange_config is None:
-            # exchange stopped
-            return None
         try:
             candles: list = await self._get_init_candles(time_frame, pair)
         except errors.FailedRequest as e:
             self.logger.warning(str(e))
         if candles and len(candles) > 1:
             self._set_initialized(pair, time_frame, True)
             await self.channel.exchange_manager.get_symbol_data(pair) \
@@ -161,28 +158,18 @@
                                 f"the next time frame update")
             return None
 
     def _set_mark_price_from_candle(self, pair, candle):
         # Initialize mark price with last candle close to allow trading low liquidity markets. Those that might
         # take some time to produce a trade and therefore initialize their mark price, which is
         # required to create orders and might block the trading initialization
-        price = decimal.Decimal(str(candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value]))
         self.channel.exchange_manager.get_symbol_data(pair).handle_mark_price_update(
-            price,
+            decimal.Decimal(str(candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value])),
             enums.MarkPriceSources.TICKER_CLOSE_PRICE.value
         )
-        if self.channel.exchange_manager.exchange_personal_data.portfolio_manager is None:
-            if self.channel.exchange_manager.is_trading:
-                self.logger.error(
-                    f"Trading exchange manager without portfolio_manager "
-                    f"on {self.channel.exchange_manager.exchange_name}"
-                )
-        else:
-            self.channel.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
-                value_converter.update_last_price(pair, price)
 
     async def _push_initial_candles(self, initial_candles_data):
         self.logger.debug("Pushing completed initialization candles")
         for initial_candles_tuple in initial_candles_data:
             if initial_candles_tuple is not None:
                 pair, time_frame, candles = initial_candles_tuple
                 await self._push_complete_candles(time_frame, pair, candles)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/channel/ohlcv_updater_simulator.py`

 * *Files 2% similar despite different names*

```diff
@@ -71,19 +71,15 @@
                         # otherwise but are required to complete TA evaluation
                         if time_frame.value in self.last_candles_by_pair_by_time_frame[pair]:
                             await self.push(time_frame,
                                             pair,
                                             [self.last_candles_by_pair_by_time_frame[pair][time_frame.value][-1]],
                                             partial=True)
                             pushed_data = True
-            if (
-                not self.channel.exchange_manager.exchange.is_skipping_empty_candles_in_ohlcv_fetch()
-                and not pushed_data
-            ):
-                self.channel.exchange_manager.exchange.is_unreachable = True
+            self.channel.exchange_manager.exchange.is_unreachable = not pushed_data
 
         except errors.DatabaseNotFoundError as e:
             self.logger.warning(f"Not enough data : {e}")
             await self.pause()
             await self.stop()
         except IndexError as e:
             self.logger.warning(f"Failed to access ohlcv_data : {e}")
@@ -94,30 +90,26 @@
             self.require_last_init_candles_pairs_push = False
 
     async def _handle_ohlcv_data(self, ohlcv_data, time_frame, pair, timestamp):
         has_future_candle = False
         if self.future_candle_time_frame is time_frame:
             if ohlcv_data[-1][-1][enums.PriceIndexes.IND_PRICE_TIME.value] == timestamp:
                 # register future candle
-                self.channel.exchange_manager.exchange.get_current_future_candles()[pair][time_frame.value] = \
+                self.channel.exchange.get_current_future_candles()[pair][time_frame.value] = \
                     ohlcv_data[-1][-1]
                 # do not push future candle
                 has_future_candle = True
             else:
                 # if no future candle available
                 # (end of backtesting of missing data: reset future candle)
-                self.channel.exchange_manager.exchange.get_current_future_candles()[pair][time_frame.value] = None
+                self.channel.exchange.get_current_future_candles()[pair][time_frame.value] = None
 
             # There should always be at least 2 candles in read data, otherwise this means that
             # the exchange was down for some time. Consider it unreachable
-            if (
-                len(ohlcv_data) < 2 and
-                not self.channel.exchange_manager.exchange.is_skipping_empty_candles_in_ohlcv_fetch()
-            ):
-                self.channel.exchange_manager.exchange.is_unreachable = True
+            self.channel.exchange_manager.exchange.is_unreachable = len(ohlcv_data) < 2
         if not has_future_candle or len(ohlcv_data) > 1:
             # push current candle(s)
             candles = ohlcv_data[:-1] if has_future_candle else ohlcv_data
             await self.push(time_frame,
                             pair,
                             [ohlcv[-1] for ohlcv in candles],
                             partial=True)
@@ -133,15 +125,15 @@
     async def resume(self):
         await util.resume_time_consumer(self, self.handle_timestamp)
 
     def _get_traded_pairs(self):
         return api.get_available_symbols(self.exchange_data_importer)
 
     def _get_time_frames(self):
-        return self.channel.exchange_manager.exchange.get_time_frames(self.exchange_data_importer)
+        return self.channel.exchange.get_time_frames(self.exchange_data_importer)
 
     async def _initialize_candles(self, time_frame, pair, should_retry):
         # fetch history
         ohlcv_data = None
         try:
             # only load candles starting from the star time of the backtesting
             ohlcv_data: list = await self.exchange_data_importer.get_ohlcv_from_timestamps(
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ohlcv/preloaded_candles_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/channel/order_book_updater_simulator.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,14 +9,17 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import async_channel.channels as channels
+
+import octobot_commons.channels_name as channels_name
 import octobot_commons.errors as errors
 
 import octobot_trading.exchange_data.order_book.channel.order_book_updater as order_book_updater
 import octobot_trading.util as util
 
 
 class OrderBookUpdaterSimulator(order_book_updater.OrderBookUpdater):
@@ -47,15 +50,17 @@
             await self.pause()
             await self.stop()
         except IndexError as e:
             self.logger.warning(f"Failed to access order_book_data : {e}")
 
     async def pause(self):
         if self.time_consumer is not None:
-            await util.get_time_channel(self).remove_consumer(self.time_consumer)
+            await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).\
+                remove_consumer(self.time_consumer)
 
     async def stop(self):
         await util.stop_and_pause(self)
 
     async def resume(self):
         if self.time_consumer is None and not self.channel.is_paused:
-            self.time_consumer = await util.get_time_channel(self).new_consumer(self.handle_timestamp)
+            self.time_consumer = await channels.get_chan(
+                channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).new_consumer(self.handle_timestamp)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/order_book/order_book_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/order_book/order_book_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/price.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/price.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/prices_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/prices_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/channel/prices_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/price_events_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/price_events_manager.py`

 * *Files 9% similar despite different names*

```diff
@@ -45,20 +45,14 @@
     def reset(self):
         """
         Reset price events
         """
         self.clear_recent_prices()
         self.events.clear()
 
-    def get_min_and_max_prices(self) -> (float, float):
-        if len(self._last_recent_prices) < 2:
-            raise IndexError("Not enough data")
-        prices = sorted([element[self.PRICE_KEY] for element in self._last_recent_prices])
-        return prices[0], prices[-1]
-
     def handle_recent_trades(self, recent_trades):
         """
         Handle new recent trades prices
         :param recent_trades: prices to check
         """
         # reset recent prices on new recent trades
         self.clear_recent_prices()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/prices/prices_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/prices/prices_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -96,18 +96,14 @@
         :return: the mark price if valid
         """
         self._ensure_price_validity()
         if not self.valid_price_received_event.is_set():
             try:
                 self.exchange_manager.ensure_reachability()
                 if self.exchange_manager.is_backtesting:
-                    if self.exchange_manager.exchange.is_skipping_empty_candles_in_ohlcv_fetch():
-                        # missing candles can happen if no traded took place in their time frame. Don't raise and use
-                        # last set price
-                        return self.mark_price
                     # should never happen in backtesting: mark price is either available
                     # or exchange should be unreachable
                     raise asyncio.TimeoutError()
                 await asyncio.wait_for(self.valid_price_received_event.wait(), timeout)
             except asyncio.TimeoutError:
                 self.logger.warning("Timeout when waiting for current market price. This probably means that the "
                                     "required mark price market as a very low liquidity. Market price will be "
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/channel/recent_trade_updater_simulator.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,17 +9,20 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import async_channel.channels as channels
+
 import octobot_backtesting.api as api
 import octobot_backtesting.enums as backtesting_enums
 
+import octobot_commons.channels_name as channels_name
 import octobot_commons.enums as common_enums
 import octobot_commons.errors as errors
 
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.exchange_data.recent_trades.channel.recent_trade_updater as recent_trade_updater
@@ -64,15 +67,15 @@
         if time_frame == self.recent_trades_time_frame:
             try:
                 # Candles are pushed when completed therefore the current price is the candle's close price
                 # However we can't only rely on close price to generate minimal recent trades.
                 # Recent trades for this candle are between the next candle candle high price and the next candle
                 # low price in order to get these prices, use exchange simulator's future candles filled by the
                 # previous ohlcv updater cycle that also triggered this call
-                future_candle = self.channel.exchange_manager.exchange.get_current_future_candles()[symbol][time_frame]
+                future_candle = self.channel.exchange.get_current_future_candles()[symbol][time_frame]
                 last_candle_timestamp = future_candle[common_enums.PriceIndexes.IND_PRICE_TIME.value]
                 if last_candle_timestamp > self.last_timestamp_pushed_by_symbol[symbol]:
                     future_candle_low_price = future_candle[common_enums.PriceIndexes.IND_PRICE_LOW.value]
                     future_candle_high_price = future_candle[common_enums.PriceIndexes.IND_PRICE_HIGH.value]
                     recent_trades = [self._generate_recent_trade(last_candle_timestamp, future_candle_low_price),
                                      self._generate_recent_trade(last_candle_timestamp, future_candle_high_price)]
                     self.last_timestamp_pushed_by_symbol[symbol] = last_candle_timestamp
@@ -93,26 +96,28 @@
         return {
             enums.ExchangeConstantsOrderColumns.TIMESTAMP.value: timestamp,
             enums.ExchangeConstantsOrderColumns.PRICE.value: price
         }
 
     async def pause(self):
         if self.time_consumer is not None:
-            await util.get_time_channel(self).remove_consumer(self.time_consumer)
+            await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value). \
+                remove_consumer(self.time_consumer)
         self.is_running = False
 
     async def stop(self):
         await util.stop_and_pause(self)
 
     async def resume(self):
         if not self.is_running:
             if self.time_consumer is None and not self.channel.is_paused:
                 if backtesting_enums.ExchangeDataTables.RECENT_TRADES in \
                         api.get_available_data_types(self.exchange_data_importer):
-                    self.time_consumer = await util.get_time_channel(self).new_consumer(
+                    self.time_consumer = await channels.get_chan(
+                        channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).new_consumer(
                         self.handle_timestamp)
                 else:
                     await exchanges_channel.get_chan(constants.OHLCV_CHANNEL, self.channel.exchange_manager.id) \
                         .new_consumer(self._recent_trades_from_ohlcv_callback)
                     self.last_timestamp_pushed_by_symbol = {
                         symbol: 0
                         for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/recent_trades/recent_trades_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/channel/ticker_updater_simulator.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,19 +9,23 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+
+import async_channel.channels as channels
+
 import octobot_backtesting.api as api
 import octobot_backtesting.enums as backtesting_enums
 
 import octobot_commons.enums as common_enums
 import octobot_commons.constants as common_constants
+import octobot_commons.channels_name as channels_name
 import octobot_commons.errors as errors
 
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.util as util
 import octobot_trading.exchange_data.ticker.channel.ticker_updater as ticker_updater
@@ -85,26 +89,28 @@
             enums.ExchangeConstantsTickersColumns.CLOSE.value: candle[common_enums.PriceIndexes.IND_PRICE_CLOSE.value],
             enums.ExchangeConstantsTickersColumns.BASE_VOLUME.value:
                 candle[common_enums.PriceIndexes.IND_PRICE_VOL.value]
         }
 
     async def pause(self):
         if self.time_consumer is not None:
-            await util.get_time_channel(self).remove_consumer(self.time_consumer)
+            await channels.get_chan(channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value). \
+                remove_consumer(self.time_consumer)
         self.is_running = False
 
     async def stop(self):
         await util.stop_and_pause(self)
 
     async def resume(self):
         if not self.is_running:
             if self.time_consumer is None and not self.channel.is_paused:
                 if backtesting_enums.ExchangeDataTables.TICKER in \
                         api.get_available_data_types(self.exchange_data_importer):
-                    self.time_consumer = await util.get_time_channel(self).new_consumer(
+                    self.time_consumer = await channels.get_chan(
+                        channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).new_consumer(
                         self.handle_timestamp)
                 else:
                     await exchanges_channel.get_chan(constants.OHLCV_CHANNEL, self.channel.exchange_manager.id) \
                         .new_consumer(self._ticker_from_ohlcv_callback)
                     self.last_timestamp_pushed_by_symbol = {
                         symbol: 0
                         for symbol in self.channel.exchange_manager.exchange_config.traded_symbol_pairs
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchange_data/ticker/ticker_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchange_data/ticker/ticker_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -52,36 +52,31 @@
     initialize_real_exchange,
     create_simulated_exchange,
     init_simulated_exchange,
 )
 from octobot_trading.exchanges.util import (
     ExchangeMarketStatusFixer,
     is_ms_valid,
-    SymbolDetails,
     get_rest_exchange_class,
     get_order_side,
     log_time_sync_error,
     get_partners_explanation_message,
     get_enabled_exchanges,
-    exchange_error_translator,
     is_compatible_account,
     get_historical_ohlcv,
     get_exchange_type,
     get_default_exchange_type,
     get_supported_exchange_types,
     update_raw_order_from_raw_trade,
     is_missing_trading_fees,
     apply_trades_fees,
-    get_common_traded_quote,
-    get_associated_symbol,
     get_exchange_class_from_name,
     get_local_exchange_manager,
     get_auto_filled_exchange_names,
     get_exchange_details,
-    is_error_on_this_type,
     force_disable_web_socket,
     check_web_socket_config,
     search_websocket_class,
     supports_websocket,
 )
 from octobot_trading.exchanges import exchange_websocket_factory
 from octobot_trading.exchanges.exchange_websocket_factory import (
@@ -144,30 +139,26 @@
     "ExchangeConfiguration",
     "Exchanges",
     "get_rest_exchange_class",
     "get_order_side",
     "log_time_sync_error",
     "get_partners_explanation_message",
     "get_enabled_exchanges",
-    "exchange_error_translator",
     "is_compatible_account",
     "get_historical_ohlcv",
     "get_exchange_type",
     "get_default_exchange_type",
     "get_supported_exchange_types",
     "update_raw_order_from_raw_trade",
     "is_missing_trading_fees",
     "apply_trades_fees",
-    "get_common_traded_quote",
-    "get_associated_symbol",
     "get_exchange_class_from_name",
     "get_local_exchange_manager",
     "get_auto_filled_exchange_names",
     "get_exchange_details",
-    "is_error_on_this_type",
     "AbstractExchange",
     "is_channel_managed_by_websocket",
     "is_channel_fully_managed_by_websocket",
     "is_websocket_feed_requiring_init",
     "search_and_create_websocket",
     "requires_refresh_trigger",
     "create_exchange_channels",
@@ -179,15 +170,14 @@
     "DefaultRestExchange",
     "ExchangeSimulator",
     "CCXTWebsocketConnector",
     "WebSocketExchange",
     "RestExchange",
     "ExchangeMarketStatusFixer",
     "is_ms_valid",
-    "SymbolDetails",
     "AbstractWebsocketExchange",
     "force_disable_web_socket",
     "check_web_socket_config",
     "search_websocket_class",
     "supports_websocket",
     "CCXTConnector",
     "CCXTAdapter",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/abstract_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/abstract_exchange.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
 import typing
 import decimal
 import time
-import contextlib
 
 import octobot_commons.constants
 import octobot_commons.enums as common_enums
 import octobot_commons.logging as logging
 import octobot_commons.timestamp_util as timestamp_util
 import octobot_commons.tentacles_management as tentacles_management
 
@@ -91,16 +90,14 @@
 
         # exchange related constants
         self.allowed_time_lag = octobot_trading.constants.DEFAULT_EXCHANGE_TIME_LAG
         self.current_account = enums.AccountTypes.CASH
 
         self.is_unreachable = False
 
-        self._creating_exchange_order_ids = set()
-
         if self.exchange_manager.tentacles_setup_config is not None:
             self.load_user_inputs_from_class(self.exchange_manager.tentacles_setup_config, self.tentacle_config)
 
     async def initialize(self, force=False, **kwargs):
         if not self.is_initialized or force:
             await self.initialize_impl(**kwargs)
             self.is_initialized = True
@@ -379,30 +376,24 @@
         :param stop_loss_price: the bundled order stop_loss price
         :param take_profit_price: the bundled order take_profit price
         :return: A dict with the necessary parameters to create the bundled order on exchange alongside the
         base order in one request
         """
         raise NotImplementedError("get_bundled_order_parameters is not implemented")
 
-    def is_supported_order_type(self, order_type: enums.TraderOrderType) -> bool:
+    def is_supported_order_type(self, order_type):
         """
         Check if the order type is supported by the current exchange instance
         Should be used to know if we should simulate this order or create it on the exchange
         :param order_type: the order type, should be a member of enums.TraderOrderType
         :return: True if the order type is supported by the exchange, else False
         """
         return order_type not in self.get_supported_elements(enums.ExchangeSupportedElements.UNSUPPORTED_ORDERS)
 
-    def is_market_open_for_order_type(self, symbol: str, order_type: enums.TraderOrderType) -> bool:
-        """
-        Override if necessary
-        """
-        return True
-
-    def get_trade_fee(self, symbol: str, order_type: enums.TraderOrderType, quantity, price, taker_or_maker):
+    def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         """
         Calculates fees resulting to a trade
         :param symbol: the symbol
         :param order_type: the order type
         :param quantity: the trade quantity
         :param price: the trade price
         :param taker_or_maker: if the trade was taker or maker
@@ -476,38 +467,28 @@
     async def retry_n_time(self, n_times, request_func, *args, **kwargs):
         return await self._retry_until(0, n_times, request_func, *args, **kwargs)
 
     async def _retry_until(self, timeout, n_times, request_func, *args, **kwargs):
         t0 = time.time()
         minimal_interval = 0.1
         attempt = 1
-        latest_error = None
-        latest_request_url = None
         while (timeout != 0 and time.time() - t0 < timeout) or (n_times != 0 and attempt <= n_times + 1):
             last_request_time = time.time()
             try:
                 result = await request_func(*args, **kwargs)
                 if attempt > 1:
                     self.logger.debug(f"Request retrier success for {request_func.__name__} after {attempt} attempts")
                 return result
-            except errors.FailedRequest as err:
-                latest_error = err
-                latest_request_url = self.get_latest_request_url()
-                self.logger.debug(
-                    f"Request retrier failed for {request_func.__name__}({args} {kwargs}) (attempt {attempt}) ({err})"
-                )
+            except errors.FailedRequest:
+                self.logger.debug(f"Request retrier failed for {request_func.__name__} (attempt {attempt})")
                 if time.time() - last_request_time < minimal_interval:
                     await asyncio.sleep(minimal_interval)
                 attempt += 1
-        latest_error = latest_error or RuntimeError("unknown error, this is unexpected, latest_error should be set")
-        raise errors.FailedRequest(
-            f"Failed to successfully run {request_func.__name__}(args={args}, kwargs={kwargs}) request after {attempt} "
-            f"attempts. Latest error: {latest_error} ({latest_error.__class__.__name__}). "
-            f"Last request url: {latest_request_url}"
-        ) from latest_error
+        raise errors.FailedRequest(f"Failed to successfully run {request_func.__name__} request after {attempt} "
+                                   f"attempts.")
 
     """
     Parsers
     """
 
     def parse_balance(self, balance):
         """
@@ -600,20 +581,14 @@
     def parse_account(self, account):
         """
         :param account: the raw account
         :return: the AccountTypes related to the account
         """
         raise NotImplementedError("parse_account is not implemented")
 
-    def get_latest_request_url(self) -> str:
-        """
-        :return: the URL of the last request
-        """
-        return self.connector.get_latest_request_url()
-
     """
     Uniformization
     """
 
     def need_to_uniformize_timestamp(self, timestamp):
         """
         Return True if the timestamp should be uniformized
@@ -703,23 +678,7 @@
         order_desc = f"order_type: {order_type}, symbol: {symbol}, quantity: {str(quantity)}, price: {str(price)}," \
                      f" stop_price: {str(stop_price)}"
         self.logger.error(f"Failed to create order : {error.__class__.__name__} {error}: ({order_desc})")
 
     def handle_token_error(self, error):
         self.logger.error(f"Exchange configuration is invalid : please check your configuration ! "
                           f"({error.__class__.__name__}: {error})")
-
-    @contextlib.contextmanager
-    def creating_order(self, creating_order: dict):
-        exchange_order_id = creating_order.get(
-            enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value
-        ) if creating_order else None
-        try:
-            self._creating_exchange_order_ids.add(exchange_order_id)
-            yield
-        finally:
-            self._creating_exchange_order_ids.remove(exchange_order_id)
-
-    def is_creating_order(self, exchange_order_id):
-        if exchange_order_id is None:
-            return False
-        return exchange_order_id in self._creating_exchange_order_ids
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/abstract_websocket_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/abstract_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/adapters/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/adapters/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/adapters/abstract_adapter.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/adapters/abstract_adapter.py`

 * *Files 4% similar despite different names*

```diff
@@ -66,19 +66,14 @@
 
     @_adapter
     def adapt_ticker(self, raw, **kwargs):
         fixed = self.fix_ticker(raw, **kwargs)
         return self.parse_ticker(fixed, **kwargs)
 
     @_adapter
-    def adapt_ticker_from_kline(self, raw, symbol, **kwargs):
-        fixed = self.create_ticker_from_kline(raw, symbol, **kwargs)
-        return self.parse_ticker(fixed, **kwargs)
-
-    @_adapter
     def adapt_balance(self, raw, **kwargs):
         fixed = self.fix_balance(raw, **kwargs)
         return self.parse_balance(fixed, **kwargs)
 
     @_adapter
     def adapt_order_book(self, raw, **kwargs):
         fixed = self.fix_order_book(raw, **kwargs)
@@ -121,17 +116,17 @@
 
     @_adapter
     def adapt_mark_price(self, raw, **kwargs):
         fixed = self.fix_mark_price(raw, **kwargs)
         return self.parse_mark_price(fixed, **kwargs)
 
     @_adapter
-    def adapt_market_status(self, raw, remove_price_limits=False, **kwargs):
-        fixed = self.fix_market_status(raw, remove_price_limits=remove_price_limits, **kwargs)
-        return self.parse_market_status(fixed, remove_price_limits=remove_price_limits, **kwargs)
+    def adapt_market_status(self, raw, **kwargs):
+        fixed = self.fix_market_status(raw, **kwargs)
+        return self.parse_market_status(fixed, **kwargs)
 
     def get_uniformized_timestamp(self, timestamp):
         # override if the exchange time is not a second timestamp or millisecond
         if timestamp is not None and timestamp > 16728292300:  # Friday 5 February 2500 11:51:40
             return timestamp / commons_constants.MSECONDS_TO_SECONDS
         return timestamp
 
@@ -167,17 +162,14 @@
     def fix_ticker(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_ticker(self, fixed, **kwargs):
         raise NotImplementedError("parse_ticker is not implemented")
 
-    def create_ticker_from_kline(self, kline, symbol, **kwargs):
-        raise NotImplementedError("create_ticker_from_kline is not implemented")
-
     def fix_balance(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_balance(self, fixed, **kwargs):
         raise NotImplementedError("parse_balance is not implemented")
 
@@ -193,16 +185,16 @@
         return raw
 
     def parse_public_recent_trades(self, fixed, **kwargs):
         raise NotImplementedError("parse_public_recent_trades is not implemented")
 
     def fix_trades(self, raw, **kwargs):
         for trade in raw:
-            # id is reserved for octobot managed id. store exchange trade id in EXCHANGE_TRADE_ID
-            trade[enums.ExchangeConstantsOrderColumns.EXCHANGE_TRADE_ID.value] = \
+            # id is reserved for octobot managed id. store exchange id in EXCHANGE_ID
+            trade[enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value] = \
                 trade.pop(enums.ExchangeConstantsOrderColumns.ID.value, None)
             # add generic logic if necessary
         return raw
 
     def parse_trades(self, fixed, **kwargs):
         raise NotImplementedError("parse_trades is not implemented")
 
@@ -244,13 +236,13 @@
     def fix_mark_price(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
     def parse_mark_price(self, fixed, **kwargs):
         raise NotImplementedError("parse_mark_price is not implemented")
 
-    def fix_market_status(self, raw, remove_price_limits=False, **kwargs):
+    def fix_market_status(self, raw, **kwargs):
         # add generic logic if necessary
         return raw
 
-    def parse_market_status(self, fixed, remove_price_limits=False, **kwargs):
+    def parse_market_status(self, fixed, **kwargs):
         raise NotImplementedError("parse_market_status is not implemented")
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/backtesting_exchange_config.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/backtesting_exchange_config.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/config/exchange_config_data.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/config/exchange_config_data.py`

 * *Files 0% similar despite different names*

```diff
@@ -165,19 +165,18 @@
         self.traded_cryptocurrencies = {}
         traded_symbol_pairs_set = set()
         existing_pairs = set()
         for cryptocurrency in self.config[constants.CONFIG_CRYPTO_CURRENCIES]:
             traded_symbol_pairs_set = self._set_config_traded_pair(cryptocurrency,
                                                                    traded_symbol_pairs_set,
                                                                    existing_pairs)
-        # sort lists to avoid set insert randomness issues
-        self.traded_symbol_pairs = sorted(list(traded_symbol_pairs_set))
+        self.traded_symbol_pairs = list(traded_symbol_pairs_set)
         self.traded_symbols = [
             octobot_commons.symbols.parse_symbol(symbol)
-            for symbol in self.traded_symbol_pairs
+            for symbol in traded_symbol_pairs_set
         ]
 
         # only add self.traded_symbol_pairs to watched pairs as not every existing_pairs are being collected
         self.watched_pairs = copy.deepcopy(self.traded_symbol_pairs)
 
     def _set_config_traded_pair(self, cryptocurrency, traded_symbol_pairs_set, existing_pairs):
         try:
@@ -266,18 +265,15 @@
         existing_pairs.update(wildcard_pairs_list)
 
     def _set_config_time_frame(self):
         display_time_frames = []
         for time_frame in time_frame_manager.get_config_time_frame(self.config):
             if self.exchange_manager.time_frame_exists(time_frame.value):
                 self.available_required_time_frames.append(time_frame)
-        if (
-            not self.exchange_manager.is_backtesting or
-            (self.exchange_manager.is_backtesting and self.exchange_manager.exchange.use_accurate_price_time_frame())
-        ) or not self.available_required_time_frames:
+        if not self.exchange_manager.is_backtesting or not self.available_required_time_frames:
             # add shortest time frame for realtime evaluators
             client_shortest_time_frame = time_frame_manager.find_min_time_frame(
                 self.exchange_manager.client_time_frames,
                 constants.MIN_EVAL_TIME_FRAME)
             self.real_time_time_frames.append(client_shortest_time_frame)
         if self.exchange_manager.time_frame_exists(trading_constants.DISPLAY_TIME_FRAME.value):
             # add display time frame if not available already
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_adapter.py`

 * *Files 13% similar despite different names*

```diff
@@ -20,69 +20,40 @@
 import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
 import octobot_trading.personal_data as personal_data
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 from octobot_trading.enums import ExchangeConstantsOrderColumns as ecoc
 import octobot_commons.enums as common_enums
 import octobot_commons.constants as common_constants
-import octobot_commons.number_util as number_util
 
 
 class CCXTAdapter(adapters.AbstractAdapter):
-    def fix_order(self, raw, symbol=None, **kwargs):
+    def fix_order(self, raw, **kwargs):
         fixed = super().fix_order(raw, **kwargs)
         try:
             exchange_timestamp = fixed[ecoc.TIMESTAMP.value]
-            fixed[ecoc.TIMESTAMP.value] = self.get_uniformized_timestamp(exchange_timestamp)
-            self.adapt_quantities_with_contract_size(fixed, symbol)
+            fixed[ecoc.TIMESTAMP.value] = \
+                self.get_uniformized_timestamp(exchange_timestamp)
         except KeyError as e:
             self.logger.error(f"Fail to cleanup order dict ({e})")
         self._register_exchange_fees(fixed)
         return fixed
 
     def parse_order(self, fixed, **kwargs):
         # CCXT standard order parsing logic
         return fixed
 
-    def adapt_quantities_with_contract_size(self, order_or_trade, symbol):
-        if self.connector.exchange_manager.is_future:
-            symbol = symbol or order_or_trade.get(ecoc.SYMBOL.value)
-            if symbol is None:
-                # can't get contract size
-                return
-            # amount is in contacts, multiply by contract value to get the currency amount (displayed to the user)
-            contract_size = self.connector.get_contract_size(symbol)
-            if contract_size == constants.ONE:
-                # nothing to do
-                return
-            if amount := order_or_trade.get(enums.ExchangeConstantsOrderColumns.AMOUNT.value):
-                order_or_trade[enums.ExchangeConstantsOrderColumns.AMOUNT.value] = amount * float(contract_size)
-            if filled := order_or_trade.get(enums.ExchangeConstantsOrderColumns.FILLED.value):
-                order_or_trade[enums.ExchangeConstantsOrderColumns.FILLED.value] = filled * float(contract_size)
-
     def _register_exchange_fees(self, order_or_trade):
         try:
             fees = order_or_trade[enums.ExchangeConstantsOrderColumns.FEE.value]
             fees[enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value] = fees[enums.FeePropertyColumns.COST.value]
             fees[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] = True
         except (KeyError, TypeError):
             pass
 
-    def _ensure_fees(self, order_or_trade):
-        # call if necessary
-        if order_or_trade.get(enums.ExchangeConstantsOrderColumns.FEE.value) is None:
-            order_or_trade[enums.ExchangeConstantsOrderColumns.FEE.value] = {
-                enums.FeePropertyColumns.COST.value: constants.ZERO,
-                enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value: constants.ZERO,
-                enums.FeePropertyColumns.CURRENCY.value: None,
-                enums.FeePropertyColumns.RATE.value: None,
-                enums.FeePropertyColumns.TYPE.value: ccxt_enums.ExchangeOrderCCXTColumns.TAKER_OR_MAKER.value,
-                enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: True,
-            }
-
     def _fix_ohlcv_prices(self, ohlcv):
         for index, value in enumerate(ohlcv[common_enums.PriceIndexes.IND_PRICE_TIME.value + 1:]):
             ohlcv[index + 1] = float(value)
 
     def fix_ohlcv(self, raw, **kwargs):
         fixed = super().fix_ohlcv(raw, **kwargs)
         # ensure open time is not the current time but the actual candle open time
@@ -128,40 +99,20 @@
     def parse_kline(self, fixed, **kwargs):
         # CCXT standard kline parsing logic
         return fixed
 
     def fix_ticker(self, raw, **kwargs):
         fixed = super().fix_ticker(raw, **kwargs)
         # CCXT standard ticker fixing logic
-        if timestamp := fixed.get(enums.ExchangeConstantsTickersColumns.TIMESTAMP.value):
-            fixed[enums.ExchangeConstantsTickersColumns.TIMESTAMP.value] = \
-                int(self.get_uniformized_timestamp(timestamp))
         return fixed
 
     def parse_ticker(self, fixed, **kwargs):
         # CCXT standard ticker parsing logic
         return fixed
 
-    def create_ticker_from_kline(self, kline, symbol, **kwargs):
-        return {
-            enums.ExchangeConstantsTickersColumns.SYMBOL.value: symbol,
-            enums.ExchangeConstantsTickersColumns.TIMESTAMP.value: kline[common_enums.PriceIndexes.IND_PRICE_TIME.value],
-            enums.ExchangeConstantsTickersColumns.OPEN.value: kline[common_enums.PriceIndexes.IND_PRICE_OPEN.value],
-            enums.ExchangeConstantsTickersColumns.HIGH.value: kline[common_enums.PriceIndexes.IND_PRICE_HIGH.value],
-            enums.ExchangeConstantsTickersColumns.LOW.value: kline[common_enums.PriceIndexes.IND_PRICE_LOW.value],
-            enums.ExchangeConstantsTickersColumns.CLOSE.value: kline[common_enums.PriceIndexes.IND_PRICE_CLOSE.value],
-            enums.ExchangeConstantsTickersColumns.BASE_VOLUME.value: kline[common_enums.PriceIndexes.IND_PRICE_VOL.value],
-            enums.ExchangeConstantsTickersColumns.LAST.value: kline[common_enums.PriceIndexes.IND_PRICE_CLOSE.value],
-            enums.ExchangeConstantsTickersColumns.BID.value: None,
-            enums.ExchangeConstantsTickersColumns.BID_VOLUME.value: None,
-            enums.ExchangeConstantsTickersColumns.ASK.value: None,
-            enums.ExchangeConstantsTickersColumns.ASK_VOLUME.value: None,
-            enums.ExchangeConstantsTickersColumns.PREVIOUS_CLOSE.value: None,
-        }
-
     def fix_balance(self, raw, **kwargs):
         fixed = super().fix_balance(raw, **kwargs)
         # remove not currency specific keys
         return fixed
 
     def parse_balance(self, fixed, **kwargs):
         fixed.pop(constants.CONFIG_PORTFOLIO_FREE, None)
@@ -208,21 +159,19 @@
     def fix_trades(self, raw, **kwargs):
         fixed = super().fix_trades(raw, **kwargs)
         # CCXT standard trades fixing logic
         for trade in fixed:
             try:
                 trade[ecoc.TIMESTAMP.value] = \
                     self.get_uniformized_timestamp(trade[ecoc.TIMESTAMP.value])
-                trade[ecoc.EXCHANGE_ID.value] = trade.get(ecoc.ORDER.value)
                 if trade[enums.ExchangeConstantsOrderColumns.TYPE.value] is None:
                     trade[enums.ExchangeConstantsOrderColumns.TYPE.value] = enums.TradeOrderType.MARKET.value \
                         if trade[ccxt_enums.ExchangeOrderCCXTColumns.TAKER_OR_MAKER.value] \
                         == enums.ExchangeConstantsMarketPropertyColumns.TAKER.value \
                         else enums.TradeOrderType.LIMIT.value
-                self.adapt_quantities_with_contract_size(trade, None)
             except KeyError as e:
                 self.logger.error(f"Fail to clean trade dict ({e})")
             self._register_exchange_fees(trade)
         return fixed
 
     def parse_trades(self, fixed, **kwargs):
         # CCXT standard trades parsing logic
@@ -272,31 +221,31 @@
                                       constants.DEFAULT_SYMBOL_LEVERAGE),
                 enums.ExchangeConstantsPositionColumns.POSITION_MODE.value: None if is_empty else
                 enums.PositionMode.HEDGE if fixed.get(ccxt_enums.ExchangePositionCCXTColumns.HEDGED.value, True)
                 else enums.PositionMode.ONE_WAY,
                 # next values are always 0 when the position empty (0 contracts)
                 enums.ExchangeConstantsPositionColumns.COLLATERAL.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.COLLATERAL.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.COLLATERAL.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.NOTIONAL.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.NOTIONAL.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.NOTIONAL.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.INITIAL_MARGIN.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.INITIAL_MARGIN.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.INITIAL_MARGIN.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.UNREALIZED_PNL.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.UNREALISED_PNL.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.UNREALISED_PNL.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.REALISED_PNL.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.REALISED_PNL.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.REALISED_PNL.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.LIQUIDATION_PRICE.value: liquidation_price,
                 enums.ExchangeConstantsPositionColumns.MARK_PRICE.value: constants.ZERO if is_empty else
                 decimal.Decimal(
-                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.MARK_PRICE.value, 0) or 0}"),
+                    f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.MARK_PRICE.value, 0)}"),
                 enums.ExchangeConstantsPositionColumns.ENTRY_PRICE.value: constants.ZERO if is_empty else
                 decimal.Decimal(
                     f"{fixed.get(ccxt_enums.ExchangePositionCCXTColumns.ENTRY_PRICE.value, 0)}"),
             })
         except KeyError as e:
             self.logger.error(f"Fail to parse position dict ({e})")
         return fixed
@@ -307,28 +256,28 @@
         return fixed
 
     def parse_funding_rate(self, fixed, from_ticker=False, **kwargs):
         # CCXT standard funding_rate parsing logic
         fixed.update({
             enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value:
                 self.safe_decimal(
-                    fixed, ccxt_enums.ExchangeFundingCCXTColumns.FUNDING_RATE.value, constants.NaN
+                    fixed, ccxt_enums.ExchangeFundingCCXTColumns.PREVIOUS_FUNDING_RATE.value, constants.NaN
                 ),
             enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value:
                 self.get_uniformized_timestamp(
                     fixed.get(ccxt_enums.ExchangeFundingCCXTColumns.PREVIOUS_FUNDING_TIMESTAMP.value, 0)
-                    or 0
+                    or constants.ZERO
                 ),
             enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value:
                 self.safe_decimal(
                     fixed, ccxt_enums.ExchangeFundingCCXTColumns.FUNDING_RATE.value, constants.NaN
                 ),
             enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value:
                 self.get_uniformized_timestamp(
-                    fixed.get(ccxt_enums.ExchangeFundingCCXTColumns.FUNDING_TIMESTAMP.value, 0) or 0
+                    fixed.get(ccxt_enums.ExchangeFundingCCXTColumns.FUNDING_TIMESTAMP.value, 0) or constants.ZERO
                 ),
         })
         return fixed
 
     def fix_leverage(self, raw, **kwargs):
         fixed = super().fix_leverage(raw, **kwargs)
         # CCXT standard leverage fixing logic
@@ -397,33 +346,15 @@
         # CCXT standard mark_price fixing logic
         return fixed
 
     def parse_mark_price(self, fixed, **kwargs):
         # CCXT standard mark_price parsing logic
         return fixed
 
-    def fix_market_status(self, raw, remove_price_limits=False, **kwargs):
-        fixed = super().fix_market_status(raw, remove_price_limits=remove_price_limits, **kwargs)
+    def fix_market_status(self, raw, **kwargs):
+        fixed = super().fix_market_status(raw, **kwargs)
         # CCXT standard market_status fixing logic
-        fixed[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
-            enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value] = number_util.get_digits_count(
-            fixed[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
-                enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value]
-        )
-        fixed[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
-            enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value] = number_util.get_digits_count(
-            fixed[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
-                enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value]
-        )
-        if remove_price_limits:
-            fixed[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value][
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MIN.value] = None
-            fixed[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value][
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MAX.value] = None
-
         return fixed
 
-    def parse_market_status(self, fixed, remove_price_limits=False, **kwargs):
+    def parse_market_status(self, fixed, **kwargs):
         # CCXT standard market_status parsing logic
         return fixed
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_client_util.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,53 +9,44 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import copy
 import logging
-import typing
 import ccxt
 import ccxt.pro as ccxt_pro
 
 import octobot_commons.time_frame_manager as time_frame_manager
 import octobot_trading.constants as constants
-import octobot_trading.enums as enums
-import octobot_trading.errors as errors
 import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
-import octobot_trading.exchanges.connectors.ccxt.ccxt_clients_cache as ccxt_clients_cache
 import octobot_trading.exchanges.util.exchange_util as exchange_util
 
 
-def create_client(
-    exchange_class, exchange_manager, logger, options, headers,
-    additional_config, should_authenticate, unauthenticated_exchange_fallback=None,
-    keys_adapter=None
-):
+def create_client(exchange_class, exchange_manager, logger,
+                  options, headers, additional_config, 
+                  should_authenticate, unauthenticated_exchange_fallback=None):
     """
     Exchange instance creation
     :return: the created ccxt (pro, async or sync) client
     """
     is_authenticated = False
     if not exchange_manager.exchange_only:
         # avoid logging version on temporary exchange_only exchanges
         exchange_type = exchange_util.get_exchange_type(exchange_manager)
         logger.info(f"Creating {exchange_class.__name__} {exchange_type.name} "
                     f"exchange with ccxt in version {ccxt.__version__}")
     if exchange_manager.ignore_config or exchange_manager.check_config(exchange_manager.exchange_name):
         try:
             key, secret, password = exchange_manager.get_exchange_credentials(exchange_manager.exchange_name)
-            if keys_adapter:
-                key, secret, password = keys_adapter(key, secret, password)
             if not (key and secret) and not exchange_manager.is_simulated and not exchange_manager.ignore_config:
                 logger.warning(f"No exchange API key set for {exchange_manager.exchange_name}. "
                                f"Enter your account details to enable real trading on this exchange.")
-            if should_authenticate and not exchange_manager.is_backtesting:
+            if should_authenticate:
                 client = exchange_class(_get_client_config(options, headers, additional_config,
                                                            key, secret, password))
                 is_authenticated = True
                 if exchange_manager.check_credentials:
                     client.checkRequiredCredentials()
             else:
                 client = exchange_class(_get_client_config(options, headers, additional_config))
@@ -109,50 +100,27 @@
         additional_info = f" in type {default_type}" if default_type else ""
         exchange_connector.logger.warning(f"{exchange_connector.name} does not support sandboxing {additional_info}: {e}")
         # raise exception to stop this exchange and prevent dealing with a real funds exchange
         raise e
     return None
 
 
-def load_markets_from_cache(client, market_filter: typing.Union[None, typing.Callable[[dict], bool]] = None):
-    client.set_markets(
-        market
-        for market in ccxt_clients_cache.get_exchange_parsed_markets(ccxt_clients_cache.get_client_key(client))
-        if market_filter is None or market_filter(market)
-    )
-
-
-def set_markets_cache(client):
-    if client.markets:
-        ccxt_clients_cache.set_exchange_parsed_markets(
-            ccxt_clients_cache.get_client_key(client), copy.deepcopy(list(client.markets.values()))
-        )
-
-
 def get_ccxt_client_login_options(exchange_manager):
     """
     :return: ccxt client login option dict, can be overwritten to custom exchange login
     """
     if exchange_manager.is_future:
         return {'defaultType': 'future'}
     if exchange_manager.is_margin:
         return {'defaultType': 'margin'}
     return {'defaultType': 'spot'}
 
 
-def get_symbols(client, active_only):
+def get_symbols(client):
     try:
-        if active_only:
-            return set(
-                symbol
-                for symbol in client.symbols
-                if client.markets.get(symbol, {}).get(
-                    enums.ExchangeConstantsMarketStatusColumns.ACTIVE.value, True
-                )
-            )
         return set(client.symbols)
     except (AttributeError, TypeError):
         # ccxt exchange load_markets failed
         return set()
 
 
 def get_time_frames(client):
@@ -193,28 +161,14 @@
     raise ValueError(f'{pair} is not supported')
 
 
 def get_contract_size(client, pair) -> float:
     return client.markets[pair][ccxt_enums.ExchangeConstantsMarketStatusCCXTColumns.CONTRACT_SIZE.value]
 
 
-def get_fees(market_status) -> dict:
-    return {
-        enums.ExchangeConstantsMarketPropertyColumns.TAKER.value:
-            market_status.get(enums.ExchangeConstantsMarketPropertyColumns.TAKER.value,
-                              constants.CONFIG_DEFAULT_FEES),
-        enums.ExchangeConstantsMarketPropertyColumns.MAKER.value:
-            market_status.get(enums.ExchangeConstantsMarketPropertyColumns.MAKER.value,
-                              constants.CONFIG_DEFAULT_FEES),
-        enums.ExchangeConstantsMarketPropertyColumns.FEE.value:
-            market_status.get(enums.ExchangeConstantsMarketPropertyColumns.FEE.value,
-                              constants.CONFIG_DEFAULT_FEES)
-    }
-
-
 def add_headers(client, headers_dict):
     """
     Add new headers to ccxt client
     :param headers_dict: the additional header keys and values as dict
     """
     for header_key, header_value in headers_dict.items():
         client.headers[header_key] = header_value
@@ -225,25 +179,14 @@
     Add new options to ccxt client
     :param options_dict: the additional option keys and values as dict
     """
     for option_key, option_value in options_dict.items():
         client.options[option_key] = option_value
 
 
-def converted_ccxt_common_errors(f):
-    async def wrapper(*args, **kwargs):
-        try:
-            return await f(*args, **kwargs)
-        except ccxt.RateLimitExceeded as err:
-            raise errors.RateLimitExceeded(err) from err
-        except ccxt.NotSupported as err:
-            raise errors.NotSupported(err) from err
-    return wrapper
-
-
 def _use_http_proxy_if_necessary(client):
     client.aiohttp_trust_env = constants.ENABLE_EXCHANGE_HTTP_PROXY_FROM_ENV
 
 
 def _get_client_config(options, headers, additional_config, api_key=None, secret=None, password=None):
     config = {
         'verbose': constants.ENABLE_CCXT_VERBOSE,
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_clients_cache.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,25 +9,18 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import cachetools
 
-import octobot_commons.constants as commons_constants
 
+def is_emitting_trading_signals(ctx):
+    return ctx.is_trading_signal_emitter()
 
-_MARKETS_BY_EXCHANGE = cachetools.TTLCache(maxsize=50, ttl=commons_constants.DAYS_TO_SECONDS*7)
 
-
-def get_client_key(client) -> str:
-    return client.__class__.__name__
-
-
-def get_exchange_parsed_markets(exchange: str):
-    return _MARKETS_BY_EXCHANGE[exchange]
-
-
-def set_exchange_parsed_markets(exchange: str, markets):
-    _MARKETS_BY_EXCHANGE[exchange] = markets
+async def emit_trading_signals(ctx):
+    try:
+        return await ctx.emit_signal()
+    except Exception as e:
+        ctx.logger.exception(e, True, f"Error when emitting trading signal: {e}")
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_connector.py`

 * *Files 16% similar despite different names*

```diff
@@ -87,83 +87,46 @@
                 
             if self.force_authentication or (
                 self._should_authenticate() and not self.exchange_manager.exchange_only
             ):
                 await self._ensure_auth()
 
             with self.error_describer():
-                await self.load_symbol_markets(
-                    reload=not self.exchange_manager.use_cached_markets,
-                    market_filter=self.exchange_manager.market_filter,
-                )
+                await self.load_symbol_markets(forced_markets=self.exchange_manager.forced_markets)
 
             # initialize symbols and timeframes
-            self.symbols = self.get_client_symbols(active_only=True)
+            self.symbols = self.get_client_symbols()
             self.time_frames = self.get_client_time_frames()
 
         except (ccxt.ExchangeNotAvailable, ccxt.RequestTimeout) as e:
-            raise octobot_trading.errors.UnreachableExchange(e) from e
+            raise octobot_trading.errors.UnreachableExchange() from e
         except ccxt.AuthenticationError:
             raise ccxt.AuthenticationError
 
     def get_adapter_class(self, adapter_class):
         return adapter_class or ccxt_adapter.CCXTAdapter
 
     @classmethod
     def load_user_inputs_from_class(cls, tentacles_setup_config, tentacle_config):
         # no user input in connector
         pass
 
-    @ccxt_client_util.converted_ccxt_common_errors
-    async def load_symbol_markets(
-        self,
-        reload=False,
-        market_filter: typing.Union[None, typing.Callable[[dict], bool]] = None
-    ):
-        load_markets = reload
-        if not load_markets:
-            try:
-                ccxt_client_util.load_markets_from_cache(self.client, market_filter=market_filter)
-            except KeyError:
-                load_markets = True
-        if load_markets:
-            self.logger.info(f"Loading {self.exchange_manager.exchange_name} exchange markets")
-            try:
-                await self.client.load_markets(reload=reload)
-                ccxt_client_util.set_markets_cache(self.client)
-            except ccxt.ExchangeNotAvailable as err:
-                raise octobot_trading.errors.FailedRequest(
-                    f"Failed to load_symbol_markets: {err.__class__.__name__} on {err}"
-                ) from err
-            except ccxt.ExchangeError:
-                # includes AuthenticationError but also auth error not identified as such by ccxt
-                if not self.force_authentication and self.is_authenticated:
-                    self.logger.debug(
-                        f"Credentials check enabled when fetching exchange market status, trying with "
-                        f"unauthenticated client."
-                    )
-                    # auth invalid but not required: fetch markets from another client
-                    unauth_client = None
-                    try:
-                        unauth_client = self._client_factory(True)[0]
-                        await unauth_client.load_markets(reload=reload)
-                        ccxt_client_util.set_markets_cache(unauth_client)
-                        # apply markets to target client
-                        ccxt_client_util.load_markets_from_cache(self.client, market_filter=market_filter)
-                        self.logger.debug(
-                            f"Fetched exchange market status from unauthenticated client."
-                        )
-                    finally:
-                        if unauth_client:
-                            await unauth_client.close()
-                else:
-                    raise
+    async def load_symbol_markets(self, reload=False, forced_markets=None):
+        if forced_markets is not None:
+            if forced_markets:
+                # only set markets if there are markets to be set
+                self.client.set_markets([
+                    self.client.parse_market(market) if hasattr(self.client, "parse_market") else market
+                    for market in forced_markets
+                ])
+        else:
+            await self.client.load_markets(reload=reload)
 
-    def get_client_symbols(self, active_only=True):
-        return ccxt_client_util.get_symbols(self.client, active_only)
+    def get_client_symbols(self):
+        return ccxt_client_util.get_symbols(self.client)
 
     def get_client_time_frames(self):
         return ccxt_client_util.get_time_frames(self.client)
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return isinstance(exchange_candidate_name, str)
@@ -188,46 +151,39 @@
         Add new options to ccxt client
         :param options_dict: the additional option keys and values as dict
         """
         self.options.update(options_dict)
         if self.client is not None:
             ccxt_client_util.add_options(self.client, options_dict)
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def _ensure_auth(self):
         try:
             await self.get_balance()
         except ccxt.AuthenticationError as e:
             await self.client.close()
             self.unauthenticated_exchange_fallback(e)
         except Exception as e:
             # Is probably handled in exchange tentacles, important thing here is that authentication worked
             self.logger.debug(f"Error when checking exchange connection: {e}. This should not be an issue.")
 
-    def _create_client(self, force_unauth=False):
-        self.client, self.is_authenticated = self._client_factory(force_unauth)
-
-    def _client_factory(self, force_unauth, keys_adapter=None) -> tuple:
-        return ccxt_client_util.create_client(
+    def _create_client(self):
+        self.client, self.is_authenticated = ccxt_client_util.create_client(
             self.exchange_type, self.exchange_manager, self.logger,
             self.options, self.headers, self.additional_config,
-            False if force_unauth else self._should_authenticate(), self.unauthenticated_exchange_fallback,
-            keys_adapter=keys_adapter
+            self._should_authenticate(), self.unauthenticated_exchange_fallback
         )
 
     def _should_authenticate(self):
         return self.force_authentication or not (
             self.exchange_manager.is_simulated or
             self.exchange_manager.is_backtesting
         )
 
     def unauthenticated_exchange_fallback(self, err):
-        if not self.exchange_manager.exchange_only:
-            # don't log error when auth is probably not necessary
-            self.handle_token_error(err)
+        self.handle_token_error(err)
         return ccxt_client_util.get_unauthenticated_exchange(
             self.exchange_type,
             self.options, self.headers, self.additional_config
         )
 
     def get_market_status(self, symbol, price_example=None, with_fixer=True):
         try:
@@ -236,15 +192,14 @@
             return self.client.market(symbol)
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except Exception as e:
             self.logger.error(f"Fail to get market status of {symbol}: {e}")
             return {}
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_balance(self, **kwargs: dict):
         """
         fetch balance (free + used) by currency
         :return: balance dict
         """
         if not kwargs:
             kwargs = {}
@@ -252,34 +207,30 @@
             with self.error_describer():
                 return self.adapter.adapt_balance(
                     await self.client.fetch_balance(params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_symbol_prices(self,
                                 symbol: str,
                                 time_frame: octobot_commons.enums.TimeFrames,
                                 limit: int = None,
                                 since: int = None,
                                 **kwargs: dict) -> typing.Optional[list]:
         try:
             with self.error_describer():
                 return self.adapter.adapt_ohlcv(
                     await self.client.fetch_ohlcv(symbol, time_frame.value, limit=limit, since=since, params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
-            raise octobot_trading.errors.FailedRequest(
-                f"Failed to get_symbol_prices of {symbol} on {time_frame.value}: {e.__class__.__name__} on {e}"
-            ) from e
+            raise octobot_trading.errors.FailedRequest(f"Failed to get_symbol_prices: {e.__class__.__name__} on {e}") from e
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_kline_price(self,
                               symbol: str,
                               time_frame: octobot_commons.enums.TimeFrames,
                               **kwargs: dict) -> typing.Optional[list]:
         try:
             with self.error_describer():
                 limit = kwargs.pop("limit", 1)
@@ -289,135 +240,122 @@
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_kline_price {e}")
 
     # return up to ten bidasks on each side of the order book stack
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_order_book(self, symbol: str, limit: int = 5, **kwargs: dict) -> typing.Optional[dict]:
         try:
             with self.error_describer():
                 return self.adapter.adapt_order_book(
                     await self.client.fetch_order_book(symbol, limit=limit, params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_order_book {e}")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_recent_trades(self, symbol: str, limit: int = 50, **kwargs: dict) -> typing.Optional[list]:
         try:
             with self.error_describer():
                 return self.adapter.adapt_public_recent_trades(
                     await self.client.fetch_trades(symbol, limit=limit, params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_recent_trades {e}")
 
     # A price ticker contains statistics for a particular market/symbol for some period of time in recent past (24h)
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_price_ticker(self, symbol: str, **kwargs: dict) -> typing.Optional[dict]:
         try:
             with self.error_describer():
                 return self.adapter.adapt_ticker(
                     await self.client.fetch_ticker(symbol, params=kwargs)
                 )
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_price_ticker {e}")
 
-    @ccxt_client_util.converted_ccxt_common_errors
-    async def get_all_currencies_price_ticker(self, **kwargs: dict) -> typing.Optional[dict[str, dict]]:
+    async def get_all_currencies_price_ticker(self, **kwargs: dict) -> typing.Optional[list]:
         try:
             with self.error_describer():
                 symbols = kwargs.pop("symbols", None)
                 self.all_currencies_price_ticker = {
                     symbol: self.adapter.adapt_ticker(ticker)
                     for symbol, ticker in (await self.client.fetch_tickers(symbols, params=kwargs)).items()
                 }
             return self.all_currencies_price_ticker
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except ccxt.BaseError as e:
             raise octobot_trading.errors.FailedRequest(f"Failed to get_all_currencies_price_ticker {e}")
 
     # ORDERS
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_order(self, exchange_order_id: str, symbol: str = None, **kwargs: dict) -> dict:
         if self.client.has['fetchOrder']:
             try:
                 with self.error_describer():
-                    order = await self.client.fetch_order(exchange_order_id, symbol, params=kwargs)
-                    if order.get(ccxt_constants.CCXT_INFO):
-                        return self.adapter.adapt_order(order, symbol=symbol)
-                    return None
-            except (ccxt.OrderNotFound, ccxt.InvalidOrder):
-                # some exchanges are throwing this error when an order
-                #   - is cancelled (ex: coinbase pro): ccxt.OrderNotFound
-                #   - or not yet created (ex: kucoin): ccxt.InvalidOrder
+                    return self.adapter.adapt_order(
+                        await self.client.fetch_order(exchange_order_id, symbol, params=kwargs),
+                        symbol=symbol
+                    )
+            except ccxt.OrderNotFound:
+                # some exchanges are throwing this error when an order is cancelled (ex: coinbase pro)
                 pass
             except ccxt.NotSupported as e:
                 # some exchanges are throwing this error when an order is cancelled (ex: coinbase pro)
-                raise octobot_trading.errors.NotSupported(e) from e
+                raise octobot_trading.errors.NotSupported from e
             except ccxt.ExchangeError as e:
-                if self.exchange_manager.exchange.is_order_not_found_error(e):
-                    # when an OrderNotFound error should have been raised but is not for some reason
-                    pass
-                else:
-                    # something went wrong and ccxt did not expect it
-                    raise octobot_trading.errors.FailedRequest(e) from e
+                # something went wrong and ccxt did not expect it
+                raise octobot_trading.errors.FailedRequest from e
         else:
-            # When fetch_order is not supported, uses get_open_orders or get_closed_orders and extract order id
-            for method in (self.get_open_orders, self.get_closed_orders):
-                orders = await method(symbol=symbol)
-                for order in orders:
-                    if order.get(ecoc.EXCHANGE_ID.value, None) == exchange_order_id:
-                        return order
-
+            # When fetch_order is not supported, uses get_open_orders and extract order id
+            open_orders = await self.get_open_orders(symbol=symbol)
+            for order in open_orders:
+                if order.get(ecoc.EXCHANGE_ID.value, None) == exchange_order_id:
+                    return order
         return None  # OrderNotFound
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_all_orders(self, symbol: str = None, since: int = None,
                              limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchOrders']:
             with self.error_describer():
                 return self.adapter.adapt_orders(
                     await self.client.fetch_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
                     symbol=symbol
                 )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchOrders")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_open_orders(self, symbol: str = None, since: int = None,
                               limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchOpenOrders']:
             with self.error_describer():
                 return self.adapter.adapt_orders(
                     await self.client.fetch_open_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
                     symbol=symbol
                 )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchOpenOrders")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_closed_orders(self, symbol: str = None, since: int = None,
                                 limit: int = None, **kwargs: dict) -> list:
-        with self.error_describer():
-            return self.adapter.adapt_orders(
-                await self.client.fetch_closed_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
-                symbol=symbol
-            )
+        try:
+            with self.error_describer():
+                return self.adapter.adapt_orders(
+                    await self.client.fetch_closed_orders(symbol=symbol, since=since, limit=limit, params=kwargs),
+                    symbol=symbol
+                )
+        except ccxt.NotSupported as e:
+            # fetch_closed_orders is not supported
+            raise octobot_trading.errors.NotSupported from e
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_my_recent_trades(self, symbol: str = None, since: int = None,
                                    limit: int = None, **kwargs: dict) -> list:
         if self.client.has['fetchMyTrades'] or self.client.has['fetchTrades']:
             with self.error_describer():
                 method = self.client.fetch_my_trades if self.client.has['fetchMyTrades'] else self.client.fetch_trades
                 trades = self.adapter.adapt_trades(await method(symbol=symbol, since=since, limit=limit, params=kwargs))
                 if trades or not self.exchange_manager.exchange.ALLOW_TRADES_FROM_CLOSED_ORDERS:
@@ -428,51 +366,46 @@
                     since=since,
                     limit=limit,
                     **kwargs
                 )
         else:
             raise octobot_trading.errors.NotSupported("This exchange doesn't support fetchMyTrades nor fetchTrades")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_market_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
             # use create_order instead of create_market_buy_order to pass the price argument
             await self.client.create_order(
                 symbol, enums.TradeOrderType.MARKET.value, enums.TradeOrderSide.BUY.value, quantity,
                 price=price, params=params
             ),
             symbol=symbol, quantity=quantity
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_limit_buy_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
             await self.client.create_limit_buy_order(symbol, quantity, price, params=params),
             symbol=symbol, quantity=quantity
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_market_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
             # use create_order instead of create_market_sell_order to pass the price argument
             await self.client.create_order(
                 symbol, enums.TradeOrderType.MARKET.value, enums.TradeOrderSide.SELL.value, quantity,
                 price=price, params=params
             ),
             symbol=symbol, quantity=quantity
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_limit_sell_order(self, symbol, quantity, price=None, params=None) -> dict:
         return self.adapter.adapt_order(
             await self.client.create_limit_sell_order(symbol, quantity, price, params=params),
             symbol=symbol, quantity=quantity
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_market_stop_loss_order(self, symbol, quantity, price, side, current_price, params=None) -> dict:
         if self.client.has.get("createStopMarketOrder"):
             try:
                 return self.adapter.adapt_order(
                     await self.client.createStopMarketOrder(
                         symbol,
                         side=side,
@@ -495,15 +428,14 @@
                 )
                 created_order[enums.ExchangeConstantsOrderColumns.TYPE.value] = (
                     enums.TraderOrderType.STOP_LOSS.value
                     )
                 return created_order
         raise NotImplementedError("create_market_stop_loss_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_limit_stop_loss_order(self, symbol, quantity, price, stop_price, side, params=None) -> dict:
         if self.client.has.get("createStopLimitOrder"):
             return self.adapter.adapt_order(
                 await self.client.create_stop_limit_order(
                     symbol,
                     side=side,
                     amount=quantity,
@@ -511,31 +443,26 @@
                     stopPrice=stop_price,
                     params=params,
                 ),
                 symbol=symbol, quantity=quantity
             )
         raise NotImplementedError("create_limit_stop_loss_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_market_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_market_take_profit_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_limit_take_profit_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_limit_take_profit_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_market_trailing_stop_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_market_trailing_stop_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def create_limit_trailing_stop_order(self, symbol, quantity, price=None, side=None, params=None) -> dict:
         raise NotImplementedError("create_limit_trailing_stop_order is not implemented")
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def edit_order(self, exchange_order_id: str, order_type: enums.TraderOrderType, symbol: str,
                          quantity: float, price: float, stop_price: float = None, side: str = None,
                          current_price: float = None, params: dict = None):
         ccxt_order_type = self.get_ccxt_order_type(order_type)
         price_to_use = price
         if ccxt_order_type == enums.TradeOrderType.MARKET.value:
             # can't set price in market orders
@@ -544,15 +471,14 @@
         return self.adapter.adapt_order(
             await self.client.edit_order(
                 exchange_order_id, symbol, ccxt_order_type, side, quantity, price_to_use, params
             ),
             symbol=symbol, quantity=quantity
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def cancel_order(
         self, exchange_order_id: str, symbol: str, order_type: enums.TraderOrderType, **kwargs: dict
     ) -> enums.OrderStatus:
         try:
             with self.error_describer():
                 await self.client.cancel_order(exchange_order_id, symbol=symbol, params=kwargs)
                 # no exception, cancel worked
@@ -572,94 +498,83 @@
                 return enums.OrderStatus.PENDING_CANCEL
             except ccxt.OrderNotFound:
                 # Order is not found: it has successfully been cancelled (some exchanges don't allow to
                 # get a cancelled order).
                 return enums.OrderStatus.CANCELED
         except ccxt.OrderNotFound as e:
             self.logger.debug(f"Trying to cancel order with id {exchange_order_id} but order was not found")
-            raise octobot_trading.errors.OrderCancelError(e) from e
+            raise octobot_trading.errors.OrderCancelError from e
         except (ccxt.NotSupported, octobot_trading.errors.NotSupported) as e:
-            raise octobot_trading.errors.NotSupported(e) from e
+            raise octobot_trading.errors.NotSupported from e
         except Exception as e:
             self.logger.exception(e, True, f"Unexpected error when cancelling order with exchange id: "
                                            f"{exchange_order_id} failed to cancel | {e} ({e.__class__.__name__})")
             raise e
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_positions(self, symbols=None, **kwargs: dict) -> list:
         try:
             return [
                 self.adapter.adapt_position(position)
                 for position in await self.client.fetch_positions(symbols=symbols, params=kwargs)
             ]
         except ccxt.NotSupported as err:
             raise NotImplementedError from err
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_position(self, symbol: str, **kwargs: dict) -> dict:
         try:
             return self.adapter.adapt_position(
                 await self.client.fetch_position(symbol=symbol, params=kwargs)
             )
         except ccxt.NotSupported as err:
             raise NotImplementedError from err
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_mocked_empty_position(self, symbol: str, **kwargs: dict) -> dict:
         return self.adapter.adapt_position(
             self.client.parse_position({}, market=self.client.market(symbol)),
             force_empty=True
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_funding_rate(self, symbol: str, **kwargs: dict) -> dict:
         return self.adapter.adapt_funding_rate(
             await self.client.fetch_funding_rate(symbol=symbol, params=kwargs)
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_funding_rate_history(self, symbol: str, limit: int = 1, **kwargs: dict) -> list:
         return self.adapter.adapt_funding_rate(
             await self.client.fetch_funding_rate_history(symbol=symbol, limit=limit, params=kwargs)
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_leverage_tiers(self, symbols: list = None, **kwargs: dict) -> dict:
         if self.client.has.get("fetchLeverageTiers"):
             return self.adapter.adapt_leverage_tiers(
                 await self.client.fetch_leverage_tiers(symbols=symbols, params=kwargs)
             )
         raise NotImplementedError("get_leverage_tiers is not supported")
 
     def get_contract_size(self, symbol: str):
         return decimal.Decimal(str(ccxt_client_util.get_contract_size(self.client, symbol)))
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def get_symbol_leverage(self, symbol: str, **kwargs: dict):
         return self.adapter.adapt_leverage(
             await self.client.fetch_leverage(symbol=symbol, params=kwargs)
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def set_symbol_leverage(self, symbol: str, leverage: float, **kwargs: dict):
         return await self.client.set_leverage(leverage=int(leverage), symbol=symbol, params=kwargs)
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def set_symbol_margin_type(self, symbol: str, isolated: bool, **kwargs: dict):
         return await self.client.set_margin_mode(
             ccxt_enums.ExchangeMarginTypes.ISOLATED.value if isolated else ccxt_enums.ExchangeMarginTypes.CROSS.value,
             symbol=symbol,
             params=kwargs,
         )
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def set_symbol_position_mode(self, symbol: str, one_way: bool):
         return await self.client.set_position_mode(self, hedged=not one_way, symbol=symbol)
 
-    @ccxt_client_util.converted_ccxt_common_errors
     async def set_symbol_partial_take_profit_stop_loss(self, symbol: str, inverse: bool,
                                                        tp_sl_mode: enums.TakeProfitStopLossMode):
         raise NotImplementedError("set_symbol_partial_take_profit_stop_loss is not implemented")
 
     def get_ccxt_order_type(self, order_type: enums.TraderOrderType):
         if order_type in (enums.TraderOrderType.BUY_LIMIT, enums.TraderOrderType.SELL_LIMIT,
                           enums.TraderOrderType.STOP_LOSS_LIMIT, enums.TraderOrderType.TAKE_PROFIT_LIMIT,
@@ -667,42 +582,51 @@
             return enums.TradeOrderType.LIMIT.value
         if order_type in (enums.TraderOrderType.BUY_MARKET, enums.TraderOrderType.SELL_MARKET,
                           enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.TAKE_PROFIT,
                           enums.TraderOrderType.TRAILING_STOP):
             return enums.TradeOrderType.MARKET.value
         raise RuntimeError(f"Unknown order type: {order_type}")
 
-    def get_trade_fee(self, symbol: str, order_type: enums.TraderOrderType, quantity, price, taker_or_maker):
+    def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         fees = self.client.calculate_fee(symbol=symbol,
                                          type=order_type,
                                          side=exchanges.get_order_side(order_type),
                                          amount=float(quantity),
                                          price=float(price),
                                          takerOrMaker=taker_or_maker)
         fees[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] = False
-        fees[enums.FeePropertyColumns.COST.value] = decimal.Decimal(
-            str(fees.get(enums.FeePropertyColumns.COST.value) or 0)
-        )
+        fees[enums.FeePropertyColumns.COST.value] = decimal.Decimal(str(fees[enums.FeePropertyColumns.COST.value]))
         if self.exchange_manager.is_future:
             # fees on futures are wrong
-            rate = fees.get(enums.FeePropertyColumns.RATE.value, 0) or 0
+            rate = fees[enums.FeePropertyColumns.RATE.value]
             # avoid using ccxt computed fees as they are often wrong
             # see https://docs.ccxt.com/en/latest/manual.html#trading-fees
             parsed_symbol = commons_symbols.parse_symbol(symbol)
             if self.exchange_manager.exchange.get_pair_future_contract(symbol).is_inverse_contract():
                 fees[enums.FeePropertyColumns.COST.value] = decimal.Decimal(str(rate)) * quantity
                 fees[enums.FeePropertyColumns.CURRENCY.value] = parsed_symbol.base
             else:
                 fees[enums.FeePropertyColumns.COST.value] = decimal.Decimal(str(rate)) * quantity * price
                 fees[enums.FeePropertyColumns.CURRENCY.value] = parsed_symbol.quote
         return fees
 
     def get_fees(self, symbol):
         try:
-            return ccxt_client_util.get_fees(self.client.market(symbol))
+            market_status = self.client.market(symbol)
+            return {
+                enums.ExchangeConstantsMarketPropertyColumns.TAKER.value:
+                    market_status.get(enums.ExchangeConstantsMarketPropertyColumns.TAKER.value,
+                                      constants.CONFIG_DEFAULT_FEES),
+                enums.ExchangeConstantsMarketPropertyColumns.MAKER.value:
+                    market_status.get(enums.ExchangeConstantsMarketPropertyColumns.MAKER.value,
+                                      constants.CONFIG_DEFAULT_FEES),
+                enums.ExchangeConstantsMarketPropertyColumns.FEE.value:
+                    market_status.get(enums.ExchangeConstantsMarketPropertyColumns.FEE.value,
+                                      constants.CONFIG_DEFAULT_FEES)
+            }
         except ccxt.NotSupported:
             raise octobot_trading.errors.NotSupported
         except Exception as e:
             self.logger.error(f"Fees data for {symbol} was not found ({e})")
             return {
                 enums.ExchangeConstantsMarketPropertyColumns.TAKER.value: constants.CONFIG_DEFAULT_FEES,
                 enums.ExchangeConstantsMarketPropertyColumns.MAKER.value: constants.CONFIG_DEFAULT_FEES,
@@ -751,17 +675,14 @@
 
     def get_default_balance(self):
         return self.client.account()
 
     def get_rate_limit(self):
         return self.exchange_type.rateLimit / 1000
 
-    def has_markets(self):
-        return bool(self.client.markets)
-
     def supports_trading_type(self, symbol, trading_type: enums.FutureContractType) -> bool:
         trading_type_to_ccxt_property = {
             enums.FutureContractType.LINEAR_PERPETUAL: "linear",
             enums.FutureContractType.LINEAR_EXPIRABLE: "linear",
             enums.FutureContractType.INVERSE_PERPETUAL: "inverse",
             enums.FutureContractType.INVERSE_EXPIRABLE: "inverse",
         }
@@ -846,26 +767,23 @@
     def log_ddos_error(self, error):
         self.logger.error(
             f"DDoSProtection triggered [{error} ({error.__class__.__name__})]. "
             f"Last response headers: {self.client.last_response_headers} "
             f"Last json response: {self.client.last_json_response}"
         )
 
-    def get_latest_request_url(self) -> str:
-        return self.client.last_request_url
-
     @contextlib.contextmanager
     def error_describer(self):
         try:
             yield
         except ccxt.DDoSProtection as e:
             # raised upon rate limit issues, last response data might have details on what is happening
             if self.exchange_manager.exchange.should_log_on_ddos_exception(e):
                 self.log_ddos_error(e)
             raise
         except ccxt.InvalidNonce as err:
             # use 2 index to get the caller of the context manager
             caller_function_name = inspect.stack()[2].function
             exchanges.log_time_sync_error(self.logger, self.name, err, caller_function_name)
-            raise octobot_trading.errors.FailedRequest(err) from err
+            raise octobot_trading.errors.FailedRequest from err
         except ccxt.RequestTimeout as e:
             raise octobot_trading.errors.FailedRequest(f"Request timeout: {e}") from e
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/ccxt_websocket_connector.py`

 * *Files 2% similar despite different names*

```diff
@@ -272,15 +272,14 @@
 
     async def _init_client(self):
         """
         Prepares client configuration and instantiates client feeds
         """
         try:
             self.initialized_event = asyncio.Event()
-            self.logger.info(f"Loading {self.exchange_manager.exchange_name} websocket exchange markets")
             await self.client.load_markets()
             self._filter_exchange_pairs_and_timeframes()
             self._subscribe_feeds()
         except Exception as e:
             self.logger.exception(e, True, f"Failed to subscribe when creating websocket feed : {e}")
         finally:
             self.initialized_event.set()
@@ -533,26 +532,21 @@
             self.logger.error(f"Aborting {feed.value} feed connection with {g_kwargs}: "
                               f"missing required initialization data")
             return
         enable_throttling = feed in self.THROTTLED_CHANNELS and self.throttled_ws_updates != 0.0
         ws_des = f"{watch_func.__name__} {g_kwargs}"
         subsequent_disconnections = 0
         already_got_feed_stopping_error = False
-        already_got_closed_by_user_error = False
         spamming_logs_warning_interval = 5000
         spamming_logs_debug_interval = 1000
         while not self.should_stop:
             try:
                 update_data = await watch_func(*g_args, **g_kwargs)
-
                 self._last_message_time = time.time()
-                if subsequent_disconnections > 0:
-                    self.logger.debug(f"Reconnected to {ws_des}")
                 subsequent_disconnections = 0
-                already_got_closed_by_user_error = False
                 if update_data:
                     # Use a copy of the update data as it will be edited by adapters.
                     # We should avoid editing the original object since it is also used in ccxt internally buffers
                     await callback(copy.deepcopy(update_data), **g_kwargs)
                 if enable_throttling:
                     # ccxt keeps updating the internal structures while waiting
                     # https://docs.ccxt.com/en/latest/ccxt.pro.manual.html?rtd_search=fetchLedger#incremental-data-structures
@@ -602,42 +596,23 @@
                     err,
                     True,
                     f"Impossible to start {ws_des} feed: {err}. "
                     f"Stopping it. Please report to the OctoBot team if you see this error"
                 )
                 return
             except Exception as err:
-                count_error = True
-                if isinstance(err, ccxt.ExchangeClosedByUser):
-                    if self.should_stop:
-                        # normal when stopping websocket
-                        self.logger.debug(
-                            f"Disconnected {ws_des}: connection closed as {self.get_name()} is stopping ({err})"
-                        )
-                        return
-                    # happening when auto-stopping websocket (calling self._close_exchange_to_force_reconnect)
-                    # from another task: current task also raised ccxt.ExchangeClosedByUser
-                    # this is normal as long as it happens only once after a reconnection
-                    if not already_got_closed_by_user_error:
-                        count_error = False
-                        self.logger.debug(
-                            f"{ws_des} connection automatically closed, reconnecting in {self.LONG_RECONNECT_DELAY} "
-                            f"seconds ({err})"
-                        )
-                        already_got_closed_by_user_error = True
-                if count_error:
-                    error_count = self._increment_error_counter(g_kwargs.get("time_frame"), err)
-                    error_message = f"Unexpected error when handling {ws_des} feed: {err} ({err.__class__.__name__}) " \
-                                    f"({error_count} times)"
-                    if error_count == 1:
-                        self.logger.exception(err, True, error_message)
-                    elif error_count % spamming_logs_warning_interval == 0:
-                        self.logger.warning(error_message)
-                    elif error_count % spamming_logs_debug_interval == 0:
-                        self.logger.debug(error_message)
+                error_count = self._increment_error_counter(g_kwargs.get("time_frame"), err)
+                error_message = f"Unexpected error when handling {ws_des} feed: {err} ({err.__class__.__name__}) " \
+                                f"({error_count} times)"
+                if error_count == 1:
+                    self.logger.exception(err, True, error_message)
+                elif error_count % spamming_logs_warning_interval == 0:
+                    self.logger.warning(error_message)
+                elif error_count % spamming_logs_debug_interval == 0:
+                    self.logger.debug(error_message)
                 await asyncio.sleep(self.LONG_RECONNECT_DELAY)  # avoid spamming
                 subsequent_disconnections += 1  # wait for a longer time before the next reconnect
                 # self.client might have changed
                 watch_func = self._get_feed_generator_by_feed()[feed]
 
     def _create_task_if_necessary(self, feed, feed_callback, feed_generator, **kwargs):
         identifier = self._get_feed_identifier(feed_generator, kwargs)
@@ -762,15 +737,15 @@
         if filtered_timeframes:
             self.min_timeframe = time_frame_manager.find_min_time_frame(filtered_timeframes)
 
     def _should_run_candle_feed(self):
         return self.EXCHANGE_FEEDS.get(Feeds.CANDLE, Feeds.UNSUPPORTED.value) != Feeds.UNSUPPORTED.value
 
     def _is_supported_pair(self, pair):
-        return pair in ccxt_client_util.get_symbols(self.client, True)
+        return pair in ccxt_client_util.get_symbols(self.client)
 
     def _is_pair_independent_feed(self, feed):
         return feed in self.PAIR_INDEPENDENT_CHANNELS
 
     def _convert_book_prices_to_orders(self, book_prices_and_volumes, book_side):
         """
         Convert a book_prices format : {PRICE_1: SIZE_1, PRICE_2: SIZE_2...}
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/constants.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/constants.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/ccxt/enums.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/ccxt/enums.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/connectors/simulator/exchange_simulator_connector.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,25 +14,24 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 
 import octobot_backtesting.api as backtesting_api
 import octobot_backtesting.importers as importers
 
+import octobot_commons.number_util as number_util
 import octobot_commons.symbols as symbol_util
 import octobot_commons.time_frame_manager as time_frame_manager
 import octobot_commons.constants as commons_constants
 
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
-import octobot_trading.errors as errors
 import octobot_trading.exchanges.abstract_exchange as abstract_exchange
 import octobot_trading.exchanges.connectors.simulator.exchange_simulator_adapter as exchange_simulator_adapter
-import octobot_trading.exchanges.connectors.simulator.ccxt_client_simulation as ccxt_client_simulation
 import octobot_trading.exchange_data as exchange_data
 import octobot_trading.exchanges.util as util
 
 
 class ExchangeSimulatorConnector(abstract_exchange.AbstractExchange):
     def __init__(self, config, exchange_manager, backtesting, adapter_class=None):
         super().__init__(config, exchange_manager)
@@ -41,15 +40,14 @@
         self.adapter = self.get_adapter_class(adapter_class)(self)
 
         self.exchange_importers = []
 
         self.current_future_candles = {}
 
         self.is_authenticated = False
-        self._forced_market_statuses: dict = None
 
     async def initialize_impl(self):
         self.exchange_importers = self.backtesting.get_importers(importers.ExchangeDataImporter)
         # load symbols and time frames
         for importer in self.exchange_importers:
             self.symbols.update(backtesting_api.get_available_symbols(importer))
             self.time_frames.update(importer.time_frames)
@@ -59,32 +57,17 @@
             symbol: {}
             for symbol in self.symbols
         }
 
         # set exchange manager attributes
         self.exchange_manager.client_symbols = list(self.symbols)
 
-        # init _forced_market_statuses when allowed
-        if self.exchange_manager.use_cached_markets:
-            self._init_forced_market_statuses()
-
     def get_adapter_class(self, adapter_class):
         return adapter_class or exchange_simulator_adapter.ExchangeSimulatorAdapter
 
-    def _init_forced_market_statuses(self):
-        def market_filter(market):
-            return market[enums.ExchangeConstantsMarketStatusColumns.SYMBOL.value] in self.symbols
-
-        self._forced_market_statuses = ccxt_client_simulation.parse_markets(
-            self.exchange_manager.exchange_class_string, market_filter
-        )
-
-    def should_adapt_market_statuses(self) -> bool:
-        return self.exchange_manager.use_cached_markets
-
     @classmethod
     def load_user_inputs_from_class(cls, tentacles_setup_config, tentacle_config):
         # no user input in connector
         pass
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
@@ -138,30 +121,19 @@
                     for time_frame in backtesting_api.get_available_time_frames(next(iter(self.exchange_importers)))]
         return []
 
     def get_backtesting_data_files(self):
         return [backtesting_api.get_data_file_path(importer) for importer in self.exchange_importers]
 
     def get_market_status(self, symbol, price_example=0, with_fixer=True):
-        if self._forced_market_statuses:
-            try:
-                if with_fixer:
-                    return util.ExchangeMarketStatusFixer(
-                        self._forced_market_statuses[symbol], price_example
-                    ).market_status
-                return self._forced_market_statuses[symbol]
-            except KeyError:
-                raise errors.NotSupported
-        return self._get_default_market_status()
-
-    def _get_default_market_status(self):
         return {
             # number of decimal digits "after the dot"
             enums.ExchangeConstantsMarketStatusColumns.PRECISION.value: {
                 enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value: 8,
+                enums.ExchangeConstantsMarketStatusColumns.PRECISION_COST.value: 8,
                 enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value: 8,
             },
             enums.ExchangeConstantsMarketStatusColumns.LIMITS.value: {
                 enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT.value: {
                     enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MIN.value: 0.00001,
                     enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MAX.value: 1000000000000,
                 },
@@ -176,18 +148,14 @@
             },
         }
 
     def get_uniform_timestamp(self, timestamp):
         return timestamp / 1000
 
     def get_fees(self, symbol):
-        if self._forced_market_statuses and symbol in self._forced_market_statuses:
-            # use self._forced_market_statuses when possible
-            return ccxt_client_simulation.get_fees(self._forced_market_statuses[symbol])
-
         result_fees = {
             enums.ExchangeConstantsMarketPropertyColumns.TAKER.value: constants.CONFIG_DEFAULT_SIMULATOR_FEES,
             enums.ExchangeConstantsMarketPropertyColumns.MAKER.value: constants.CONFIG_DEFAULT_SIMULATOR_FEES,
             enums.ExchangeConstantsMarketPropertyColumns.FEE.value: constants.CONFIG_DEFAULT_SIMULATOR_FEES
         }
 
         if commons_constants.CONFIG_SIMULATOR in self.config and \
@@ -219,47 +187,43 @@
     # returns {
     #     'type': takerOrMaker,
     #     'currency': 'BTC', // the unified fee currency code
     #     'rate': percentage, // the fee rate, 0.05% = 0.0005, 1% = 0.01, ...
     #     'cost': feePaid, // the fee cost (amount * fee rate)
     #     'is_from_exchange': False, // simulated fees
     # }
-    def get_trade_fee(self, symbol: str, order_type: enums.TraderOrderType, quantity, price, taker_or_maker):
+    def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         if not taker_or_maker:
             taker_or_maker = enums.ExchangeConstantsMarketPropertyColumns.TAKER.value
-        base, quote = symbol_util.parse_symbol(symbol).base_and_quote()
-        fee_currency = self._get_fees_currency(base, quote, order_type)
-
         symbol_fees = self.get_fees(symbol)
         rate = symbol_fees[taker_or_maker]
-        cost = quantity * decimal.Decimal(str(rate))
-        if fee_currency == quote:
-            cost = cost * price
+        currency, market = symbol_util.parse_symbol(symbol).base_and_quote()
+        fee_currency = currency
+
+        precision = self.get_market_status(symbol)[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value] \
+            [enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value]
+        cost = float(number_util.round_into_str_with_max_digits(float(quantity) * rate, precision))
+
+        if util.get_order_side(order_type) == enums.TradeOrderSide.SELL.value:
+            cost = float(number_util.round_into_str_with_max_digits(cost * float(price), precision))
+            fee_currency = market
 
         return {
             enums.FeePropertyColumns.TYPE.value: taker_or_maker,
             enums.FeePropertyColumns.CURRENCY.value: fee_currency,
             enums.FeePropertyColumns.RATE.value: rate,
-            enums.FeePropertyColumns.COST.value: cost,
+            enums.FeePropertyColumns.COST.value: decimal.Decimal(str(cost)),
             enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: False,
         }
 
-    def _get_fees_currency(self, base, quote, order_type: enums.TraderOrderType):
-        if util.get_order_side(order_type) is enums.TradeOrderSide.SELL.value:
-            return quote
-        return base
-
     def get_time_frames(self, importer):
         return time_frame_manager.sort_time_frames(list(set(backtesting_api.get_available_time_frames(importer)) &
                                                         set(self.exchange_manager.exchange_config.available_time_frames)),
                                                    reverse=True)
 
-    def use_accurate_price_time_frame(self) -> bool:
-        return self.backtesting.use_accurate_price_time_frame()
-
     def get_split_pair_from_exchange(self, pair) -> (str, str):
         return symbol_util.parse_symbol(pair).base_and_quote()
 
     def get_pair_cryptocurrency(self, pair) -> str:
         return self.get_split_pair_from_exchange(pair)[0]
 
     @staticmethod
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_builder.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_builder.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,15 +10,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import typing
 import octobot_commons.logging as logging
 import octobot_commons.constants as commons_constants
 
 import octobot_trading.errors as errors
 import octobot_trading.modes as modes
 import octobot_trading.exchanges as exchanges
 import octobot_trading.constants as constants
@@ -31,16 +30,14 @@
         self.config: dict = config
         self.exchange_name: str = exchange_name
 
         self.exchange_manager: exchanges.ExchangeManager = exchanges.ExchangeManager(self.config, self.exchange_name)
 
         self._is_using_trading_modes: bool = True
         self._matrix_id: str = None
-        self.trading_config_by_trading_mode: dict = None
-        self.auto_start_trading_modes: bool = True
 
     async def build(self):
         """
         Build the exchange
         """
         try:
             await self._build_exchange_manager()
@@ -110,28 +107,27 @@
         if self._is_using_trading_modes:
             # self.exchange_manager.trader can be None if neither simulator or real trader has be set
             if self.exchange_manager.is_trading:
                 if self.exchange_manager.trader is None:
                     self.logger.warning(f"There wont be any order created on {self.exchange_name}: neither "
                                         f"simulated nor real trader has been activated.")
                 else:
-                    self.exchange_manager.trading_modes = await self.build_trading_modes(trading_mode_class)
+                    self.exchange_manager.trading_modes = await self._build_trading_modes(trading_mode_class)
             else:
                 self.logger.info(f"{self.exchange_name} exchange is online and won't be trading")
 
-    async def build_trading_modes(self, trading_mode_class):
+    async def _build_trading_modes(self, trading_mode_class, trading_config_by_trading_mode=None):
         try:
             self._ensure_trading_mode_compatibility(trading_mode_class)
             return await modes.create_trading_modes(
                 self.config,
                 self.exchange_manager,
                 trading_mode_class,
                 self.exchange_manager.bot_id,
-                trading_config_by_trading_mode=self.trading_config_by_trading_mode,
-                auto_start=self.auto_start_trading_modes,
+                trading_config_by_trading_mode=trading_config_by_trading_mode
             )
         except errors.TradingModeIncompatibility as e:
             raise e
         except Exception as e:
             self.logger.error(f"An error occurred when initializing trading mode : {e}")
             raise e
 
@@ -214,30 +210,22 @@
         self.exchange_manager.rest_only = True
         return self
 
     def is_exchange_only(self):
         self.exchange_manager.exchange_only = True
         return self
 
-    def use_cached_markets(self, use_cached_markets: bool):
-        self.exchange_manager.use_cached_markets = use_cached_markets
-        return self
-
-    def use_market_filter(self, market_filter: typing.Union[None, typing.Callable[[dict], bool]]):
-        self.exchange_manager.market_filter = market_filter
+    def has_forced_markets(self, forced_markets: dict):
+        self.exchange_manager.forced_markets = forced_markets
         return self
 
     def is_ignoring_config(self, ignore_config=True):
         self.exchange_manager.ignore_config = ignore_config
         return self
 
-    def is_broker_enabled(self, is_broker_enabled=False):
-        self.exchange_manager.is_broker_enabled = is_broker_enabled
-        return self
-
     def is_without_auth(self):
         self.exchange_manager.without_auth = True
         return self
 
     def is_checking_credentials(self, check_credentials):
         self.exchange_manager.check_credentials = check_credentials
         return self
@@ -254,18 +242,10 @@
         self._is_using_trading_modes = False
         return self
 
     def has_matrix(self, matrix_id):
         self._matrix_id = matrix_id
         return self
 
-    def use_trading_config_by_trading_mode(self, trading_config_by_trading_mode):
-        self.trading_config_by_trading_mode = trading_config_by_trading_mode
-        return self
-
-    def set_auto_start_trading_modes(self, auto_start_trading_modes):
-        self.auto_start_trading_modes = auto_start_trading_modes
-        return self
-
 
 def create_exchange_builder_instance(config, exchange_name):
     return ExchangeBuilder(config, exchange_name)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_channels.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_channels.py`

 * *Files 2% similar despite different names*

```diff
@@ -168,16 +168,8 @@
     have been a few seconds ago)
     Return False if this channels updates by its exchange_manager
     and manual refresh trigger is not necessary (ex: websocket feed)
     :param exchange_manager: the related exchange manager
     :param channel: name of the channel
     :return: True if it should be refreshed via a manual trigger to be exactly up to date
     """
-    return not (
-        exchanges.is_channel_managed_by_websocket(exchange_manager, channel)
-        or _is_updater_refresh_disabled(exchange_manager)
-    )
-
-
-def _is_updater_refresh_disabled(exchange_manager):
-    # channel updaters are disabled on exchange_only mode
-    return exchange_manager.exchange_only
+    return not exchanges.is_channel_managed_by_websocket(exchange_manager, channel)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_details.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_details.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/spot_rest_exchange_test_tools.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-#  Drakkar-Software OctoBot-Trading
+#  Drakkar-Software OctoBot-Private-Tentacles
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
 #
@@ -10,150 +10,127 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import asyncio
+import decimal
 
-import trading_backend
+import async_channel.enums as channel_enums
+import octobot_commons.channels_name as channels_name
 
-import octobot_commons.authentication as authentication
-import octobot_trading.errors as errors
-import octobot_trading.exchanges as exchanges
-
-
-async def create_exchanges(exchange_manager):
-    if exchange_manager.is_sandboxed and not exchange_manager.exchange_only:
-        exchange_manager.logger.info(f"Using sandbox exchange for {exchange_manager.exchange_name}")
-
-    if exchange_manager.is_backtesting:
-        # simulated : create exchange simulator instance
-        await create_simulated_exchange(exchange_manager)
-        exchange_manager.load_constants()
-    else:
-        # real : create a rest or websocket exchange instance
-        await create_real_exchange(exchange_manager)
-        exchange_manager.load_constants()
-        await initialize_real_exchange(exchange_manager)
-
-    if not exchange_manager.exchange_only:
-        # create exchange producers if necessary
-        await exchanges.create_exchange_producers(exchange_manager)
-
-    if exchange_manager.is_backtesting:
-        await init_simulated_exchange(exchange_manager)
-
-    exchange_manager.exchange_name = exchange_manager.exchange.name
-    exchange_manager.is_ready = True
-
-
-async def create_real_exchange(exchange_manager) -> None:
-    """
-    Create and initialize real REST exchange
-    :param exchange_manager: the related exchange manager
-    """
-    await _create_rest_exchange(exchange_manager)
-    try:
-        await exchange_manager.exchange.initialize()
-        _create_exchange_backend(exchange_manager)
-        if exchange_manager.exchange_only:
-            return
-        await _initialize_exchange_backend(exchange_manager)
-    except errors.AuthenticationError:
-        exchange_manager.logger.error("Authentication error, retrying without authentication...")
-        exchange_manager.without_auth = True
-        await create_real_exchange(exchange_manager)
-        return
-
-
-async def initialize_real_exchange(exchange_manager):
-    if not exchange_manager.exchange_only:
-        await exchanges.create_exchange_channels(exchange_manager)
-
-    # create Websocket exchange if possible
-    if not exchange_manager.rest_only:
-        # search for websocket
-        if exchanges.check_web_socket_config(exchange_manager.config, exchange_manager.exchange.name):
-            await exchanges.search_and_create_websocket(exchange_manager)
-
-
-def _create_exchange_backend(exchange_manager):
-    try:
-        exchange_manager.exchange_backend = trading_backend.exchange_factory.create_exchange_backend(
-            exchange_manager.exchange
+import octobot_trading.enums as trading_enums
+import octobot_trading.exchange_channel as exchanges_channel
+import octobot_trading.personal_data as trading_personal_data
+import octobot_trading.util.test_tools.exchanges_test_tools as exchanges_test_tools
+
+
+class SpotRestExchangeTests:
+    SUBSCRIBED_CHANNELS = [channels_name.OctoBotTradingChannelsName.BALANCE_CHANNEL.value,
+                           channels_name.OctoBotTradingChannelsName.TRADES_CHANNEL.value,
+                           channels_name.OctoBotTradingChannelsName.ORDERS_CHANNEL.value]
+
+    def __init__(self, exchange_name, config):
+        self.config = config
+        self.exchange_name = exchange_name
+
+        self.exchange_manager_instance = None
+
+        self.channel_callbacks_triggered = {}
+        self.expected_crypto_in_balance = []
+
+    async def initialize(self):
+        self.exchange_manager_instance = await exchanges_test_tools.create_test_exchange_manager(
+            config=self.config, exchange_name=self.exchange_name,
+            rest_only=True, is_spot_only=True, is_sandboxed=True, ignore_exchange_config=False)
+        await self.exchange_manager_instance.trader.initialize()
+
+    async def run(self, symbol):
+        await self.subscribe_personal_channels()
+        await self.exchange_manager_instance.trader.cancel_all_open_orders()
+        await self.test_orders(symbol)
+
+    async def stop(self):
+        await exchanges_test_tools.stop_test_exchange_manager(self.exchange_manager_instance)
+
+    async def test_orders(self, symbol):
+        mark_price = await self.exchange_manager_instance.exchange_symbols_data.get_exchange_symbol_data(symbol) \
+            .prices_manager.get_mark_price(timeout=60)
+        await self._create_order(symbol,
+                                 trading_enums.TraderOrderType.SELL_LIMIT,
+                                 mark_price * decimal.Decimal("1.1"),
+                                 decimal.Decimal("1.001"),
+                                 mark_price * decimal.Decimal("1.1"))
+        await asyncio.sleep(7)
+        assert (await self._get_exchange_orders_count(symbol)) == 1
+        open_orders = self._get_orders_manager_open_orders(symbol)
+        assert len(open_orders) == 1
+        await self.exchange_manager_instance.trader.cancel_order_with_id(open_orders[-1].order_id)
+        await asyncio.sleep(7)
+        assert (await self._get_exchange_orders_count(symbol)) == 0
+        open_orders = self._get_orders_manager_open_orders(symbol)
+        assert len(open_orders) == 0
+
+    async def _get_exchange_orders_count(self, symbol):
+        return len(await self.exchange_manager_instance.exchange.get_open_orders(symbol=symbol))
+
+    def _get_orders_manager_open_orders(self, symbol):
+        return self.exchange_manager_instance.exchange_personal_data.orders_manager.get_open_orders(symbol)
+
+    async def test_all_callback_triggered(self):
+        for channel in self.SUBSCRIBED_CHANNELS:
+            assert self.channel_callbacks_triggered.get(channel, False)
+
+    async def _create_order(self, symbol, order_type, current_price, quantity, limit_price):
+        current_order = trading_personal_data.create_order_instance(trader=self.exchange_manager_instance.trader,
+                                                                    order_type=order_type,
+                                                                    symbol=symbol,
+                                                                    current_price=current_price,
+                                                                    quantity=quantity,
+                                                                    price=limit_price)
+        await self.exchange_manager_instance.trader.create_order(current_order)
+
+    async def subscribe_personal_channels(self):
+        await exchanges_channel.get_chan(channels_name.OctoBotTradingChannelsName.BALANCE_CHANNEL.value,
+                                         self.exchange_manager_instance.id).new_consumer(
+            self._balance_callback, priority_level=channel_enums.ChannelConsumerPriorityLevels.MEDIUM.value
+        )
+        await exchanges_channel.get_chan(channels_name.OctoBotTradingChannelsName.TRADES_CHANNEL.value,
+                                         self.exchange_manager_instance.id).new_consumer(
+            self._trades_callback, priority_level=channel_enums.ChannelConsumerPriorityLevels.MEDIUM.value
+        )
+        await exchanges_channel.get_chan(channels_name.OctoBotTradingChannelsName.ORDERS_CHANNEL.value,
+                                         self.exchange_manager_instance.id).new_consumer(
+            self._orders_callback, priority_level=channel_enums.ChannelConsumerPriorityLevels.MEDIUM.value
         )
-    except Exception as e:
-        exchange_manager.logger.exception(e, True, f"Error when creating exchange backend: {e}")
-
 
-async def _initialize_exchange_backend(exchange_manager):
-    if exchange_manager.exchange_backend is not None and exchange_manager.exchange.authenticated() \
-            and not exchange_manager.is_trader_simulated:
-        exchange_manager.logger.debug(await exchange_manager.exchange_backend.initialize())
-        initial_is_broker_enabled = exchange_manager.is_broker_enabled
-        try:
-            exchange_manager.is_broker_enabled, _ = await exchange_manager.exchange_backend.is_valid_account()
-            exchange_manager.logger.debug(f"Broker rebate enabled: {exchange_manager.is_broker_enabled}")
-        except Exception as err:
-            exchange_manager.is_broker_enabled = initial_is_broker_enabled
-            exchange_manager.logger.debug(f"Error when checking account broker state: {err}")
-
-
-async def _is_supporting_octobot() -> bool:
-    try:
-        authenticator = authentication.Authenticator.instance()
-        if not authenticator.is_initialized():
-            initialization_timeout = 5
-            await authenticator.await_initialization(initialization_timeout)
-        if authenticator.user_account.supports.is_supporting():
-            return True
-    except asyncio.TimeoutError:
-        pass
-    return False
-
-
-async def _create_rest_exchange(exchange_manager) -> None:
-    """
-    create REST based on ccxt exchange
-    :param exchange_manager: the related exchange manager
-    """
-    await _search_and_create_rest_exchange(exchange_manager)
-
-    if not exchange_manager.exchange:
-        raise Exception(f"Can't create an exchange instance that match the exchange configuration ({exchange_manager})")
-
-
-async def create_simulated_exchange(exchange_manager):
-    exchange_manager.exchange = exchanges.ExchangeSimulator(
-        exchange_manager.config, exchange_manager, exchange_manager.backtesting
-    )
-
-    await exchange_manager.exchange.initialize()
-    _initialize_simulator_time_frames(exchange_manager)
-    exchange_manager.exchange_config.set_config_time_frame()
-    exchange_manager.exchange_config.set_config_traded_pairs()
-    await exchanges.create_exchange_channels(exchange_manager)
-
-
-async def init_simulated_exchange(exchange_manager):
-    await exchange_manager.exchange.create_backtesting_exchange_producers()
-
-
-async def _search_and_create_rest_exchange(exchange_manager) -> None:
-    """
-    Create a rest exchange if a RestExchange matching class is found
-    :param exchange_manager: the related exchange manager
-    """
-    rest_exchange_class = exchanges.get_rest_exchange_class(exchange_manager.exchange_name,
-                                                            exchange_manager.tentacles_setup_config)
-    if rest_exchange_class:
-        exchange_manager.exchange = rest_exchange_class(config=exchange_manager.config,
-                                                        exchange_manager=exchange_manager)
-
-
-def _initialize_simulator_time_frames(exchange_manager):
-    """
-    Initialize simulator client time frames
-    :param exchange_manager: the related exchange manager
-    """
-    exchange_manager.client_time_frames = exchange_manager.exchange.get_available_time_frames()
+    def _check_balance_crypto(self, balance):
+        for crypto in self.expected_crypto_in_balance:
+            assert crypto in balance
+
+    async def _balance_callback(self, exchange: str, exchange_id: str, balance):
+        self.channel_callbacks_triggered[channels_name.OctoBotTradingChannelsName.BALANCE_CHANNEL.value] = True
+        self._check_balance_crypto(balance)
+
+    async def _trades_callback(
+            self,
+            exchange: str,
+            exchange_id: str,
+            cryptocurrency: str,
+            symbol: str,
+            trade: dict,
+            old_trade: bool,
+    ):
+        self.channel_callbacks_triggered[channels_name.OctoBotTradingChannelsName.TRADES_CHANNEL.value] = True
+
+    async def _orders_callback(
+            self,
+            exchange: str,
+            exchange_id: str,
+            cryptocurrency: str,
+            symbol: str,
+            order: dict,
+            update_type: str,
+            is_from_bot: bool,
+    ):
+        self.channel_callbacks_triggered[channels_name.OctoBotTradingChannelsName.ORDERS_CHANNEL.value] = True
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_manager.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import typing
 import uuid
 
 import octobot_commons.configuration as configuration
 import octobot_commons.constants as common_constants
 import octobot_commons.logging as logging
 import octobot_commons.timestamp_util as timestamp_util
 
@@ -44,16 +43,15 @@
         self.logger = logging.get_logger(self.__class__.__name__)
 
         self.is_ready = False
         self.is_simulated: bool = False
         self.is_backtesting: bool = False
         self.rest_only: bool = False
         self.ignore_config: bool = False
-        self.use_cached_markets: bool = True
-        self.market_filter: typing.Union[None, typing.Callable[[dict], bool]] = None
+        self.forced_markets: dict = None
         self.is_spot_only: bool = False
         self.is_margin: bool = False
         self.is_future: bool = False
         self.is_sandboxed: bool = False
         self.is_trading: bool = True
         self.without_auth: bool = False
         self.check_credentials: bool = True
@@ -66,15 +64,16 @@
 
         self.is_trader_simulated = util.is_trader_simulator_enabled(self.config)
         self.has_websocket = False
 
         self.trader = None
         self.exchange = None
         self.exchange_backend = None
-        self.is_broker_enabled = False
+        self.is_valid_account = True
+        self.init_error = None
         self.trading_modes = []
 
         self.exchange_web_socket = None
 
         self.client_symbols = []
         self.client_time_frames = []
 
@@ -98,84 +97,61 @@
         """
         if enable_logs:
             self.logger.debug("Stopping ...")
         # stop websockets if any
         if self.has_websocket:
             if enable_logs:
                 self.logger.debug("Stopping websocket ...")
-            try:
-                await self.exchange_web_socket.stop_sockets()
-                await self.exchange_web_socket.close_sockets()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange websocket: {err}")
+            await self.exchange_web_socket.stop_sockets()
+            await self.exchange_web_socket.close_sockets()
             self.exchange_web_socket.clear()
             self.exchange_web_socket = None
             if enable_logs:
                 self.logger.debug("Stopped websocket")
 
         # stop trading modes
         if enable_logs:
             self.logger.debug("Stopping trading modes ...")
         for trading_mode in self.trading_modes:
-            try:
-                await trading_mode.stop()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping trading mode: {err}")
+            await trading_mode.stop()
         if enable_logs:
             self.logger.debug("Stopped trading modes")
 
         # stop exchange channels
         if enable_logs:
             self.logger.debug(f"Stopping exchange channels for exchange_id: {self.id} ...")
         if self.exchange is not None:
             try:
                 exchange_channel.get_exchange_channels(self.id)
                 await exchange_channel.stop_exchange_channels(self, should_warn=warning_on_missing_elements)
             except KeyError:
                 # no exchange channel to stop
                 pass
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange channels: {err}")
-            try:
-                await self.exchange.stop()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange: {err}")
+            await self.exchange.stop()
             exchanges.Exchanges.instance().del_exchange(
                 self.exchange.name, self.id, should_warn=warning_on_missing_elements
             )
             self.exchange.exchange_manager = None
             self.exchange = None
         if self.exchange_personal_data is not None:
-            try:
-                await self.exchange_personal_data.stop()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange_personal_data: {err}")
+            await self.exchange_personal_data.stop()
         if self.exchange_symbols_data is not None:
-            try:
-                await self.exchange_symbols_data.stop()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange_symbols_data: {err}")
+            await self.exchange_symbols_data.stop()
         if enable_logs:
             self.logger.debug(f"Stopped exchange channels for exchange_id: {self.id}")
 
         if enable_logs:
             self.logger.debug("Stopping storages ...")
-        try:
-            await self.storage_manager.stop()
-        except Exception as err:
-            self.logger.exception(err, True, f"Error when stopping storage_manager: {err}")
+        await self.storage_manager.stop()
 
         self.exchange_config = None
         self.exchange_personal_data = None
         self.exchange_symbols_data = None
         if self.exchange_backend is not None:
-            try:
-                self.exchange_backend.stop()
-            except Exception as err:
-                self.logger.exception(err, True, f"Error when stopping exchange_backend: {err}")
+            self.exchange_backend.stop()
         if enable_logs:
             self.logger.debug("Stopping trader ...")
         if self.trader is not None:
             self.trader.clear()
             self.trader = None
         if enable_logs:
             self.logger.debug("Stopped trader")
@@ -304,23 +280,17 @@
         return True
 
     def get_exchange_credentials(self, exchange_name):
         if self.ignore_config or not self.should_decrypt_token() or self.without_auth:
             return "", "", ""
         config_exchange = self.config[common_constants.CONFIG_EXCHANGES][exchange_name]
         return (
-            configuration.decrypt_element_if_possible(
-                common_constants.CONFIG_EXCHANGE_KEY, config_exchange, None
-            ).strip(" "),   # remove leading and trailing whitespaces if any
-            configuration.decrypt_element_if_possible(
-                common_constants.CONFIG_EXCHANGE_SECRET, config_exchange, None
-            ).strip(" "),   # remove leading and trailing whitespaces if any
-            configuration.decrypt_element_if_possible(
-                common_constants.CONFIG_EXCHANGE_PASSWORD, config_exchange, None
-            )
+            configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_KEY, config_exchange, None),
+            configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_SECRET, config_exchange, None),
+            configuration.decrypt_element_if_possible(common_constants.CONFIG_EXCHANGE_PASSWORD, config_exchange, None)
         )
 
     def get_exchange_sub_account_id(self, exchange_name):
         config_exchange = self.config[common_constants.CONFIG_EXCHANGES][exchange_name]
         return config_exchange.get(common_constants.CONFIG_EXCHANGE_SUB_ACCOUNT, None)
 
     def is_storage_enabled(self):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchange_websocket_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchange_websocket_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/exchanges.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/exchanges.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/default_rest_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/default_rest_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/default_websocket_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/default_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/implementations/exchange_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/implementations/exchange_simulator.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,103 +10,60 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.constants as constants
-import octobot_trading.exchanges.util as exchange_util
 import octobot_trading.exchanges.connectors.simulator.exchange_simulator_connector as exchange_simulator_connector
 import octobot_trading.exchanges.types.rest_exchange as rest_exchange
 
 
 class ExchangeSimulator(rest_exchange.RestExchange):
     DEFAULT_CONNECTOR_CLASS = exchange_simulator_connector.ExchangeSimulatorConnector
 
     def __init__(self, config, exchange_manager, backtesting):
         self.backtesting = backtesting
         self.exchange_importers = []
-        self.exchange_tentacle_class = None
-        self.exchange_tentacle = None
         super().__init__(config, exchange_manager)
 
     def _create_connector(self, config, exchange_manager, connector_class):
         return (connector_class or self.DEFAULT_CONNECTOR_CLASS)(
             config,
             exchange_manager,
             self.backtesting,
             adapter_class=self.get_adapter_class(),
         )
 
     async def initialize_impl(self):
         await super().initialize_impl()
         self.exchange_importers = self.connector.exchange_importers
-        self.exchange_tentacle_class = exchange_util.get_rest_exchange_class(
-            self.exchange_manager.exchange_name, self.exchange_manager.tentacles_setup_config
-        )
-        if self.connector.should_adapt_market_statuses():
-            await self._init_exchange_tentacle()
-
-    async def _init_exchange_tentacle(self):
-        origin_ignore_config = self.exchange_manager.ignore_config
-        try:
-            self.exchange_tentacle = None
-            self.exchange_manager.ignore_config = True
-            # initialize a locale exchange_tentacle to be able to access adapters for market statuses
-            if self.exchange_tentacle_class:
-                self.exchange_tentacle = self.exchange_tentacle_class(
-                    self.exchange_manager.config, self.exchange_manager
-                )
-        finally:
-            self.exchange_manager.ignore_config = origin_ignore_config
-            # reset ignore_config as soon as possible
-        if self.exchange_tentacle:
-            if adapter_class := self.exchange_tentacle.get_adapter_class():
-                self.connector.adapter.set_tentacles_adapter_proxy(adapter_class)
-            # do not keep the created ccxt exchange
-            await self.exchange_tentacle.stop()
 
     async def stop(self) -> None:
         await super().stop()
         self.backtesting = None
         self.exchange_importers = None
-        self.exchange_tentacle = None
 
     @classmethod
     def is_supporting_exchange(cls, exchange_candidate_name) -> bool:
         return exchange_simulator_connector.ExchangeSimulatorConnector.is_supporting_exchange(exchange_candidate_name)
 
-    def is_skipping_empty_candles_in_ohlcv_fetch(self):
-        return (self.exchange_tentacle_class or self).IS_SKIPPING_EMPTY_CANDLES_IN_OHLCV_FETCH
-
     @classmethod
     def is_simulated_exchange(cls) -> bool:
         return exchange_simulator_connector.ExchangeSimulatorConnector.is_simulated_exchange()
 
     async def create_backtesting_exchange_producers(self):
         return await self.connector.create_backtesting_exchange_producers()
 
-    def _should_fix_market_status(self):
-        return (self.exchange_tentacle or self).FIX_MARKET_STATUS
-
-    def _should_remove_market_status_limits(self):
-        return (self.exchange_tentacle or self).REMOVE_MARKET_STATUS_PRICE_LIMITS
-
-    def _should_adapt_market_status_for_contract_size(self):
-        return (self.exchange_tentacle or self).ADAPT_MARKET_STATUS_FOR_CONTRACT_SIZE
-
     def get_available_time_frames(self):
         return self.connector.get_available_time_frames()
 
     def get_time_frames(self, importer):
         return self.connector.get_time_frames(importer)
 
-    def use_accurate_price_time_frame(self) -> bool:
-        return self.connector.use_accurate_price_time_frame()
-
     def get_current_future_candles(self):
         return self.connector.current_future_candles
 
     def get_backtesting_data_files(self):
         return self.connector.get_backtesting_data_files()
 
     async def load_pair_future_contract(self, pair: str):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/trader.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/trader.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# pylint: disable=W0706
 #  Drakkar-Software OctoBot-Trading
 #  Copyright (c) Drakkar-Software, All rights reserved.
 #
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3.0 of the License, or (at your option) any later version.
@@ -111,18 +110,18 @@
         created_order = order
         try:
             params = params or {}
             self.logger.info(f"Creating order: {created_order}")
             created_order = await self._create_new_order(order, params, wait_for_creation=wait_for_creation,
                                                          creation_timeout=creation_timeout)
             if created_order is None:
-                self.logger.warning(f"Order not created on {self.exchange_manager.exchange_name} "
+                self.logger.warning(f"Order not created order on {self.exchange_manager.exchange_name} "
                                     f"(failed attempt to create: {order}). This is likely due to "
                                     f"the order being refused by the exchange.")
-        except (errors.MissingFunds, errors.AuthenticationError, errors.ExchangeCompliancyError):
+        except errors.MissingFunds:
             # forward errors that require actions to fix the situation
             raise
         except Exception as e:
             self.logger.exception(e, True, f"Unexpected error when creating order: {e}. Order: {order}")
             return None
 
         return created_order
@@ -254,15 +253,15 @@
             )
             if created_order is None:
                 return None
             self.logger.debug(f"Successfully created order on {self.exchange_manager.exchange_name}: {created_order}")
 
             # get real order from exchange
             updated_order = order_factory.create_order_instance_from_raw(
-                self, created_order, force_open_or_pending_creation=True, has_just_been_created=True
+                self, created_order, force_open_or_pending_creation=True
             )
             is_pending_creation = updated_order.status == enums.OrderStatus.PENDING_CREATION
 
             # rebind local elements to new order instance
             if new_order.order_group:
                 updated_order.add_to_order_group(new_order.order_group)
             updated_order.order_id = new_order.order_id
@@ -275,40 +274,25 @@
             updated_order.exchange_creation_params = new_order.exchange_creation_params
             updated_order.is_waiting_for_chained_trigger = new_order.is_waiting_for_chained_trigger
             updated_order.associated_entry_ids = new_order.associated_entry_ids
             updated_order.update_with_triggering_order_fees = new_order.update_with_triggering_order_fees
 
             if is_pending_creation:
                 # register order as pending order, it will then be added to live orders in order manager once open
-                self.exchange_manager.exchange_personal_data.orders_manager.register_pending_creation_order(
-                    updated_order
-                )
+                self.exchange_manager.exchange_personal_data.orders_manager.register_pending_creation_order(updated_order)
 
         await updated_order.initialize()
         if is_pending_creation and wait_for_creation \
                 and updated_order.state is not None and updated_order.state.is_pending():
             await updated_order.state.wait_for_terminate(creation_timeout)
         return updated_order
 
-    def get_take_profit_order_type(self, base_order, order_type: enums.TraderOrderType) -> enums.TraderOrderType:
-        """
-        Returns the adapted take profit order enums.TraderOrderType.
-        :return: enums.TraderOrderType.TAKE_PROFIT when order can be bundled and considered as a real take profit
-        from exchange and the given order_type otherwise
-        """
-        if not self.simulate and self.exchange_manager.exchange.supports_bundled_order_on_order_creation(
-            base_order, enums.TraderOrderType.TAKE_PROFIT
-        ):
-            # use take profit order type for bundled orders, use default order type otherwise
-            return enums.TraderOrderType.TAKE_PROFIT
-        return order_type
-
     async def bundle_chained_order_with_uncreated_order(
         self, order, chained_order, update_with_triggering_order_fees, **kwargs
-    ) -> dict:
+    ):
         """
         Creates and bundles an order as a chained order to the given order.
         When supported and in real trading, return the stop loss parameters to be given when
         pushing the initial order on exchange
         :param order: the order to create a chained order from after fill
         :param chained_order: the chained order to create when the 1st order is filled
         :param update_with_triggering_order_fees: if the chained order quantity should
@@ -334,21 +318,18 @@
                     take_profit_price=chained_order.origin_price
                 ))
             if params:
                 self.logger.debug(
                     f"Including {chained_order.order_type} chained order into order "
                     f"parameters to handle it directly on exchange."
                 )
-        await self.chain_order(order, chained_order, update_with_triggering_order_fees, is_bundled, **kwargs)
-        return params
-
-    async def chain_order(self, order, chained_order, update_with_triggering_order_fees, is_bundled, **kwargs):
         await chained_order.set_as_chained_order(order, is_bundled, {}, update_with_triggering_order_fees, **kwargs)
         order.add_chained_order(chained_order)
-        self.logger.info(f"Added chained order [{chained_order}] to [{order}] order.")
+        self.logger.debug(f"Added chained order [{chained_order}] to [{order}] order.")
+        return params
 
     async def cancel_order(self, order, ignored_order=None,
                            wait_for_cancelling=True,
                            cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT) -> bool:
         """
         Cancels the given order and updates the portfolio, publish in order channel
         if order is from a real exchange.
@@ -520,15 +501,15 @@
                             order,
                             wait_for_cancelling=wait_for_cancelling,
                             cancelling_timeout=cancelling_timeout, )
                     if cancelled:
                         cancelled_orders.append(order)
                     all_cancelled = cancelled and all_cancelled
                 except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
-                    self.logger.warning(f"Skipping order cancel: {err} ({err.__class__.__name__})")
+                    self.logger.warning(f"Skipping order cancel: {err}")
         return all_cancelled, cancelled_orders
 
     async def cancel_all_open_orders_with_currency(
             self, currency, emit_trading_signals=False,
             wait_for_cancelling=True,
             cancelling_timeout=octobot_trading.constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT
     ) -> bool:
@@ -573,15 +554,15 @@
                         all_cancelled = await signals.cancel_order(
                             self.exchange_manager,
                             emit_trading_signals and signals.should_emit_trading_signal(self.exchange_manager),
                             order,
                             wait_for_cancelling=wait_for_cancelling,
                             cancelling_timeout=cancelling_timeout, ) and all_cancelled
                 except (errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError) as err:
-                    self.logger.warning(f"Skipping order cancel: {err} ({err.__class__.__name__})")
+                    self.logger.warning(f"Skipping order cancel: {err}")
                     all_cancelled = False
         return all_cancelled
 
     async def _sell_everything(self, symbol, inverted, timeout=None):
         created_orders = []
         order_type = octobot_trading.enums.TraderOrderType.BUY_MARKET \
             if inverted else octobot_trading.enums.TraderOrderType.SELL_MARKET
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/traders/trader_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/traders/trader_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/rest_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/rest_exchange.py`

 * *Files 4% similar despite different names*

```diff
@@ -39,20 +39,14 @@
 
 
 class RestExchange(abstract_exchange.AbstractExchange):
     ORDER_NON_EMPTY_FIELDS = [ecoc.EXCHANGE_ID.value, ecoc.TIMESTAMP.value, ecoc.SYMBOL.value, ecoc.TYPE.value,
                               ecoc.SIDE.value, ecoc.PRICE.value, ecoc.AMOUNT.value, ecoc.STATUS.value]
     ORDER_REQUIRED_FIELDS = ORDER_NON_EMPTY_FIELDS + [ecoc.REMAINING.value]
     PRINT_DEBUG_LOGS = False
-    FIX_MARKET_STATUS = False  # set True when get_fixed_market_status should be called when calling get_market_status
-    # set True when get_fixed_market_status should be remove price limits (when limits are invalid)
-    REMOVE_MARKET_STATUS_PRICE_LIMITS = False
-    # set True when get_fixed_market_status should adapt amounts for contract size
-    # (amounts are in not kept as contract size with OctoBot)
-    ADAPT_MARKET_STATUS_FOR_CONTRACT_SIZE = False
     REQUIRE_ORDER_FEES_FROM_TRADES = False  # set True when get_order is not giving fees on closed orders and fees
     # should be fetched using recent trades.
     REQUIRE_CLOSED_ORDERS_FROM_RECENT_TRADES = False  # set True when get_closed_orders is not supported
     ALLOW_TRADES_FROM_CLOSED_ORDERS = False  # set True when get_my_recent_trades should use get_closed_orders
     DUMP_INCOMPLETE_LAST_CANDLE = False  # set True in tentacle when the exchange can return incomplete last candles
     # Set True when exchange is not returning empty position details when fetching a position with a specified symbol
     # Exchange will then fallback to self.get_mocked_empty_position when having get_position returning None
@@ -63,17 +57,14 @@
     SUPPORTS_SET_MARGIN_TYPE_ON_OPEN_POSITIONS = True  # set False when the exchange refuses to change margin type
     # when an associated position is open
     EXPECT_POSSIBLE_ORDER_NOT_FOUND_DURING_ORDER_CREATION = False  # set True when get_order() can return None
     # (order not found) when orders are being created on exchange and are not fully processed on the exchange side.
     REQUIRES_AUTHENTICATION = False  # set True when even normally public apis require authentication
     HAS_FETCHED_DETAILS = False  # set True when this exchange details (urls etc) have to be fetched before
     # starting the exchange
-    IS_SKIPPING_EMPTY_CANDLES_IN_OHLCV_FETCH = False    # set True when the exchange is known for not returning any
-    # candle when no traded happened during a candle time frame. In this case, a missing candle in backtesting won't
-    # trigger an error
     """
     RestExchange is using its exchange connector to interact with the exchange.
     It should be used regardless of the exchange or the exchange library (ccxt or other)
     Always take and returns octobot formatted data and errors
     Is used request regardless of the trading type (spot / future / other)
 
     Is extended in exchange tentacles to define custom behaviors or exchange adapter (override of get_adapter_class)
@@ -85,25 +76,14 @@
     # Funding rate params
     FUNDING_WITH_MARK_PRICE = False
     FUNDING_IN_TICKER = False
 
     # Set when order cost is not (yet) accurately computed for a given exchange
     MAX_INCREASED_POSITION_QUANTITY_MULTIPLIER = constants.ONE
 
-    # text content of errors due to orders not found errors
-    EXCHANGE_ORDER_NOT_FOUND_ERRORS: typing.List[typing.Iterable[str]] = []
-    # when ccxt is raising ccxt.ExchangeError instead of ccxt.AuthenticationError on api key permissions issue
-    # text content of errors due to api key permissions issues
-    EXCHANGE_PERMISSION_ERRORS: typing.List[typing.Iterable[str]] = []
-    # text content of errors due to account compliancy issues
-    EXCHANGE_COMPLIANCY_ERRORS: typing.List[typing.Iterable[str]] = []
-    # text content of errors due to exchange local account permissions (ex: accounts from X country can't trade XYZ)
-    # text content of errors due to traded assets for account
-    EXCHANGE_ACCOUNT_TRADED_SYMBOL_PERMISSION_ERRORS: typing.List[typing.Iterable[str]] = []
-
     DEFAULT_CONNECTOR_CLASS = ccxt_connector.CCXTConnector
 
     def __init__(self, config, exchange_manager, connector_class=None):
         super().__init__(config, exchange_manager)
         if self.HAS_FETCHED_DETAILS:
             self._fetch_details(config, exchange_manager)
         self.connector = self._create_connector(config, exchange_manager, connector_class)
@@ -159,16 +139,15 @@
                            reduce_only: bool = False, params: dict = None) -> typing.Optional[dict]:
         async with self._order_operation(order_type, symbol, quantity, price, stop_price):
             created_order = await self._create_order_with_retry(
                 order_type=order_type, symbol=symbol, quantity=quantity, price=price,
                 stop_price=stop_price, side=side, current_price=current_price,
                 reduce_only=reduce_only, params=params)
             self.logger.debug(f"Created order: {created_order}")
-            with self.creating_order(created_order):
-                return await self._verify_order(created_order, order_type, symbol, price, side)
+            return await self._verify_order(created_order, order_type, symbol, price, side)
         return None
 
     async def edit_order(self, exchange_order_id: str, order_type: enums.TraderOrderType, symbol: str,
                          quantity: decimal.Decimal, price: decimal.Decimal,
                          stop_price: decimal.Decimal = None, side: enums.TradeOrderSide = None,
                          current_price: decimal.Decimal = None,
                          params: dict = None):
@@ -200,51 +179,23 @@
     async def _order_operation(self, order_type, symbol, quantity, price, stop_price):
         try:
             yield
         except ccxt.InsufficientFunds as e:
             self.log_order_creation_error(e, order_type, symbol, quantity, price, stop_price)
             if self.__class__.PRINT_DEBUG_LOGS:
                 self.logger.warning(str(e))
-            raise errors.MissingFunds(e) from e
-        except ccxt.NotSupported as err:
-            raise errors.NotSupported from err
-        except ccxt.AuthenticationError as err:
-            # invalid api key or missing trading rights
-            raise errors.AuthenticationError(
-                f"Error when handling order {err}. Please make sure that trading permissions are on for this API key."
-            ) from err
+            raise errors.MissingFunds(e)
+        except ccxt.NotSupported:
+            raise errors.NotSupported
         except ccxt.DDoSProtection as e:
             # raised upon rate limit issues, last response data might have details on what is happening
-            # ensure this is not a permission error (can happen on binance)
-            if self.is_api_permission_error(e):
-                # invalid api key or missing trading rights
-                raise errors.AuthenticationError(
-                    f"Error when handling order {e}. Please make sure that trading permissions are on for this API key."
-                ) from e
             if self.should_log_on_ddos_exception(e):
                 self.connector.log_ddos_error(e)
             raise errors.FailedRequest(f"Failed to order operation: {e.__class__.__name__} {e}") from e
-        except errors.ExchangeAccountSymbolPermissionError:
-            raise
         except Exception as e:
-            if not self.is_market_open_for_order_type(symbol, order_type):
-                raise errors.UnavailableOrderTypeForMarketError(
-                    f"Error when handling order {e}. "
-                    f"Exchange currently refuses to create orders of type {order_type} on {symbol}."
-                ) from e
-            if self.is_api_permission_error(e):
-                # invalid api key or missing trading rights
-                raise errors.AuthenticationError(
-                    f"Error when handling order {e}. Please make sure that trading permissions are on for this API key."
-                ) from e
-            if self.is_exchange_rules_compliancy_error(e):
-                raise errors.ExchangeCompliancyError(
-                    f"Error when handling order {e}. Exchange is refusing this order request on this account because "
-                    f"of its compliancy requirements."
-                ) from e
             self.log_order_creation_error(e, order_type, symbol, quantity, price, stop_price)
             print(traceback.format_exc(), file=sys.stderr)
             self.logger.exception(e, False, f"Unexpected error during order operation: {e}")
 
     async def _verify_order(self, created_order, order_type, symbol, price, side, get_order_params=None):
         # some exchanges are not returning the full order details on creation: fetch it if necessary
         if created_order and not self._ensure_order_details_completeness(created_order):
@@ -279,24 +230,19 @@
                                        current_price: decimal.Decimal, 
                                        reduce_only: bool, params) -> dict:
         try:
             return await self._create_specific_order(order_type, symbol, quantity, price=price,
                                                      stop_price=stop_price, side=side,
                                                      current_price=current_price, 
                                                      reduce_only=reduce_only, params=params)
-        except (ccxt.InvalidOrder, ccxt.BadRequest) as err:
-            if self.is_exchange_account_traded_symbol_permission_error(err):
-                # exchange won't let this order create: raise
-                raise errors.ExchangeAccountSymbolPermissionError(
-                    f"Error when creating {symbol} {order_type} order on {self.exchange_manager.exchange_name}: {err}"
-                ) from err
+        except (ccxt.InvalidOrder, ccxt.BadRequest) as e:
             # can be raised when exchange precision/limits rules change
-            self.logger.debug(f"Failed to create order ({err}) : order_type: {order_type}, symbol: {symbol}. "
+            self.logger.debug(f"Failed to create order ({e}) : order_type: {order_type}, symbol: {symbol}. "
                               f"This might be due to an update on {self.name} market rules. Fetching updated rules.")
-            await self.connector.load_symbol_markets(reload=True, market_filter=self.exchange_manager.market_filter)
+            await self.connector.load_symbol_markets(reload=True)
             # retry order creation with updated markets (ccxt will use the updated market values)
             return await self._create_specific_order(order_type, symbol, quantity, price=price, 
                                                      stop_price=stop_price, side=side,
                                                      current_price=current_price, reduce_only=reduce_only, 
                                                      params=params)
 
     def _ensure_order_details_completeness(self, order, order_required_fields=None, order_non_empty_fields=None):
@@ -403,58 +349,65 @@
 
     def get_exchange_current_time(self):
         return self.connector.get_exchange_current_time()
 
     def get_uniform_timestamp(self, timestamp):
         return self.connector.get_uniform_timestamp(timestamp)
 
-    def _should_fix_market_status(self):
-        return self.FIX_MARKET_STATUS
-
-    def _should_remove_market_status_limits(self):
-        return self.REMOVE_MARKET_STATUS_PRICE_LIMITS
-
-    def _should_adapt_market_status_for_contract_size(self):
-        return self.ADAPT_MARKET_STATUS_FOR_CONTRACT_SIZE
-
     def get_market_status(self, symbol, price_example=None, with_fixer=True):
         """
         Override using get_fixed_market_status in exchange tentacle if the default market status is not as expected
         """
-        if self._should_fix_market_status():
-            return self.get_fixed_market_status(
-                symbol,
-                price_example=price_example,
-                with_fixer=with_fixer,
-                remove_price_limits=self._should_remove_market_status_limits(),
-                adapt_for_contract_size=self._should_adapt_market_status_for_contract_size()
-            )
         return self.connector.get_market_status(symbol, price_example=price_example, with_fixer=with_fixer)
 
     def get_fixed_market_status(self, symbol, price_example=None, with_fixer=True, remove_price_limits=False,
                                 adapt_for_contract_size=False):
         """
         Use this method in local get_market_status overrides when market status has to be fixed by
         calling _fix_market_status.
         Changes PRECISION_AMOUNT and PRECISION_PRICE from decimals to integers
         (use number of digits instead of price example) by default.
         Override _fix_market_status to change other elements
         """
-        market_status = self.connector.adapter.adapt_market_status(
+        market_status = self._fix_market_status(
             copy.deepcopy(
                 self.connector.get_market_status(symbol, with_fixer=False)
             ),
             remove_price_limits=remove_price_limits
         )
         if adapt_for_contract_size and self.exchange_manager.is_future:
             self._adapt_market_status_for_contract_size(market_status, self.get_contract_size(symbol))
         if with_fixer:
             return exchanges_util.ExchangeMarketStatusFixer(market_status, price_example).market_status
         return market_status
 
+    def _fix_market_status(self, market_status, remove_price_limits=False):  # todo move to adapter
+        """
+        Overrite if necessary
+        """
+        market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
+            enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value] = number_util.get_digits_count(
+            market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
+                enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value]
+        )
+        market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
+            enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value] = number_util.get_digits_count(
+            market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
+                enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value]
+        )
+        if remove_price_limits:
+            market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][
+                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value][
+                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MIN.value] = None
+            market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][
+                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value][
+                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MAX.value] = None
+
+        return market_status
+
     def _apply_contract_size(self, value, contract_size):
         if value is None:
             return value
         return value * contract_size
 
     def _adapt_market_status_for_contract_size(self, market_status, contract_size):
         float_size = float(contract_size)
@@ -467,22 +420,16 @@
                         market_status[enums.ExchangeConstantsMarketStatusColumns.LIMITS.value][limit_type][limit_val],
                         float_size
                     )
         market_status[enums.ExchangeConstantsMarketStatusColumns.PRECISION.value][
             enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value] = \
             number_util.get_digits_count(float_size)
 
-    async def get_account_id(self, **kwargs: dict) -> str:
-        raise NotImplementedError(f"get_account_id is not implemented on {self.exchange_manager.exchange_name}")
-
     async def get_balance(self, **kwargs: dict):
-        try:
-            return await self.connector.get_balance(**kwargs)
-        except ccxt.AuthenticationError as err:
-            raise errors.AuthenticationError(err) from err
+        return await self.connector.get_balance(**kwargs)
 
     async def get_symbol_prices(self, symbol: str, time_frame: commons_enums.TimeFrames, limit: int = None,
                                 **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_symbol_prices(symbol=symbol, time_frame=time_frame, limit=limit, **kwargs)
 
     async def get_kline_price(self, symbol: str, time_frame: commons_enums.TimeFrames,
                               **kwargs: dict) -> typing.Optional[list]:
@@ -495,15 +442,15 @@
 
     async def get_recent_trades(self, symbol: str, limit: int = 50, **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_recent_trades(symbol=symbol, limit=limit, **kwargs)
 
     async def get_price_ticker(self, symbol: str, **kwargs: dict) -> typing.Optional[dict]:
         return await self.connector.get_price_ticker(symbol=symbol, **kwargs)
 
-    async def get_all_currencies_price_ticker(self, **kwargs: dict) -> typing.Optional[dict[str, dict]]:
+    async def get_all_currencies_price_ticker(self, **kwargs: dict) -> typing.Optional[list]:
         return await self.connector.get_all_currencies_price_ticker(**kwargs)
 
     async def get_order(self, exchange_order_id: str, symbol: str = None, **kwargs: dict) -> dict:
         return await self._ensure_order_completeness(
             await self.connector.get_order(exchange_order_id, symbol=symbol, **kwargs),
             symbol, **kwargs
         )
@@ -575,19 +522,15 @@
             )
             for order in raw_orders
         ]
 
     async def _ensure_order_completeness(
         self, raw_order, symbol, since=None, limit=None, trades_by_exchange_order_id=None, **kwargs
     ):
-        if (
-            raw_order is None
-            or not self.REQUIRE_ORDER_FEES_FROM_TRADES
-            or not exchanges_util.is_missing_trading_fees(raw_order)
-        ):
+        if not self.REQUIRE_ORDER_FEES_FROM_TRADES or not exchanges_util.is_missing_trading_fees(raw_order):
             return raw_order
         trades_by_exchange_order_id = trades_by_exchange_order_id or await self._get_trades_by_exchange_order_id(
             symbol=symbol, since=since, limit=limit, **kwargs
         )
         exchanges_util.apply_trades_fees(raw_order, trades_by_exchange_order_id)
         return raw_order
 
@@ -605,15 +548,15 @@
         return await self.connector.get_my_recent_trades(symbol=symbol, since=since, limit=limit, **kwargs)
 
     async def cancel_order(
             self, exchange_order_id: str, symbol: str, order_type: enums.TraderOrderType, **kwargs: dict
     ) -> enums.OrderStatus:
         return await self.connector.cancel_order(exchange_order_id, symbol, order_type, **kwargs)
 
-    def get_trade_fee(self, symbol: str, order_type: enums.TraderOrderType, quantity, price, taker_or_maker):
+    def get_trade_fee(self, symbol, order_type, quantity, price, taker_or_maker):
         return self.connector.get_trade_fee(symbol, order_type, quantity, price, taker_or_maker)
 
     def get_fees(self, symbol):
         return self.connector.get_fees(symbol)
 
     def get_pair_from_exchange(self, pair) -> str:
         return self.connector.get_pair_from_exchange(pair)
@@ -743,20 +686,18 @@
         :return: the user position list
         """
         if not self.REQUIRES_SYMBOL_FOR_EMPTY_POSITION:
             return await self.connector.get_positions(symbols=symbols, **kwargs)
         if symbols is None:
             raise NotImplementedError(f"The symbols param is required to get multiple positions at once")
         # force get_position when symbols is set as ccxt get_positions is only returning open positions
-        return list(
-            await asyncio.gather(*(
-                self.get_position(symbol, **kwargs)
-                for symbol in symbols
-            ))
-        )
+        return [
+            await self.get_position(symbol, **kwargs)
+            for symbol in symbols
+        ]
 
     async def get_mocked_empty_position(self, symbol: str, **kwargs: dict) -> dict:
         """
         Override when necessary
         Called when self.REQUIRES_MOCKED_EMPTY_POSITION is True and a fetched position is None
         :param symbol: the position symbol
         """
@@ -889,37 +830,14 @@
     def is_expirable_symbol(self, symbol):
         """
         :param symbol: the symbol
         :return: True if the symbol is related to a contract having an expiration date
         """
         return self.connector.is_expirable_symbol(symbol)
 
-    def is_skipping_empty_candles_in_ohlcv_fetch(self):
-        return self.IS_SKIPPING_EMPTY_CANDLES_IN_OHLCV_FETCH
-
-    def is_order_not_found_error(self, error: BaseException) -> bool:
-        if self.EXCHANGE_ORDER_NOT_FOUND_ERRORS:
-            return exchanges_util.is_error_on_this_type(error, self.EXCHANGE_ORDER_NOT_FOUND_ERRORS)
-        return False
-
-    def is_api_permission_error(self, error: BaseException) -> bool:
-        if self.EXCHANGE_PERMISSION_ERRORS:
-            return exchanges_util.is_error_on_this_type(error, self.EXCHANGE_PERMISSION_ERRORS)
-        return False
-
-    def is_exchange_rules_compliancy_error(self, error: BaseException) -> bool:
-        if self.EXCHANGE_COMPLIANCY_ERRORS:
-            return exchanges_util.is_error_on_this_type(error, self.EXCHANGE_COMPLIANCY_ERRORS)
-        return False
-
-    def is_exchange_account_traded_symbol_permission_error(self, error: BaseException) -> bool:
-        if self.EXCHANGE_ACCOUNT_TRADED_SYMBOL_PERMISSION_ERRORS:
-            return exchanges_util.is_error_on_this_type(error, self.EXCHANGE_ACCOUNT_TRADED_SYMBOL_PERMISSION_ERRORS)
-        return False
-
     """
     Auto fetched and filled exchanges
     """
     def _fetch_details(self, config, exchange_manager):
         raise NotImplementedError("_fetch_details is not implemented")
 
     @staticmethod
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/types/websocket_exchange.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/types/websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,73 +15,60 @@
 #  License along with this library.
 
 from octobot_trading.exchanges.util import exchange_market_status_fixer
 from octobot_trading.exchanges.util.exchange_market_status_fixer import (
     ExchangeMarketStatusFixer,
     is_ms_valid,
 )
-from octobot_trading.exchanges.util import symbol_details
-from octobot_trading.exchanges.util.symbol_details import (
-    SymbolDetails,
-)
 from octobot_trading.exchanges.util import exchange_util
 from octobot_trading.exchanges.util.exchange_util import (
     get_rest_exchange_class,
     get_order_side,
     log_time_sync_error,
     get_partners_explanation_message,
     get_enabled_exchanges,
     get_local_exchange_manager,
-    exchange_error_translator,
     is_compatible_account,
     get_historical_ohlcv,
     get_exchange_type,
     get_default_exchange_type,
     get_supported_exchange_types,
     update_raw_order_from_raw_trade,
     is_missing_trading_fees,
     apply_trades_fees,
-    get_common_traded_quote,
-    get_associated_symbol,
     get_exchange_class_from_name,
     get_auto_filled_exchange_names,
     get_exchange_details,
-    is_error_on_this_type,
 )
 from octobot_trading.exchanges.util import websockets_util
 from octobot_trading.exchanges.util.websockets_util import (
     force_disable_web_socket,
     check_web_socket_config,
     search_websocket_class,
     supports_websocket,
 )
 
 __all__ = [
     "ExchangeMarketStatusFixer",
     "is_ms_valid",
-    "SymbolDetails",
     "get_rest_exchange_class",
     "get_order_side",
     "log_time_sync_error",
     "get_partners_explanation_message",
     "get_enabled_exchanges",
     "get_local_exchange_manager",
-    "exchange_error_translator",
     "is_compatible_account",
     "get_historical_ohlcv",
     "get_exchange_type",
     "get_default_exchange_type",
     "get_supported_exchange_types",
     "update_raw_order_from_raw_trade",
     "is_missing_trading_fees",
     "apply_trades_fees",
-    "get_common_traded_quote",
-    "get_associated_symbol",
     "get_exchange_class_from_name",
     "get_auto_filled_exchange_names",
     "get_exchange_details",
-    "is_error_on_this_type",
     "force_disable_web_socket",
     "check_web_socket_config",
     "search_websocket_class",
     "supports_websocket",
 ]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/exchange_market_status_fixer.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/exchange_market_status_fixer.py`

 * *Files 2% similar despite different names*

```diff
@@ -155,15 +155,15 @@
                     self.logger.debug(f"Impossible to convert {val} to float in {key} market status. "
                                       f"Full market status: {self.market_status}")
 
     def _fix_typing(self):
         self._convert_values_to_float(
             self.market_status,
             [Ecmsc.PRECISION.value, ],
-            [Ecmsc.PRECISION_AMOUNT.value, Ecmsc.PRECISION_PRICE.value],
+            [Ecmsc.PRECISION_AMOUNT.value, Ecmsc.PRECISION_COST.value, Ecmsc.PRECISION_PRICE.value],
         )
         self._convert_values_to_float(
             self.market_status,
             [Ecmsc.LIMITS.value, Ecmsc.LIMITS_COST.value],
             [Ecmsc.LIMITS_COST_MAX.value, Ecmsc.LIMITS_COST_MIN.value],
         )
         self._convert_values_to_float(
@@ -177,23 +177,21 @@
             [Ecmsc.LIMITS_PRICE_MAX.value, Ecmsc.LIMITS_PRICE_MIN.value],
         )
 
     def _fix_market_status_precision(self):
         if Ecmsc.PRECISION.value not in self.market_status:
             self.market_status[Ecmsc.PRECISION.value] = {
                 Ecmsc.PRECISION_AMOUNT.value: None,
+                Ecmsc.PRECISION_COST.value: None,
                 Ecmsc.PRECISION_PRICE.value: None,
             }
 
         market_precision = self.market_status[Ecmsc.PRECISION.value]
 
-        if not check_market_status_values(
-            (market_precision.get(Ecmsc.PRECISION_AMOUNT.value), market_precision.get(Ecmsc.PRECISION_PRICE.value)),
-            zero_valid=True
-         ):
+        if not check_market_status_values(market_precision.values(), zero_valid=True):
             if self.price_example is not None:
                 self._fix_market_status_precision_with_price()
 
             elif self.market_status_specific:
                 self._fix_market_status_precision_with_specific()
 
     def _fix_market_status_limits(self):
@@ -275,25 +273,19 @@
         }
 
     def _get_price_precision(self):
         return -decimal.Decimal(f"{self.price_example}").as_tuple().exponent
 
     def _fix_market_status_precision_with_price(self):
         precision = self._get_price_precision()
-        # only patch value when necessary
-        if not is_ms_valid(
-            self.market_status[Ecmsc.PRECISION.value].get(Ecmsc.PRECISION_AMOUNT.value),
-            zero_valid=True
-        ):
-            self.market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value] = precision
-        if not is_ms_valid(
-            self.market_status[Ecmsc.PRECISION.value].get(Ecmsc.PRECISION_PRICE.value),
-            zero_valid=True
-        ):
-            self.market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value] = precision
+        self.market_status[Ecmsc.PRECISION.value] = {
+            Ecmsc.PRECISION_AMOUNT.value: precision,
+            Ecmsc.PRECISION_COST.value: precision,
+            Ecmsc.PRECISION_PRICE.value: precision,
+        }
 
     def _fix_market_status_precision_with_specific(self):
         # binance specific
         pass  # nothing for binance
 
     def _fix_market_status_limits_with_specific(self):
         market_limit = self.market_status[Ecmsc.LIMITS.value]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/exchange_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/exchange_util.py`

 * *Files 15% similar despite different names*

```diff
@@ -10,29 +10,25 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
-import typing
-
 import ccxt
 import trading_backend
 
 import octobot_commons.logging as logging
 import octobot_commons.constants as common_constants
 import octobot_commons.enums as common_enums
-import octobot_commons.symbols as common_symbols
 import octobot_commons.tentacles_management as tentacles_management
 
 import octobot_tentacles_manager.api as api
 
 import octobot_trading.enums as enums
-import octobot_trading.errors as errors
 import octobot_trading.constants as constants
 import octobot_trading.exchanges.types as exchanges_types
 import octobot_trading.exchanges.implementations as exchanges_implementations
 import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
 import octobot_trading.exchanges.exchange_details as exchange_details
 import octobot_trading.exchanges.exchange_builder as exchange_builder
 
@@ -153,33 +149,33 @@
 
 
 def _get_docs_url():
     try:
         import octobot.constants
         return octobot.constants.OCTOBOT_DOCS_URL
     except ImportError:
-        return "https://www.octobot.cloud/en/guides"
+        return "https://www.octobot.info"
 
 
 def _get_exchanges_docs_url():
     try:
         import octobot.constants
         return octobot.constants.EXCHANGES_DOCS_URL
     except ImportError:
-        return "https://www.octobot.cloud/en/guides/exchanges"
+        return "https://exchanges.octobot.info"
 
 
 def _get_time_sync_error_message(exchange_name, caller_name):
     return f"Time synchronization error when calling {caller_name} on {exchange_name.capitalize()}. " \
         f"To fix this, please synchronize your computer's clock. See " \
-        f"{_get_docs_url()}/octobot-installation/troubleshoot#time-synchronization"
+        f"{_get_docs_url()}/installation/installation-troubleshoot#time-synchronization"
 
 
 def get_partners_explanation_message():
-    return f"More info on partner exchanges on {_get_exchanges_docs_url()}#partner-exchanges---support-octobot"
+    return f"More info on partner exchanges on {_get_exchanges_docs_url()}#partner-exchanges-support-octobot"
 
 
 def _get_minimal_exchange_config(exchange_name, exchange_config):
     return {
         common_constants.CONFIG_EXCHANGES: {
             exchange_name: exchange_config
         },
@@ -203,125 +199,93 @@
         )
     ]
 
 
 @contextlib.asynccontextmanager
 async def get_local_exchange_manager(
     exchange_name: str, exchange_config: dict, tentacles_setup_config,
-    is_sandboxed: bool, ignore_config=False, builder=None, use_cached_markets=True,
-    is_broker_enabled: bool = False,
-    market_filter: typing.Union[None, typing.Callable[[dict], bool]] = None
+    is_sandboxed: bool, ignore_config=False, builder=None, forced_markets=None,
 ):
     exchange_type = exchange_config.get(common_constants.CONFIG_EXCHANGE_TYPE, get_default_exchange_type(exchange_name))
     builder = builder or exchange_builder.ExchangeBuilder(
         _get_minimal_exchange_config(exchange_name, exchange_config),
         exchange_name
     )
     exchange_manager = await builder.use_tentacles_setup_config(tentacles_setup_config) \
         .is_checking_credentials(False) \
         .is_sandboxed(is_sandboxed) \
         .is_using_exchange_type(exchange_type) \
         .is_exchange_only() \
         .is_rest_only() \
-        .is_broker_enabled(is_broker_enabled) \
-        .use_cached_markets(use_cached_markets) \
-        .use_market_filter(market_filter) \
+        .has_forced_markets(forced_markets or {}) \
         .is_ignoring_config(ignore_config) \
         .disable_trading_mode() \
         .build()
     try:
-        with exchange_error_translator(exchange_manager):
-            yield exchange_manager
+        yield exchange_manager
     finally:
         # do not log stopping message
         logger = exchange_manager.exchange.connector.logger
         logger.disable(True)
         builder.clear()
         await exchange_manager.stop(enable_logs=False)
         logger.disable(False)
 
 
-@contextlib.contextmanager
-def exchange_error_translator(exchange_manager):
-    try:
-        yield
-    except ccxt.ExchangeError as err:
-        # convert permission and compliancy errors while the exchange manager still exists and can be used
-        if exchange_manager.exchange.is_api_permission_error(err):
-            raise errors.AuthenticationError(f"{err} ({err.__class__})") from err
-        if exchange_manager.exchange.is_exchange_rules_compliancy_error(err):
-            raise errors.ExchangeCompliancyError(f"{err} ({err.__class__})") from err
-        # default raise
-        raise
-
-
 async def is_compatible_account(exchange_name: str, exchange_config: dict, tentacles_setup_config, is_sandboxed: bool) \
         -> (bool, bool, str):
     """
     Returns details regarding the compatibility of the account given in parameters
     :return: (True if compatible, True if successful login, error explanation if any)
     """
     async with get_local_exchange_manager(
         exchange_name, exchange_config, tentacles_setup_config, is_sandboxed, ignore_config=False
     ) as local_exchange_manager:
         backend = trading_backend.exchange_factory.create_exchange_backend(local_exchange_manager.exchange)
         try:
-            is_compatible, error = await backend.is_valid_account(always_check_key_rights=True)
+            is_compatible, error = await backend.is_valid_account()
             if not local_exchange_manager.is_spot_only:
                 message = f"Future trading on {exchange_name.capitalize()} requires a supporting account. {error}." \
                           f"Please create a new {exchange_name.capitalize()} account to use futures trading. "
                 # only ensure compatibility for non spot trading
                 return is_compatible, True, message if error else error
             else:
                 # auth didn't fail, spot trading is always allowed
                 return True, True, None
         except trading_backend.TimeSyncError:
             return False, False, _get_time_sync_error_message(exchange_name, "backend.is_valid_account")
         except trading_backend.ExchangeAuthError:
-            message = f"Invalid {exchange_name.capitalize()} authentication details"
-            if is_sandboxed:
-                message = f"{message}. Warning: exchange sandbox is enabled, " \
-                          f"this means that OctoBot is connecting to the testnet/sandbox version of " \
-                          f"{exchange_name.capitalize()} to trade and validate your api key. " \
-                          f"Disable sandbox in your accounts configuration if this is not intended."
-            return False, False, message
-        except trading_backend.APIKeyPermissionsError as err:
-            return False, False, f"Please update your API Key permissions: {err}"
+            return False, False, f"Invalid {exchange_name.capitalize()} authentication details"
         except (AttributeError, Exception) as e:
             return True, False, f"Error when loading exchange account: {e}"
 
 
 async def get_historical_ohlcv(
     local_exchange_manager, symbol, time_frame, start_time, end_time,
-    request_retry_timeout=constants.HISTORICAL_CANDLES_FETCH_DEFAULT_TIMEOUT
+        request_retry_timeout=constants.HISTORICAL_CANDLES_FETCH_DEFAULT_TIMEOUT
 ):
     """
     Async generator, use as follows:
         async for candles in get_historical_ohlcv(exchange_manager, pair, time_frame, start_time, end_time):
             # candles stuff
     WARNING: start_time and end_time are inclusive boundaries and should be milliseconds timestamps
     request_retry_timeout is a timer in seconds to keep retrying to fetch failed candle requests before giving up
     """
     reached_max = False
-    time_frame_sec = common_enums.TimeFramesMinutes[time_frame] * common_constants.MINUTE_TO_SECONDS
-    exchange_time = local_exchange_manager.exchange.get_exchange_current_time()
-    max_theoretical_time = exchange_time - exchange_time % time_frame_sec
     while start_time < end_time and not reached_max:
         candles = await local_exchange_manager.exchange.retry_till_success(
             request_retry_timeout,
             local_exchange_manager.exchange.get_symbol_prices,
             symbol, time_frame, since=int(start_time)
         )
         if candles:
             while candles and candles[-1][common_enums.PriceIndexes.IND_PRICE_TIME.value] * 1000 > end_time:
                 candles.pop(-1)
                 reached_max = True
             if candles:
-                if candles[-1][common_enums.PriceIndexes.IND_PRICE_TIME.value] >= max_theoretical_time:
-                    reached_max = True
                 yield candles
                 start_time = candles[-1][common_enums.PriceIndexes.IND_PRICE_TIME.value] * 1000
                 # avoid fetching the last element twice
                 start_time += 1
             else:
                 reached_max = True
         else:
@@ -351,44 +315,44 @@
     if exchange_class is None:
         # default
         return [enums.ExchangeTypes.SPOT]
     return exchange_class.get_supported_exchange_types()
 
 
 def update_raw_order_from_raw_trade(order_to_update, raw_trade):
-    order_to_update[enums.ExchangeConstantsOrderColumns.INFO.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.INFO.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.ORDER.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.SYMBOL.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.SYMBOL.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.TYPE.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.TYPE.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.AMOUNT.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.AMOUNT.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.DATETIME.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.DATETIME.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.SIDE.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.SIDE.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.PRICE.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.PRICE.value)
+    order_to_update[enums.ExchangeConstantsOrderColumns.INFO.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.INFO.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.ORDER.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.SYMBOL.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.SYMBOL.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.TYPE.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.TYPE.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.AMOUNT.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.AMOUNT.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.DATETIME.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.DATETIME.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.SIDE.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.SIDE.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.PRICE.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.PRICE.value]
     order_to_update[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] = order_to_update.get(
         enums.ExchangeConstantsOrderColumns.TIMESTAMP.value,
         raw_trade[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value])
     order_to_update[enums.ExchangeConstantsOrderColumns.STATUS.value] = enums.OrderStatus.FILLED.value
-    order_to_update[enums.ExchangeConstantsOrderColumns.FILLED.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.AMOUNT.value)
-    order_to_update[enums.ExchangeConstantsOrderColumns.COST.value] = raw_trade.get(
-        enums.ExchangeConstantsOrderColumns.COST.value)
+    order_to_update[enums.ExchangeConstantsOrderColumns.FILLED.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.AMOUNT.value]
+    order_to_update[enums.ExchangeConstantsOrderColumns.COST.value] = raw_trade[
+        enums.ExchangeConstantsOrderColumns.COST.value]
     order_to_update[enums.ExchangeConstantsOrderColumns.REMAINING.value] = 0
     order_to_update[
         enums.ExchangeConstantsOrderColumns.FEE.value
-    ] = raw_trade.get(enums.ExchangeConstantsOrderColumns.FEE.value)
+    ] = raw_trade[enums.ExchangeConstantsOrderColumns.FEE.value]
     return order_to_update
 
 
 def is_missing_trading_fees(raw_order):
     try:
         return (
             raw_order is not None
@@ -415,38 +379,7 @@
         for trade in raw_trades_by_exchange_order_id[exchange_order_id][1:]:
             order_fee[enums.FeePropertyColumns.COST.value] += \
                 trade[enums.ExchangeConstantsOrderColumns.FEE.value][enums.FeePropertyColumns.COST.value]
             order_fee[enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value] += \
                 trade[enums.ExchangeConstantsOrderColumns.FEE.value][
                     enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value]
         raw_order[enums.ExchangeConstantsOrderColumns.FEE.value] = order_fee
-
-
-def get_common_traded_quote(exchange_manager) -> typing.Union[str, None]:
-    quote = None
-    for symbol in exchange_manager.exchange_config.traded_symbols:
-        if quote is None:
-            quote = symbol.quote
-        elif quote != symbol.quote:
-            return None
-    return quote
-
-
-def get_associated_symbol(exchange_manager, asset: str, target_asset: str) -> (typing.Union[str, None], bool):
-    symbol = common_symbols.merge_currencies(asset, target_asset)
-    is_reversed_symbol = False
-    if symbol not in exchange_manager.client_symbols:
-        # try reversed
-        reversed_symbol = common_symbols.merge_currencies(target_asset, asset)
-        if reversed_symbol not in exchange_manager.client_symbols:
-            return None, is_reversed_symbol
-        symbol = reversed_symbol
-        is_reversed_symbol = True
-    return symbol, is_reversed_symbol
-
-
-def is_error_on_this_type(error: BaseException, descriptions: typing.List[typing.Iterable[str]]) -> bool:
-    lower_error = str(error).lower()
-    for identifiers in descriptions:
-        if all(identifier in lower_error for identifier in identifiers):
-            return True
-    return False
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/exchanges/util/websockets_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/exchanges/util/websockets_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -43,37 +43,27 @@
 
 from octobot_trading.modes import mode_config
 from octobot_trading.modes.mode_config import (
     get_activated_trading_mode,
     should_emit_trading_signals_user_input,
     is_trading_signal_emitter,
     user_select_order_amount,
-    get_order_amount_value_desc,
     get_user_selected_order_amount,
 )
 
 from octobot_trading.modes import modes_factory
 from octobot_trading.modes.modes_factory import (
     create_trading_modes,
     create_trading_mode,
     create_temporary_trading_mode_with_local_config,
 )
 
-from octobot_trading.modes import mode_activity
-from octobot_trading.modes.mode_activity import (
-    TradingModeActivity,
-)
-
 from octobot_trading.modes import modes_util
 from octobot_trading.modes.modes_util import (
     get_required_candles_count,
-    get_assets_requiring_extra_price_data_to_convert,
-    convert_assets_to_target_asset,
-    convert_asset_to_target_asset,
-    notify_portfolio_optimization_complete,
 )
 
 __all__ = [
     "ModeChannelConsumer",
     "ModeChannelProducer",
     "ModeChannel",
     "AbstractTradingModeProducer",
@@ -82,20 +72,14 @@
     "AbstractScriptedTradingMode",
     "AbstractScriptedTradingModeProducer",
     "Context",
     "check_factor",
     "create_trading_modes",
     "create_trading_mode",
     "create_temporary_trading_mode_with_local_config",
-    "TradingModeActivity",
     "get_activated_trading_mode",
     "should_emit_trading_signals_user_input",
     "is_trading_signal_emitter",
     "user_select_order_amount",
-    "get_order_amount_value_desc",
     "get_user_selected_order_amount",
     "get_required_candles_count",
-    "get_assets_requiring_extra_price_data_to_convert",
-    "convert_assets_to_target_asset",
-    "convert_asset_to_target_asset",
-    "notify_portfolio_optimization_complete",
 ]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/abstract_trading_mode.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/abstract_trading_mode.py`

 * *Files 15% similar despite different names*

```diff
@@ -32,55 +32,45 @@
 import octobot_trading.enums as enums
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.modes.modes_factory as modes_factory
 import octobot_trading.modes.channel.abstract_mode_producer as abstract_mode_producer
 import octobot_trading.modes.channel.abstract_mode_consumer as abstract_mode_consumer
 import octobot_trading.modes.mode_config as mode_config
 import octobot_trading.modes.modes_util as modes_util
-import octobot_trading.exchanges.util.exchange_util as exchange_util
 import octobot_trading.signals as signals
 
 
 class AbstractTradingMode(abstract_tentacle.AbstractTentacle):
     __metaclass__ = abc.ABCMeta
     USER_INPUT_TENTACLE_TYPE = common_enums.UserInputTentacleTypes.TRADING_MODE
     ALLOW_CUSTOM_TRIGGER_SOURCE = False
     HISTORIZE_USER_INPUT_CONFIG = True
 
     MODE_PRODUCER_CLASSES = []
     MODE_CONSUMER_CLASSES = []
     # maximum seconds before sending a trading signal if orders are slow to create on exchange
     TRADING_SIGNAL_TIMEOUT = 10
     REQUIRE_TRADES_HISTORY = False   # set True when this trading mode needs the trade history to operate
-    ALLOW_CANCEL_BEFORE_BUY_SIGNALS = True  # set False if trade signals from this trading mode should NOT be
-    # reordered to process cancel signals first
-    SUPPORTS_INITIAL_PORTFOLIO_OPTIMIZATION = False  # set True when self._optimize_initial_portfolio is implemented
-    SUPPORTS_HEALTH_CHECK = False   # set True when self.health_check is implemented
-    ENABLE_HEALTH_CHECK = "enable_health_check"
-    HEALTH_CHECK_INTERVAL = common_constants.DAYS_TO_SECONDS
 
     def __init__(self, config, exchange_manager):
         super().__init__()
         self.logger = logging.get_logger(self.get_name())
 
         # Global OctoBot configuration
         self.config: dict = config
 
         # Mode related exchange manager instance
         self.exchange_manager = exchange_manager
 
         # The id of the OctoBot using this trading mode
         self.bot_id: str = None
 
-        # Trading Mode specific config (Is loaded from tentacle specific file)
+        # Evaluator specific config (Is loaded from tentacle specific file)
         self.trading_config: dict = None
 
-        # Trading Mode specific config snapshot before a config update
-        self.previous_trading_config: dict = None
-
         # If this mode is enabled
         self.enabled: bool = True
 
         # Specified Cryptocurrency for this instance (Should be None if wildcard)
         self.cryptocurrency: str = None
 
         # Symbol is the cryptocurrency pair (Should be None if wildcard)
@@ -94,21 +84,14 @@
 
         # producers is the list of consumers created by this trading mode
         self.consumers = []
 
         # True when this trading mode is waken up only after full candles close
         self.is_triggered_after_candle_close = False
 
-        # True when initialization orders are waiting to be created
-        self.are_initialization_orders_pending = False
-
-        # When True, health check will be performed when calling trading_mode_trigger
-        self.is_health_check_enabled = False
-        self._last_health_check_time = 0
-
     # Used to know the current state of the trading mode.
     # Overwrite in subclasses
     def get_current_state(self) -> tuple:
         """
         :return: (str, float): (current state description, current state value)
         """
         return "N/A", 0
@@ -191,62 +174,54 @@
     def is_backtestable() -> bool:
         """
         Should be overwritten
         :return: True if the TradingMode can be used in a backtesting else False
         """
         return True
 
-    async def initialize(self, trading_config=None, auto_start=True) -> None:
+    async def initialize(self, trading_config=None) -> None:
         """
         Triggers producers and consumers creation
         """
         await self.reload_config(self.exchange_manager.bot_id, trading_config=trading_config)
-        self.producers = await self.create_producers(auto_start)
+        self.producers = await self.create_producers()
         self.consumers = await self.create_consumers()
 
     async def stop(self) -> None:
         """
         Stops all producers and consumers
         """
         for producer in self.producers:
             await producer.stop()
         for consumer in self.consumers:
             await consumer.stop()
         self.exchange_manager = None
 
-    async def create_producers(self, auto_start) -> list:
+    async def create_producers(self) -> list:
         """
         Creates the instance of producers listed in MODE_PRODUCER_CLASSES
         :return: the list of producers created
         """
         return [
-            await self._create_mode_producer(mode_producer_class, auto_start)
+            await self._create_mode_producer(mode_producer_class)
             for mode_producer_class in self.get_mode_producer_classes()
         ]
 
-    async def _create_mode_producer(self, mode_producer_class, auto_start):
+    async def _create_mode_producer(self, mode_producer_class):
         """
         Creates a new :mode_producer_class: instance and starts it
         :param mode_producer_class: the trading mode producer class to create
         :return: the producer class created
         """
         mode_producer = mode_producer_class(
             exchanges_channel.get_chan(constants.MODE_CHANNEL, self.exchange_manager.id),
             self.config, self, self.exchange_manager)
-        if auto_start:
-            await mode_producer.run()
+        await mode_producer.run()
         return mode_producer
 
-    async def start_producers(self):
-        """
-        Should be used if producers got created with auto_start=False
-        """
-        for producer in self.producers:
-            await producer.run()
-
     async def create_consumers(self) -> list:
         """
         Creates the instance of consumers listed in MODE_CONSUMER_CLASSES
         :return: the list of consumers created
         """
         base_consumers = [
             await self._create_mode_consumer(mode_consumer_class)
@@ -280,115 +255,23 @@
         if action == common_enums.UserCommands.RELOAD_CONFIG.value:
             await self.reload_config(bot_id)
             self.logger.debug("Reloaded configuration")
         elif action == common_enums.UserCommands.CLEAR_PLOTTING_CACHE.value:
             await modes_util.clear_plotting_cache(self)
         elif action == common_enums.UserCommands.CLEAR_SIMULATED_ORDERS_CACHE.value:
             await modes_util.clear_simulated_orders_cache(self)
-        elif action == common_enums.UserCommands.OPTIMIZE_INITIAL_PORTFOLIO.value:
-            if self.SUPPORTS_INITIAL_PORTFOLIO_OPTIMIZATION:
-                await self.optimize_initial_portfolio([], {})
-        elif action == common_enums.UserCommands.TRIGGER_HEALTH_CHECK.value:
-            if self.SUPPORTS_HEALTH_CHECK:
-                await self.health_check([], {})
 
     async def _manual_trigger(self, data):
         kwargs = {
             "trigger_source": common_enums.TriggerSource.MANUAL.value
         }
         kwargs.update(data.get("kwargs", {}))
         for producer in self.producers:
             await producer.trigger(**kwargs)
 
-    def enabled_health_check_in_config(self) -> bool:
-        try:
-            return self.trading_config.get(self.ENABLE_HEALTH_CHECK, False)
-        except AttributeError:
-            # when self.trading_config is None, should not happen
-            return False
-
-    def _health_check_interval_expired(self) -> bool:
-        return self.exchange_manager.exchange.get_exchange_current_time() - self._last_health_check_time \
-            > self.HEALTH_CHECK_INTERVAL
-
-    def is_health_check_required(self) -> bool:
-        return self.SUPPORTS_HEALTH_CHECK and self.is_health_check_enabled and self._health_check_interval_expired()
-
-    async def health_check(self, chained_orders: list, tickers: dict) -> list:
-        self._last_health_check_time = self.exchange_manager.exchange.get_exchange_current_time()
-        if not self.producers:
-            # nothing to do
-            return []
-        async with self._single_exchange_operation("health check") as continue_operation:
-            if not continue_operation:
-                return []
-            return await self.single_exchange_process_health_check(chained_orders, tickers)
-
-    async def single_exchange_process_health_check(self, chained_orders: list, tickers: dict) -> list:
-        raise NotImplementedError("single_exchange_process_health_check is not implemented")
-
-    async def optimize_initial_portfolio(self, sellable_assets: list, tickers: dict) -> list:
-        if not self.producers:
-            # nothing to do
-            return []
-        # first acquire trading mode lock to be sure we are not in during trading mode iteration
-        async with self.producers[0].trading_mode_trigger():
-            async with self._single_exchange_operation("portfolio optimization") as continue_operation:
-                if not continue_operation:
-                    return []
-                target_asset = exchange_util.get_common_traded_quote(self.exchange_manager)
-                if target_asset is None:
-                    self.logger.error(f"Impossible to optimize initial portfolio with different quotes in traded pairs")
-                    return []
-                self.logger.info(f"Starting portfolio optimization using trading mode with symbol {self.symbol}")
-                created_orders = await self.single_exchange_process_optimize_initial_portfolio(
-                    sellable_assets, target_asset, tickers
-                )
-                if not created_orders:
-                    self.logger.info("Optimizing portfolio: no order to create")
-                await modes_util.notify_portfolio_optimization_complete()
-                return created_orders
-
-    async def single_exchange_process_optimize_initial_portfolio(
-        self, sellable_assets, target_asset: str, tickers: dict
-    ) -> list:
-        raise NotImplementedError("single_exchange_process_optimize_initial_portfolio is not implemented")
-
-    @contextlib.asynccontextmanager
-    async def _single_exchange_operation(self, operation_name):
-        is_the_single_operation = not self.producers[0].producer_exchange_wide_lock(self.exchange_manager).locked()
-        if is_the_single_operation:
-            # already locked by another trading mode instance: this other trading mode will do the operation
-            self.logger.debug(
-                f"[Single exchange operation]: triggering '{operation_name}' for trading mode with symbol "
-                f"{self.symbol} [{self.exchange_manager.exchange_name}]."
-            )
-        else:
-            # already locked by another trading mode instance: this other trading mode will do the operation
-            self.logger.debug(
-                f"[Single exchange operation]: skipping '{operation_name}' for trading mode with symbol {self.symbol} "
-                f"[{self.exchange_manager.exchange_name}]: "
-                f"{operation_name} already in progress. Waiting for initial {operation_name} to complete."
-            )
-        async with self.producers[0].producer_exchange_wide_lock(self.exchange_manager):
-            yield is_the_single_operation
-
-    @classmethod
-    def get_user_commands(cls) -> dict:
-        """
-        Return the dict of user commands for this tentacle
-        :return: the commands dict
-        """
-        commands = {}
-        if cls.SUPPORTS_INITIAL_PORTFOLIO_OPTIMIZATION:
-            commands[common_enums.UserCommands.OPTIMIZE_INITIAL_PORTFOLIO.value] = {}
-        if cls.SUPPORTS_HEALTH_CHECK:
-            commands[common_enums.UserCommands.TRIGGER_HEALTH_CHECK.value] = {}
-        return commands
-
     async def _create_mode_consumer(self, mode_consumer_class):
         """
         Creates a new :mode_consumer_class: instance and subscribe this new consumer to the trading mode channel
         :param mode_consumer_class: the trading mode consumer class to create
         :return: the consumer class created
         """
         mode_consumer = mode_consumer_class(self)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/channel/abstract_mode_consumer.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/channel/abstract_mode_consumer.py`

 * *Files 26% similar despite different names*

```diff
@@ -17,88 +17,59 @@
 import asyncio
 
 import octobot_commons.symbols as symbol_util
 import octobot_commons.constants as commons_constants
 
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.modes.channel as modes_channel
-import octobot_trading.modes.mode_activity as mode_activity
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
 import octobot_trading.constants as constants
 import octobot_trading.personal_data as personal_data
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc
 
 
 class AbstractTradingModeConsumer(modes_channel.ModeChannelConsumer):
     def __init__(self, trading_mode):
         super().__init__()
         self.trading_mode = trading_mode
         self.exchange_manager = trading_mode.exchange_manager
-        self.previous_call_error_per_symbol = {}    # stores the last order creation issue for symbol
         self.on_reload_config()
 
     def on_reload_config(self):
         """
         Called at constructor and after the associated trading mode's reload_config.
         Implement if necessary
         """
 
     def flush(self):
         self.trading_mode = None
         self.exchange_manager = None
-        self.previous_call_error_per_symbol = None
 
     async def internal_callback(self, trading_mode_name, cryptocurrency, symbol, time_frame, final_note, state, data):
         # creates a new order (or multiple split orders), always check self.can_create_order() first.
         try:
             await self.create_order_if_possible(symbol, final_note, state, data=data)
-            self.previous_call_error_per_symbol[symbol] = None
-        except errors.MissingMinimalExchangeTradeVolume as err:
-            self.previous_call_error_per_symbol[symbol] = err
-            self.logger.info(self.get_minimal_funds_error(symbol, final_note))
+        except errors.MissingMinimalExchangeTradeVolume:
+            market_status = self.exchange_manager.exchange.get_market_status(symbol, price_example=None, with_fixer=False)
+            self.logger.info(f"Not enough funds to create a new {symbol} order after {final_note} evaluation: "
+                             f"{self.exchange_manager.exchange_name} exchange minimal order "
+                             f"volume has not been reached. "
+                             f"Exchanges requirements are: {market_status.get(Ecmsc.LIMITS.value)}")
         except errors.UnhandledContractError as err:
-            self.previous_call_error_per_symbol[symbol] = err
             self.logger.error(f"Unhandled contract error on {self.exchange_manager.exchange_name}: {err}. "
                               f"Please make sure that {symbol} is the full futures contract symbol. "
                               f"Future contract symbols contain the settlement currency after ':'. "
                               f"Example: use BTC/USDT:USDT for linear BTC/USDT contracts and "
                               f"BTC/USD:BTC for inverse BTC/USD contracts.")
-        except errors.OrderCreationError as err:
-            self.previous_call_error_per_symbol[symbol] = err
+        except errors.OrderCreationError:
             self.logger.info(f"Failed {symbol} order creation on: {self.exchange_manager.exchange_name} "
                              f"an unexpected error happened when creating order. This is likely due to "
                              f"the order being refused by the exchange.")
 
-    def get_minimal_funds_error(self, symbol, final_note):
-        if symbol is None:
-            return (
-                f"Not enough funds to create new orders after {final_note} evaluation: "
-                f"{self.exchange_manager.exchange_name} exchange minimal order "
-                f"volume has not been reached."
-            )
-        else:
-            market_status = self.exchange_manager.exchange.get_market_status(symbol, price_example=None, with_fixer=False)
-            try:
-                base, quote = symbol_util.parse_symbol(symbol).base_and_quote()
-                portfolio = self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio
-                funds = {
-                    base: portfolio.get_currency_portfolio(base),
-                    quote: portfolio.get_currency_portfolio(quote)
-                }
-            except Exception as err:
-                self.logger.error(f"Error when getting funds for {symbol}: {err}")
-                funds = {}
-        return (
-            f"Not enough funds to create a new {symbol} order after {final_note} evaluation: "
-            f"{self.exchange_manager.exchange_name} exchange minimal order "
-            f"volume has not been reached. Funds: {funds} "
-            f"Exchanges requirements: {market_status.get(Ecmsc.LIMITS.value)}."
-        )
-
     async def init_user_inputs(self, should_clear_inputs):
         pass
 
     async def create_new_orders(self, symbol, final_note, state, **kwargs):
         raise NotImplementedError("create_new_orders is not implemented")
 
     async def create_order_if_possible(self, symbol, final_note, state, **kwargs) -> list:
@@ -114,42 +85,32 @@
                 if await self.can_create_order(symbol, state):
                     try:
                         return await self.create_new_orders(symbol, final_note, state, **kwargs)
                     except (errors.MissingMinimalExchangeTradeVolume, errors.OrderCreationError):
                         raise
                     except errors.MissingFunds:
                         try:
-                            self.logger.debug(f"Missing funds error: force refreshing portfolio")
                             # second chance: force portfolio update and retry
                             await exchange_channel.get_chan(constants.BALANCE_CHANNEL,
                                                             self.exchange_manager.id).get_internal_producer(). \
                                 refresh_real_trader_portfolio(True)
-                            self.logger.debug(f"Forced portfolio refresh success")
-                            self.logger.debug(
-                                f"Second call to self.create_new_orders with symbol: {symbol}, final_note: "
-                                f"{final_note}, state: {state}, kwargs: {kwargs}"
-                            )
+
                             return await self.create_new_orders(symbol, final_note, state, **kwargs)
-                        except errors.MissingFunds as err:
-                            self.previous_call_error_per_symbol[symbol] = err
-                            self.logger.error(f"Failed to create order on second attempt : {err})")
-                    except Exception as err:
-                        self.previous_call_error_per_symbol[symbol] = err
-                        self.logger.exception(err, True, f"Error when creating order: {err}")
+                        except errors.MissingFunds as e:
+                            self.logger.error(f"Failed to create order on second attempt : {e})")
+                    except Exception as e:
+                        self.logger.exception(e, True, f"Error when creating order: {e}")
             self.logger.info(f"Skipping order creation for {symbol} on {self.exchange_manager.exchange_name}: "
                              f"not enough available funds")
             return []
         finally:
             self.logger.debug(f"Exiting create_order_if_possible for {symbol}")
 
     # Can be overwritten
     async def can_create_order(self, symbol, state):
-        if symbol is None:
-            # can't check
-            return True
         currency, market = symbol_util.parse_symbol(symbol).base_and_quote()
         portfolio = self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio
 
         # get symbol min amount when creating order
         symbol_limit = self.exchange_manager.exchange.get_market_status(symbol)[Ecmsc.LIMITS.value]
         symbol_min_amount = symbol_limit[Ecmsc.LIMITS_AMOUNT.value][Ecmsc.LIMITS_AMOUNT_MIN.value]
         order_min_amount = symbol_limit[Ecmsc.LIMITS_COST.value][Ecmsc.LIMITS_COST_MIN.value]
@@ -198,27 +159,22 @@
             )
             return can_create_order
 
         # other cases like neutral state or unfulfilled previous conditions
         self.logger.debug("can_create_order: return False")
         return False
 
+    def get_holdings_ratio(self, currency):
+        return self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder \
+            .get_currency_holding_ratio(currency)
+
     def get_number_of_traded_assets(self):
         return len(self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder
                    .origin_crypto_currencies_values)
 
-    def _update_producer_last_activity(self, activity_type: enums, reason):
-        for producer in self.trading_mode.producers:
-            if isinstance(producer, modes_channel.AbstractTradingModeProducer):
-                if producer.last_activity is None:
-                    producer.last_activity = mode_activity.TradingModeActivity(activity_type)
-                else:
-                    producer.last_activity.type = activity_type
-                producer.last_activity.set_reason(reason)
-
     async def wait_for_active_position(self, symbol, timeout, side=None) -> bool:
         """
         Instantly return when the position is already active.
         Wait for the given timeout if the position is not active.
         :return: Return True when the position is active
         """
         if self.exchange_manager.is_backtesting:
@@ -242,37 +198,14 @@
                 try:
                     self.logger.debug(f"Waiting for position idle to be active, position: {position}")
                     await position.state.wait_for_next_state(timeout)
                 except asyncio.TimeoutError:
                     self.logger.debug(f"Timeout while waiting for idle position to be active, position: {position}")
         return position.state.is_active()
 
-    async def register_chained_order(
-        self, main_order, price, order_type, side, quantity=None, allow_bundling=True, tag=None
-    ) -> tuple:
-        chained_order = personal_data.create_order_instance(
-            trader=self.exchange_manager.trader,
-            order_type=order_type,
-            symbol=main_order.symbol,
-            current_price=price,
-            quantity=quantity or main_order.origin_quantity,
-            price=price,
-            side=side,
-            associated_entry_id=main_order.order_id,
-            tag=tag,
-        )
-        params = {}
-        if allow_bundling:
-            params = await self.exchange_manager.trader.bundle_chained_order_with_uncreated_order(
-                main_order, chained_order, True
-            )
-        else:
-            await self.exchange_manager.trader.chain_order(main_order, chained_order, True, False)
-        return params, chained_order
-
 
 def check_factor(min_val, max_val, factor):
     """
     Checks if factor is min_val < factor < max_val
     :param min_val:
     :param max_val:
     :param factor:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/channel/abstract_mode_producer.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/channel/abstract_mode_producer.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,40 +21,36 @@
 
 import octobot_commons.channels_name as channels_name
 import octobot_commons.constants as common_constants
 import octobot_commons.enums as common_enums
 import octobot_commons.logging as logging
 import octobot_commons.databases as databases
 import octobot_commons.configuration as commons_configuration
-import octobot_commons.asyncio_tools as asyncio_tools
-
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 import octobot_trading.util as util
 import octobot_trading.exchanges.exchanges as exchanges
 import octobot_trading.exchange_channel as exchanges_channel
 import octobot_trading.modes.channel as modes_channel
 import octobot_trading.modes.script_keywords as script_keywords
-import octobot_trading.modes.mode_activity as mode_activity
 import octobot_trading.storage.util as storage_util
 
 
 class AbstractTradingModeProducer(modes_channel.ModeChannelProducer):
     TOPIC_TO_CHANNEL_NAME = {
         common_enums.ActivationTopics.FULL_CANDLES.value:
             channels_name.OctoBotTradingChannelsName.OHLCV_CHANNEL.value,
         common_enums.ActivationTopics.IN_CONSTRUCTION_CANDLES.value:
             channels_name.OctoBotTradingChannelsName.KLINE_CHANNEL.value,
         common_enums.ActivationTopics.EVALUATION_CYCLE.value:
             channels_name.OctoBotEvaluatorsChannelsName.MATRIX_CHANNEL.value,
     }
     CONFIG_INIT_TIMEOUT = 1 * common_constants.MINUTE_TO_SECONDS    # let time for orders to be fetched before
     # declaring timeout at first trigger
-    PRODUCER_LOCKS_BY_EXCHANGE_ID = {}  # use to identify exchange-wide actions
 
     def __init__(self, channel, config, trading_mode, exchange_manager):
         super().__init__(channel)
         # the trading mode instance logger
         self.logger = logging.get_logger(self.__class__.__name__)
 
         # the trading mode instance
@@ -88,20 +84,14 @@
         self.priority_level: int = channel_enums.ChannelConsumerPriorityLevels.MEDIUM.value
 
         self.symbol = None
 
         self._is_ready_to_trade = None
         self.on_reload_config()
 
-        # cleared (awaitable) when inside self.trading_mode_trigger
-        self._is_trigger_completed = asyncio.Event()
-        self._is_trigger_completed.set()
-
-        self.last_activity: mode_activity.TradingModeActivity = mode_activity.TradingModeActivity()
-
     def on_reload_config(self):
         """
         Called at constructor and after the associated trading mode's reload_config.
         Implement if necessary
         """
 
     def is_cryptocurrency_wildcard(self):
@@ -126,61 +116,47 @@
         But can overwritten (with return False) to disable wildcard trigger when get_is_time_frame_wildcard() is True
         :return: True if the mode producer should be triggered by all timeframes
         """
         return self.trading_mode.get_is_time_frame_wildcard()
 
     # noinspection PyArgumentList
     async def start(self) -> None:
-        self._is_ready_to_trade = self._is_ready_to_trade or asyncio.Event()
+        self._is_ready_to_trade = asyncio.Event()
         try:
             await self.inner_start()
         finally:
-            self.logger.debug(
-                f"Ready to trade on {self.exchange_manager.exchange_name}, symbol: {self.trading_mode.symbol}"
-            )
+            self.logger.debug("Ready to trade")
             self._is_ready_to_trade.set()
 
-    def force_is_ready_to_trade(self):
-        if self._is_ready_to_trade is None:
-            self._is_ready_to_trade = asyncio.Event()
-        self._is_ready_to_trade.set()
-
-    def unset_is_ready_to_trade(self):
-        if self._is_ready_to_trade is None:
-            self._is_ready_to_trade = asyncio.Event()
-        if self._is_ready_to_trade.is_set():
-            self._is_ready_to_trade.clear()
-
     async def inner_start(self) -> None:
         """
         Start trading mode channels subscriptions
         """
         registration_topics = self.get_channels_registration()
-        if registration_topics:
-            trigger_time_frames = self.get_trigger_time_frames()
-            currency_filter = self.trading_mode.cryptocurrency \
-                if self.trading_mode.cryptocurrency is not None and not self.is_cryptocurrency_wildcard() \
-                else common_constants.CONFIG_WILDCARD
-            symbol_filter = self.trading_mode.symbol \
-                if self.trading_mode.symbol is not None and not self.is_symbol_wildcard() \
-                else common_constants.CONFIG_WILDCARD
-            self.time_frame_filter = self.trading_mode.time_frame \
-                if self.trading_mode.time_frame is not None and self.is_time_frame_wildcard() \
-                else [tf.value
-                      for tf in self.exchange_manager.exchange_config.get_relevant_time_frames()
-                      if tf.value in trigger_time_frames or
-                      trigger_time_frames == common_constants.CONFIG_WILDCARD]
-            if trigger_time_frames != common_constants.CONFIG_WILDCARD and \
-               len(self.time_frame_filter) < len(trigger_time_frames):
-                missing_time_frames = [tf for tf in trigger_time_frames if tf not in self.time_frame_filter]
-                self.logger.error(f"Missing timeframe to satisfy {trigger_time_frames} required time frames. "
-                                  f"Please activate those timeframes {missing_time_frames}")
-            self.matrix_id = exchanges.Exchanges.instance().get_exchange(self.exchange_manager.exchange_name,
-                                                                         self.exchange_manager.id).matrix_id
-            await self._subscribe_to_registration_topic(registration_topics, currency_filter, symbol_filter)
+        trigger_time_frames = self.get_trigger_time_frames()
+        currency_filter = self.trading_mode.cryptocurrency \
+            if self.trading_mode.cryptocurrency is not None and not self.is_cryptocurrency_wildcard() \
+            else common_constants.CONFIG_WILDCARD
+        symbol_filter = self.trading_mode.symbol \
+            if self.trading_mode.symbol is not None and not self.is_symbol_wildcard() \
+            else common_constants.CONFIG_WILDCARD
+        self.time_frame_filter = self.trading_mode.time_frame \
+            if self.trading_mode.time_frame is not None and self.is_time_frame_wildcard() \
+            else [tf.value
+                  for tf in self.exchange_manager.exchange_config.get_relevant_time_frames()
+                  if tf.value in trigger_time_frames or
+                  trigger_time_frames == common_constants.CONFIG_WILDCARD]
+        if trigger_time_frames != common_constants.CONFIG_WILDCARD and \
+           len(self.time_frame_filter) < len(trigger_time_frames):
+            missing_time_frames = [tf for tf in trigger_time_frames if tf not in self.time_frame_filter]
+            self.logger.error(f"Missing timeframe to satisfy {trigger_time_frames} required time frames. "
+                              f"Please activate those timeframes {missing_time_frames}")
+        self.matrix_id = exchanges.Exchanges.instance().get_exchange(self.exchange_manager.exchange_name,
+                                                                     self.exchange_manager.id).matrix_id
+        await self._subscribe_to_registration_topic(registration_topics, currency_filter, symbol_filter)
         await self.init_user_inputs(False)
         await self._wait_for_bot_init(self.CONFIG_INIT_TIMEOUT)
 
     async def _subscribe_to_registration_topic(self, registration_topics, currency_filter, symbol_filter):
         for registration_topic in registration_topics:
             if registration_topic == channels_name.OctoBotEvaluatorsChannelsName.MATRIX_CHANNEL.value:
                 # register to matrix channel if necessary
@@ -260,15 +236,14 @@
                 except (KeyError, ImportError):
                     self.logger.error(f"Can't unregister {channel_name} channel on {self.exchange_name}")
             for consumer, channel_name in self.trading_consumers:
                 try:
                     await exchanges_channel.get_chan(channel_name, self.exchange_manager.id).remove_consumer(consumer)
                 except (KeyError, ImportError):
                     self.logger.error(f"Can't unregister {channel_name} channel on {self.exchange_name}")
-            self.delete_producer_exchange_wide_lock(self.exchange_manager)
         self.flush()
 
     def flush(self) -> None:
         """
         Flush all instance objects reference
         """
         self.trading_mode = None
@@ -314,15 +289,15 @@
         Finalize evaluation
         """
         if exchange_name != self.exchange_name or not self.exchange_manager.trader.is_enabled:
             # Do nothing if not its exchange
             return
         await self.trigger(matrix_id, cryptocurrency, symbol, time_frame, trigger_source)
 
-    async def trigger(self, matrix_id: str = None, cryptocurrency: str = None, symbol: str = None, time_frame=None,
+    async def trigger(self, matrix_id: str = None, cryptocurrency: str = None, symbol: str = None, time_frame = None,
                       trigger_source: str = common_enums.TriggerSource.UNDEFINED.value) -> None:
         """
         Called by finalize and MANUAL_TRIGGER user command. Override if necessary
         """
         try:
             async with self.trading_mode_trigger(), self.trading_mode.remote_signal_publisher(symbol):
                 await self.set_final_eval(matrix_id=matrix_id,
@@ -330,52 +305,42 @@
                                           symbol=symbol,
                                           time_frame=time_frame,
                                           trigger_source=trigger_source)
         except errors.InitializingError as e:
             self.logger.exception(
                 e,
                 True,
-                f"Ignored signal: exchange: {self.exchange_manager.exchange_name} symbol: {symbol}, "
-                f"time_frame: {time_frame}. "
+                f"Ignored signal: "
                 f"Trading mode is not yet ready to trade, OctoBot is still initializing and fetching required data."
             )
 
-    async def wait_for_trigger_completion(self, timeout):
-        if self._is_trigger_completed.is_set():
-            return
-        await asyncio.wait_for(self._is_trigger_completed.wait(), timeout=timeout)
-
     @contextlib.asynccontextmanager
-    async def trading_mode_trigger(self, skip_health_check=False):
+    async def trading_mode_trigger(self):
         try:
-            self._is_trigger_completed.clear()
             if not self._is_ready_to_trade.is_set():
                 if self.exchange_manager.is_backtesting:
                     raise asyncio.TimeoutError(f"Trading mode producer has to be started in backtesting")
                 self.logger.debug("Waiting for orders initialization to proceed")
                 try:
                     await asyncio.wait_for(self._is_ready_to_trade.wait(), self.CONFIG_INIT_TIMEOUT)
                 except asyncio.TimeoutError as e:
                     raise errors.InitializingError() from e
                 self.logger.debug("Order initialized")
-            if self.trading_mode.is_health_check_required() and not skip_health_check:
-                await self.trading_mode.health_check([], {})
             yield
         except errors.InitializingError:
             raise
         except errors.UnreachableExchange as e:
             self.logger.warning(f"Error when calling trading mode: {e}")
         except AttributeError:
             if self._is_ready_to_trade is None:
                 raise AttributeError(f"{self.__class__.__name__} has to be started. self._is_ready_to_trade is None")
             raise
         except Exception as e:
             self.logger.exception(e, True, f"Error when calling trading mode: {e}")
         finally:
-            self._is_trigger_completed.set()
             await self.post_trigger()
 
     async def post_trigger(self):
         pass
 
     async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame,
                              trigger_source: str) -> None:
@@ -400,36 +365,24 @@
     def get_should_cancel_loaded_orders(cls) -> bool:
         """
         Called by cancel_symbol_open_orders => return true if OctoBot should cancel all orders for a symbol including
         orders already existing when OctoBot started up
         """
         raise NotImplementedError("get_should_cancel_loaded_orders not implemented")
 
-    async def cancel_symbol_open_orders(self, symbol, side=None, tag=None, exchange_order_ids=None) -> bool:
+    async def cancel_symbol_open_orders(self, symbol) -> bool:
         """
-        Cancel all symbol open orders
+        Cancel all trader open orders
         """
         cancel_loaded_orders = self.get_should_cancel_loaded_orders()
-        cancelled = False
-        failed_to_cancel = False
+
         if self.exchange_manager.trader.is_enabled:
-            for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(
-                symbol=symbol, tag=tag
-            ):
-                if (
-                    not (order.is_cancelled() or order.is_closed())
-                    and (cancel_loaded_orders or order.is_from_this_octobot)
-                    and (side is None or (side is order.side))
-                    and (exchange_order_ids is None or (order.exchange_order_id in exchange_order_ids))
-                ):
-                    if await self.trading_mode.cancel_order(order):
-                        cancelled = True
-                    else:
-                        failed_to_cancel = True
-        return cancelled and not failed_to_cancel
+            return (await self.exchange_manager.trader.cancel_open_orders(
+                symbol, cancel_loaded_orders, emit_trading_signals=self.trading_mode.should_emit_trading_signal()))[0]
+        return True
 
     def all_databases(self):
         provider = databases.RunDatabasesProvider.instance()
         account_type = storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager)
         return {
             common_enums.RunDatabases.RUN_DATA_DB.value: provider.get_run_db(self.trading_mode.bot_id),
             common_enums.RunDatabases.ORDERS_DB.value:
@@ -451,20 +404,20 @@
                 await util.wait_for_topic_init(self.exchange_manager, timeout,
                                                common_enums.InitializationEventExchangeTopics.CONTRACTS.value, symbol)
             return True
         except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
             self.logger.error(f"Initialization took more than {timeout} seconds")
         return False
 
-    async def _wait_for_bot_init(self, timeout, extra_topics: list=None) -> bool:
+    async def _wait_for_bot_init(self, timeout) -> bool:
         try:
             topics = [
                 common_enums.InitializationEventExchangeTopics.BALANCE.value,
                 common_enums.InitializationEventExchangeTopics.ORDERS.value
-            ] + (extra_topics if extra_topics else [])
+            ]
             if self.trading_mode.REQUIRE_TRADES_HISTORY:
                 topics.append(common_enums.InitializationEventExchangeTopics.TRADES.value)
             for topic in topics:
                 self.logger.debug(f"Trading mode [{self.exchange_manager.exchange_name}] start complete. "
                                   f"Now waiting for {topic} full initialisation.")
                 await util.wait_for_topic_init(self.exchange_manager, timeout, topic)
             self.logger.debug(
@@ -506,33 +459,7 @@
     async def _apply_exchange_side_config(self, context):
         # can be slow, call in a task if necessary
         if context.exchange_manager.is_future:
             if not self._is_ready_to_trade.is_set():
                 await util.wait_for_topic_init(self.exchange_manager, self.CONFIG_INIT_TIMEOUT,
                                                common_enums.InitializationEventExchangeTopics.CONTRACTS.value)
             await script_keywords.set_leverage(context, await script_keywords.user_select_leverage(context))
-
-    async def _wait_for_symbol_prices_and_profitability_init(self, timeout) -> bool:
-        try:
-            await util.wait_for_topic_init(self.exchange_manager, timeout,
-                                           common_enums.InitializationEventExchangeTopics.PRICE.value)
-            await util.wait_for_topic_init(self.exchange_manager, timeout,
-                                           common_enums.InitializationEventExchangeTopics.PROFITABILITY.value)
-        except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
-            self.logger.error(f"Symbol price initialization took more than {timeout} seconds")
-        return False
-
-    @classmethod
-    def producer_exchange_wide_lock(cls, exchange_manager) -> asyncio_tools.RLock():
-        try:
-            return cls.PRODUCER_LOCKS_BY_EXCHANGE_ID[exchange_manager.id]
-        except KeyError:
-            lock = asyncio_tools.RLock()
-            cls.PRODUCER_LOCKS_BY_EXCHANGE_ID[exchange_manager.id] = lock
-            return lock
-
-    @classmethod
-    def delete_producer_exchange_wide_lock(cls, exchange_manager):
-        if exchange_manager.id in cls.PRODUCER_LOCKS_BY_EXCHANGE_ID:
-            cls.PRODUCER_LOCKS_BY_EXCHANGE_ID.pop(
-                exchange_manager.id, None
-            )
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/channel/mode.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/channel/mode.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/mode_activity.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,21 +8,16 @@
 #
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
-#  License along with this library
-import dataclasses
-import enum
-import octobot_trading.enums
-import octobot_trading.constants
+#  License along with this library.
+import octobot_trading.enums as enums
+import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
 
 
-@dataclasses.dataclass
-class TradingModeActivity:
-    type: enum.Enum = octobot_trading.enums.TradingModeActivityType.NO_ACTIVITY
-    details: dict = dataclasses.field(default_factory=dict)
+class SellLimitOrder(limit_order.LimitOrder):
+    def __init__(self, trader, side=enums.TradeOrderSide.SELL):
+        super().__init__(trader, side)
 
-    def set_reason(self, reason):
-        self.details = {octobot_trading.constants.TRADING_MODE_ACTIVITY_REASON: reason}
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/mode_config.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/mode_config.py`

 * *Files 8% similar despite different names*

```diff
@@ -82,47 +82,38 @@
     try:
         return trading_mode.trading_config[common_constants.CONFIG_EMIT_TRADING_SIGNALS]
     except KeyError:
         return False
 
 
 def _get_order_amount_title(side):
-    return f"Amount per {side} order. {get_order_amount_value_desc()}"
-
-
-def get_order_amount_value_desc():
-    return "To specify the amount per order, " \
+    return f"Amount per {side} order. To specify the amount per order, " \
         f"use the following syntax: " \
         f"0.1 to trade 0.1 BTC on BTC/USD (amount in base currency); " \
         f"25q to trade 25 USD worth of BTC on BTC/USD (amount in quote currency); " \
         f"2{dsl.QuantityType.PERCENT.value} to trade 2% of the total holdings of the asset; " \
-        f"12{dsl.QuantityType.AVAILABLE_PERCENT.value} to trade 12% of the available holdings; " \
-        f"5{dsl.QuantityType.CURRENT_SYMBOL_ASSETS_PERCENT.value} to trade 5% of the available " \
-           f"holdings associated to the current traded symbol; " \
-        f"5{dsl.QuantityType.TRADED_SYMBOLS_ASSETS_PERCENT.value} to trade 5% of the available " \
-           f"holdings associated to all configured trading pairs. " \
-        f"Leave empty to auto-compute the amount. Checkout the order amounts syntax from trading modes guides " \
-        f"for more details."
+        f"12{dsl.QuantityType.AVAILABLE_PERCENT.value} to trade 12% of the available holdings. " \
+        f"Leave empty to auto-compute the amount."
 
 
 def user_select_order_amount(trading_mode, inputs: dict, include_buy=True, include_sell=True,
                              buy_dependencies=None, sell_dependencies=None):
     if include_buy:
         trading_mode.UI.user_input(
             constants.CONFIG_BUY_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
-            title=_get_order_amount_title("buy/entry"),
+            title=_get_order_amount_title("buy"),
             other_schema_values={"minLength": 0},
             editor_options={
                 common_enums.UserInputOtherSchemaValuesTypes.DEPENDENCIES.value: buy_dependencies
             } if buy_dependencies else None,
         )
     if include_sell:
         trading_mode.UI.user_input(
             constants.CONFIG_SELL_ORDER_AMOUNT, common_enums.UserInputTypes.TEXT, "", inputs,
-            title=_get_order_amount_title("sell/exit"),
+            title=_get_order_amount_title("sell"),
             other_schema_values={"minLength": 0},
             editor_options={
                 common_enums.UserInputOtherSchemaValuesTypes.DEPENDENCIES.value: sell_dependencies
             } if sell_dependencies else None,
         )
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/modes_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/modes_factory.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,29 +22,27 @@
 
 
 async def create_trading_modes(
     config: dict,
     exchange_manager,
     trading_mode_class,
     bot_id: str,
-    trading_config_by_trading_mode: dict = None,
-    auto_start: bool = True,
+    trading_config_by_trading_mode: dict = None
 ) -> list:
     is_symbol_wildcard = trading_mode_class.get_is_symbol_wildcard()
     if is_symbol_wildcard or (not is_symbol_wildcard and exchange_manager.exchange_config.traded_symbol_pairs):
         return await _create_trading_modes(
             trading_mode_class=trading_mode_class,
             config=config,
             exchange_manager=exchange_manager,
             cryptocurrencies=exchange_manager.exchange_config.traded_cryptocurrencies,
             symbols=exchange_manager.exchange_config.traded_symbol_pairs,
             time_frames=exchange_manager.exchange_config.traded_time_frames,
             bot_id=bot_id,
-            trading_config_by_trading_mode=trading_config_by_trading_mode,
-            auto_start=auto_start,
+            trading_config_by_trading_mode=trading_config_by_trading_mode
         )
     # Do not create no symbol wildcard trading mode if no trading pair is available
     raise errors.TradingModeIncompatibility(
         f"As non symbol-wildcard trading mode, {trading_mode_class.get_name()} requires "
         f"at least one exchange trading pair to be initialized. "
         f"None of the required pairs are available on {exchange_manager.exchange_name}.")
 
@@ -53,29 +51,27 @@
     trading_mode_class,
     config: dict,
     exchange_manager,
     cryptocurrencies: dict = None,
     symbols: list = None,
     time_frames: list = None,
     bot_id: str = None,
-    trading_config_by_trading_mode: dict = None,
-    auto_start: bool = True
+    trading_config_by_trading_mode: dict = None
 ) -> list:
     trading_config_by_trading_mode = trading_config_by_trading_mode or {}
     return [
         await create_trading_mode(
             trading_mode_class=trading_mode_class,
             config=config,
             exchange_manager=exchange_manager,
             cryptocurrency=cryptocurrency,
             symbol=symbol,
             time_frame=time_frame,
             bot_id=bot_id,
-            trading_config=trading_config_by_trading_mode.get(trading_mode_class.get_name()),
-            auto_start=auto_start,
+            trading_config=trading_config_by_trading_mode.get(trading_mode_class.get_name())
         )
         for cryptocurrency in _get_cryptocurrencies_to_create(trading_mode_class, cryptocurrencies)
         for symbol in _get_symbols_to_create(trading_mode_class, cryptocurrencies, cryptocurrency, symbols)
         for time_frame in _get_time_frames_to_create(trading_mode_class, time_frames)
     ]
 
 
@@ -83,26 +79,25 @@
     trading_mode_class,
     config: dict,
     exchange_manager,
     cryptocurrency: str = None,
     symbol: str = None,
     time_frame: object = None,
     bot_id: str = None,
-    trading_config: dict = None,
-    auto_start: bool = True,
+    trading_config: dict = None
 ):
     try:
         trading_mode = trading_mode_class(config, exchange_manager)
         trading_mode.cryptocurrency = cryptocurrency
         trading_mode.symbol = symbol
         trading_mode.time_frame = time_frame
         trading_mode.bot_id = bot_id
-        await trading_mode.initialize(trading_config=trading_config, auto_start=auto_start)
+        await trading_mode.initialize(trading_config=trading_config)
         logging.get_logger(f"{LOGGER_TAG}[{exchange_manager.exchange_name}]") \
-            .debug(f"{trading_mode.get_name()} {'started' if auto_start else 'created'} for "
+            .debug(f"{trading_mode.get_name()} started for "
                    f"[cryptocurrency={cryptocurrency if cryptocurrency else constants.CONFIG_WILDCARD},"
                    f" symbol={symbol if symbol else constants.CONFIG_WILDCARD},"
                    f" time_frame={time_frame if time_frame else constants.CONFIG_WILDCARD}]")
         return trading_mode
     except RuntimeError as e:
         logging.get_logger(LOGGER_TAG).error(e.args[0])
         raise e
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -31,18 +31,14 @@
     user_select_leverage,
     user_select_emit_trading_signals,
     is_emitting_trading_signals,
     emit_trading_signals,
     set_leverage,
     set_partial_take_profit_stop_loss,
     get_amount_from_input_amount,
-    get_price_with_offset,
-    get_position,
-    average_open_pos_entry,
-    is_in_one_way_position_mode,
     total_account_balance,
     available_account_balance,
     adapt_amount_to_holdings,
     account_holdings,
     get_order_size_portfolio_percent,
     set_plot_orders,
 )
@@ -67,18 +63,14 @@
     "user_select_leverage",
     "user_select_emit_trading_signals",
     "is_emitting_trading_signals",
     "emit_trading_signals",
     "set_leverage",
     "set_partial_take_profit_stop_loss",
     "get_amount_from_input_amount",
-    "get_price_with_offset",
-    "get_position",
-    "average_open_pos_entry",
-    "is_in_one_way_position_mode",
     "total_account_balance",
     "available_account_balance",
     "adapt_amount_to_holdings",
     "account_holdings",
     "get_order_size_portfolio_percent",
     "set_plot_orders",
     "get_base_context",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -32,24 +32,14 @@
     set_partial_take_profit_stop_loss,
 )
 
 from octobot_trading.modes.script_keywords.basic_keywords.amount import (
     get_amount_from_input_amount,
 )
 
-from octobot_trading.modes.script_keywords.basic_keywords.price import (
-    get_price_with_offset,
-)
-
-from octobot_trading.modes.script_keywords.basic_keywords.position import (
-    get_position,
-    average_open_pos_entry,
-    is_in_one_way_position_mode,
-)
-
 from octobot_trading.modes.script_keywords.basic_keywords.account_balance import (
     total_account_balance,
     available_account_balance,
     adapt_amount_to_holdings,
     account_holdings,
     get_order_size_portfolio_percent,
 )
@@ -77,18 +67,14 @@
     "user_select_leverage",
     "user_select_emit_trading_signals",
     "is_emitting_trading_signals",
     "emit_trading_signals",
     "set_leverage",
     "set_partial_take_profit_stop_loss",
     "get_amount_from_input_amount",
-    "get_price_with_offset",
-    "get_position",
-    "average_open_pos_entry",
-    "is_in_one_way_position_mode",
     "total_account_balance",
     "available_account_balance",
     "adapt_amount_to_holdings",
     "account_holdings",
     "get_order_size_portfolio_percent",
     "disable_candles_plot",
     "set_plot_orders",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/account_balance.py`

 * *Files 22% similar despite different names*

```diff
@@ -45,18 +45,16 @@
         return value if on_inverse_contract else value / current_price
     if reference_market == base:
         return value * current_price if on_inverse_contract else value
     raise NotImplementedError(f"Impossible to compute total account balance for a symbol that doesn't contain "
                               f"the reference market. reference market: {reference_market}, symbol: {context.symbol}")
 
 
-async def available_account_balance(
-    context, side=trading_enums.TradeOrderSide.BUY.value, use_total_holding=False,
-    is_stop_order=False, reduce_only=True, target_price=None, orders_to_be_ignored=None
-):
+async def available_account_balance(context, side=trading_enums.TradeOrderSide.BUY.value, use_total_holding=False,
+                                    is_stop_order=False, reduce_only=True, target_price=None):
     portfolio_type = commons_constants.PORTFOLIO_TOTAL if use_total_holding else commons_constants.PORTFOLIO_AVAILABLE
     current_symbol_holding, _, market_quantity, price, _ = \
         await trading_personal_data.get_pre_order_data(context.exchange_manager,
                                                        symbol=context.symbol,
                                                        timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
                                                        portfolio_type=portfolio_type,
                                                        target_price=target_price)
@@ -65,50 +63,32 @@
             context.exchange_manager, context.symbol, trading_enums.TradeOrderSide(side), price, reduce_only,
             current_symbol_holding, market_quantity
         )
         return max_order_size
     already_locked_amount = trading_constants.ZERO
     if use_total_holding and is_stop_order:
         already_locked_amount = _get_locked_amount_in_stop_orders(context, side)
-    if orders_to_be_ignored:
-        for order_to_be_ignored in orders_to_be_ignored:
-            if order_to_be_ignored.side == trading_enums.TradeOrderSide.BUY:
-                market_quantity += order_to_be_ignored.origin_quantity
-            else:
-                current_symbol_holding += order_to_be_ignored.origin_quantity
-        total_symbol_holding, _, total_market_quantity, _, _ = \
-            await trading_personal_data.get_pre_order_data(context.exchange_manager,
-                                                           symbol=context.symbol,
-                                                           timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
-                                                           portfolio_type=commons_constants.PORTFOLIO_TOTAL,
-                                                           target_price=target_price)
-        # ensure not using more than total amounts
-        current_symbol_holding = min(current_symbol_holding, total_symbol_holding)
-        market_quantity = min(market_quantity, total_market_quantity)
     return (market_quantity if side == trading_enums.TradeOrderSide.BUY.value else current_symbol_holding) \
         - already_locked_amount
 
 
 def _get_locked_amount_in_stop_orders(context, side):
     locked_amount = trading_constants.ZERO
     for order in context.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(context.symbol):
         if isinstance(order, (trading_personal_data.StopLossOrder, trading_personal_data.StopLossLimitOrder)) and \
            order.side.value == side:
             locked_amount += order.origin_quantity
     return locked_amount
 
 
-async def adapt_amount_to_holdings(
-    context, amount, side, use_total_holding, reduce_only,
-    is_stop_order, target_price=None, orders_to_be_ignored=None
-):
-    available_acc_bal = await available_account_balance(
-        context, side, use_total_holding=use_total_holding, is_stop_order=is_stop_order,
-        reduce_only=reduce_only, target_price=target_price, orders_to_be_ignored=orders_to_be_ignored
-    )
+async def adapt_amount_to_holdings(context, amount, side, use_total_holding, reduce_only,
+                                   is_stop_order, target_price=None):
+    available_acc_bal = await available_account_balance(context, side, use_total_holding=use_total_holding,
+                                                        is_stop_order=is_stop_order, reduce_only=reduce_only,
+                                                        target_price=target_price)
     if available_acc_bal > amount:
         return amount
     else:
         return available_acc_bal
 
 
 def account_holdings(context, currency):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/configuration.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/configuration.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/run_persistence.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/trading_signals.py` & `OctoBot-Trading-2.4.9/tests/api/test_modes.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,17 +10,11 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
+import pytest
 
-def is_emitting_trading_signals(ctx):
-    return ctx.is_trading_signal_emitter()
-
-
-async def emit_trading_signals(ctx):
-    try:
-        return await ctx.emit_signal()
-    except Exception as e:
-        ctx.logger.exception(e, True, f"Error when emitting trading signal: {e}")
+# All test coroutines will be treated as marked.
+pytestmark = pytest.mark.asyncio
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/basic_keywords/user_inputs.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/context_management.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/context_management.py`

 * *Files 1% similar despite different names*

```diff
@@ -41,17 +41,18 @@
 def get_full_context(trading_mode, matrix_id, cryptocurrency, symbol, time_frame, trigger_source, trigger_cache_timestamp,
                      candle, kline, init_call=False):
     context = Context(
         trading_mode,
         trading_mode.exchange_manager,
         trading_mode.exchange_manager.trader,
         trading_mode.exchange_manager.exchange_name,
-        symbol or trading_mode.symbol,
+        trading_mode.symbol,
         matrix_id,
         cryptocurrency,
+        symbol or trading_mode.symbol,
         time_frame,
         trading_mode.logger,
         trading_mode.__class__,
         trigger_cache_timestamp,
         trigger_source,
         candle or kline,
         None,
@@ -67,14 +68,15 @@
         tentacle,
         exchange_manager,
         trader,
         exchange_name,
         traded_pair,
         matrix_id,
         cryptocurrency,
+        signal_symbol,
         time_frame,
         logger,
         trading_mode_class,
         trigger_cache_timestamp,
         trigger_source,
         trigger_value,
         backtesting_id,
@@ -92,14 +94,15 @@
             not exchange_manager.is_backtesting if exchange_manager else False
         )
         self.backtesting_analysis_settings = backtesting_analysis_settings
         self.exchange_manager = exchange_manager
         self.trader = trader
         self.matrix_id = matrix_id
         self.cryptocurrency = cryptocurrency
+        self.signal_symbol = signal_symbol
         self.logger = logger
         bot_id = exchange_manager.bot_id if \
             (exchange_manager is not None) \
             and (exchange_manager.bot_id is not None) \
             and databases.RunDatabasesProvider.instance().is_storage_enabled(
                 exchange_manager.bot_id
             ) else None
@@ -225,14 +228,15 @@
             None,
             None,
             exchange_name,
             traded_pair,
             None,
             None,
             None,
+            None,
             logger,
             trading_mode_class,
             None,
             None,
             None,
             backtesting_id,
             optimizer_id,
@@ -246,14 +250,15 @@
             tentacle,
             self.exchange_manager,
             self.trader,
             self.exchange_name,
             self.symbol,
             self.matrix_id,
             self.cryptocurrency,
+            self.signal_symbol,
             self.time_frame,
             self.logger,
             self.trading_mode_class,
             self.trigger_cache_timestamp,
             self.trigger_source,
             self.trigger_value,
             self.backtesting_id,
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/quantity.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/quantity.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/script_keywords/dsl/values.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/script_keywords/dsl/values.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,26 +15,22 @@
 #  License along with this library.
 
 import enum
 
 
 class QuantityType(enum.Enum):
     DELTA = ""
-    DELTA_EXPLICIT = "d"
     DELTA_QUOTE = "q"
-    DELTA_BASE = "b"
     PERCENT = "%"
     AVAILABLE = "a"
     POSITION = "p"
     ENTRY = "e"
     AVAILABLE_PERCENT = "a%"
     POSITION_PERCENT = "p%"
     ENTRY_PERCENT = "e%"
-    CURRENT_SYMBOL_ASSETS_PERCENT = "s%"
-    TRADED_SYMBOLS_ASSETS_PERCENT = "t%"
     FLAT = "@"
     UNKNOWN = "?"
 
     @staticmethod
     def parse(value):
         try:
             # try reading directly as enum
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/scripted_trading_mode/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/scripted_trading_mode/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py` & `OctoBot-Trading-2.4.9/octobot_trading/modes/scripted_trading_mode/abstract_scripted_trading_mode.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/octobot_channel_consumer.py` & `OctoBot-Trading-2.4.9/octobot_trading/octobot_channel_consumer.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,62 +23,56 @@
 from octobot_trading.personal_data import orders
 from octobot_trading.personal_data.orders import (
     Order,
     parse_order_type,
     is_valid,
     get_min_max_amounts,
     check_cost,
-    get_split_orders_count_and_increment,
     get_futures_max_order_size,
     get_max_order_quantity_for_price,
     total_fees_from_order_dict,
-    get_locked_funds,
     get_fees_for_currency,
     parse_raw_fees,
     parse_order_status,
     parse_is_cancelled,
     parse_is_open,
     get_pnl_transaction_source_from_order,
     is_stop_order,
     is_take_profit_order,
     get_trade_order_type,
     create_as_chained_order,
     ensure_orders_relevancy,
     get_order_quantity_currency,
     get_order_size_portfolio_percent,
     generate_order_id,
-    wait_for_order_fill,
     apply_order_storage_details_if_any,
     create_orders_storage_related_elements,
     create_missing_self_managed_orders_from_storage_order_groups,
     is_associated_pending_order,
     apply_pending_order_from_created_order,
     get_up_to_date_price,
     get_pre_order_data,
-    get_portfolio_amounts,
     OrderState,
     OrderGroup,
     BalancedTakeProfitAndStopOrderGroup,
     OneCancelsTheOtherOrderGroup,
     get_group_class,
     get_or_create_order_group_from_storage_order_details,
     OrdersUpdater,
     adapt_price,
     get_minimal_order_amount,
-    get_minimal_order_cost,
     decimal_adapt_price,
     adapt_quantity,
     decimal_adapt_quantity,
     trunc_with_n_decimal_digits,
     decimal_trunc_with_n_decimal_digits,
     adapt_order_quantity_because_quantity,
     decimal_adapt_order_quantity_because_quantity,
     adapt_order_quantity_because_price,
     decimal_adapt_order_quantity_because_price,
-    decimal_adapt_order_quantity_because_fees,
     split_orders,
     decimal_split_orders,
     check_and_adapt_order_details_if_necessary,
     decimal_check_and_adapt_order_details_if_necessary,
     add_dusts_to_quantity_if_necessary,
     decimal_add_dusts_to_quantity_if_necessary,
     create_order_from_raw,
@@ -140,15 +134,14 @@
     parse_decimal_portfolio,
     parse_decimal_config_portfolio,
     filter_empty_values,
     portfolio_to_float,
     create_historical_asset_value_from_dict_like_object,
     get_draw_down,
     get_coefficient_of_determination,
-    get_asset_price_from_converter_or_tickers,
     HistoricalAssetValue,
     HistoricalPortfolioValueManager,
 )
 from octobot_trading.personal_data import positions
 from octobot_trading.personal_data.positions import (
     PositionState,
     PositionsProducer,
@@ -171,20 +164,20 @@
 from octobot_trading.personal_data import trades
 from octobot_trading.personal_data.trades import (
     TradesManager,
     TradesProducer,
     TradesChannel,
     create_trade_instance_from_raw,
     create_trade_from_order,
+    create_trade_instance,
     create_trade_from_dict,
     TradesUpdater,
     Trade,
     TradePnl,
     compute_win_rate,
-    aggregate_trades_by_exchange_order_id,
 )
 from octobot_trading.personal_data import transactions
 from octobot_trading.personal_data.transactions import (
     TransactionsManager,
     Transaction,
     BlockchainTransaction,
     FeeTransaction,
@@ -238,62 +231,56 @@
 __all__ = [
     "State",
     "Order",
     "parse_order_type",
     "is_valid",
     "get_min_max_amounts",
     "check_cost",
-    "get_split_orders_count_and_increment",
     "get_futures_max_order_size",
     "get_max_order_quantity_for_price",
     "total_fees_from_order_dict",
-    "get_locked_funds",
     "get_fees_for_currency",
     "parse_raw_fees",
     "parse_order_status",
     "parse_is_cancelled",
     "parse_is_open",
     "get_pnl_transaction_source_from_order",
     "is_stop_order",
     "is_take_profit_order",
     "get_trade_order_type",
     "create_as_chained_order",
     "ensure_orders_relevancy",
     "get_order_quantity_currency",
     "get_order_size_portfolio_percent",
     "generate_order_id",
-    "wait_for_order_fill",
     "apply_order_storage_details_if_any",
     "create_orders_storage_related_elements",
     "create_missing_self_managed_orders_from_storage_order_groups",
     "is_associated_pending_order",
     "apply_pending_order_from_created_order",
     "get_up_to_date_price",
     "get_pre_order_data",
-    "get_portfolio_amounts",
     "OrderState",
     "OrderGroup",
     "BalancedTakeProfitAndStopOrderGroup",
     "OneCancelsTheOtherOrderGroup",
     "get_group_class",
     "get_or_create_order_group_from_storage_order_details",
     "OrdersUpdater",
     "adapt_price",
     "get_minimal_order_amount",
-    "get_minimal_order_cost",
     "decimal_adapt_price",
     "adapt_quantity",
     "decimal_adapt_quantity",
     "trunc_with_n_decimal_digits",
     "decimal_trunc_with_n_decimal_digits",
     "adapt_order_quantity_because_quantity",
     "decimal_adapt_order_quantity_because_quantity",
     "adapt_order_quantity_because_price",
     "decimal_adapt_order_quantity_because_price",
-    "decimal_adapt_order_quantity_because_fees",
     "split_orders",
     "decimal_split_orders",
     "check_and_adapt_order_details_if_necessary",
     "decimal_check_and_adapt_order_details_if_necessary",
     "add_dusts_to_quantity_if_necessary",
     "decimal_add_dusts_to_quantity_if_necessary",
     "create_order_from_raw",
@@ -376,22 +363,21 @@
     "create_symbol_position",
     "parse_position_status",
     "TradesManager",
     "TradesProducer",
     "TradesChannel",
     "create_trade_instance_from_raw",
     "create_trade_from_order",
+    "create_trade_instance",
     "create_trade_from_dict",
     "TradesUpdater",
     "Trade",
     "TradePnl",
     "compute_win_rate",
-    "aggregate_trades_by_exchange_order_id",
     "ExchangePersonalData",
-    "get_asset_price_from_converter_or_tickers",
     "AUTHENTICATED_UPDATER_PRODUCERS",
     "AUTHENTICATED_UPDATER_SIMULATOR_PRODUCERS",
     "TraderOrderTypeClasses",
     "TraderPositionTypeClasses",
     "TransactionsManager",
     "Transaction",
     "BlockchainTransaction",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/exchange_personal_data.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/exchange_personal_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -73,39 +73,35 @@
     OrdersManager,
 )
 from octobot_trading.personal_data.orders import order_util
 from octobot_trading.personal_data.orders.order_util import (
     is_valid,
     get_min_max_amounts,
     check_cost,
-    get_split_orders_count_and_increment,
     get_futures_max_order_size,
     get_max_order_quantity_for_price,
-    get_locked_funds,
     total_fees_from_order_dict,
     get_fees_for_currency,
     parse_raw_fees,
     parse_order_status,
     parse_is_cancelled,
     parse_is_open,
     get_up_to_date_price,
     get_pre_order_data,
-    get_portfolio_amounts,
     get_pnl_transaction_source_from_order,
     is_stop_order,
     is_take_profit_order,
     get_trade_order_type,
     create_as_chained_order,
     is_associated_pending_order,
     apply_pending_order_from_created_order,
     ensure_orders_relevancy,
     get_order_quantity_currency,
     get_order_size_portfolio_percent,
     generate_order_id,
-    wait_for_order_fill,
 )
 from octobot_trading.personal_data.orders import orders_storage_operations
 from octobot_trading.personal_data.orders.orders_storage_operations import (
     apply_order_storage_details_if_any,
     create_orders_storage_related_elements,
     create_missing_self_managed_orders_from_storage_order_groups,
 )
@@ -118,21 +114,19 @@
     adapt_order_quantity_because_price,
     split_orders,
     check_and_adapt_order_details_if_necessary,
     add_dusts_to_quantity_if_necessary,
 )
 from octobot_trading.personal_data.orders.decimal_order_adapter import (
     get_minimal_order_amount,
-    get_minimal_order_cost,
     decimal_adapt_price,
     decimal_adapt_quantity,
     decimal_trunc_with_n_decimal_digits,
     decimal_adapt_order_quantity_because_quantity,
     decimal_adapt_order_quantity_because_price,
-    decimal_adapt_order_quantity_because_fees,
     decimal_split_orders,
     decimal_check_and_adapt_order_details_if_necessary,
     decimal_add_dusts_to_quantity_if_necessary,
 )
 from octobot_trading.personal_data.orders import order_factory
 from octobot_trading.personal_data.orders.order_factory import (
     create_order_from_raw,
@@ -145,58 +139,52 @@
 
 __all__ = [
     "Order",
     "parse_order_type",
     "is_valid",
     "get_min_max_amounts",
     "check_cost",
-    "get_split_orders_count_and_increment",
     "get_futures_max_order_size",
     "get_max_order_quantity_for_price",
-    "get_locked_funds",
     "total_fees_from_order_dict",
     "get_fees_for_currency",
     "parse_raw_fees",
     "parse_order_status",
     "parse_is_cancelled",
     "parse_is_open",
     "get_up_to_date_price",
     "get_pre_order_data",
-    "get_portfolio_amounts",
     "get_pnl_transaction_source_from_order",
     "create_as_chained_order",
     "ensure_orders_relevancy",
     "get_order_quantity_currency",
     "get_order_size_portfolio_percent",
     "generate_order_id",
-    "wait_for_order_fill",
     "apply_order_storage_details_if_any",
     "create_missing_self_managed_orders_from_storage_order_groups",
     "is_associated_pending_order",
     "apply_pending_order_from_created_order",
     "OrderState",
     "OrderGroup",
     "BalancedTakeProfitAndStopOrderGroup",
     "OneCancelsTheOtherOrderGroup",
     "get_group_class",
     "get_or_create_order_group_from_storage_order_details",
     "OrdersUpdater",
     "adapt_price",
     "get_minimal_order_amount",
-    "get_minimal_order_cost",
     "decimal_adapt_price",
     "adapt_quantity",
     "decimal_adapt_quantity",
     "trunc_with_n_decimal_digits",
     "decimal_trunc_with_n_decimal_digits",
     "adapt_order_quantity_because_quantity",
     "decimal_adapt_order_quantity_because_quantity",
     "adapt_order_quantity_because_price",
     "decimal_adapt_order_quantity_because_price",
-    "decimal_adapt_order_quantity_because_fees",
     "split_orders",
     "decimal_split_orders",
     "check_and_adapt_order_details_if_necessary",
     "decimal_check_and_adapt_order_details_if_necessary",
     "add_dusts_to_quantity_if_necessary",
     "decimal_add_dusts_to_quantity_if_necessary",
     "create_order_from_raw",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,34 +25,26 @@
 
 class OrdersProducer(exchanges_channel.ExchangeChannelProducer):
     async def push(self, orders, is_from_bot=False, are_closed=False):
         await self.perform(orders, is_from_bot=is_from_bot, are_closed=are_closed)
 
     async def perform(self, orders, is_from_bot=False, are_closed=False):
         try:
-            self.logger.debug(f"Received order update for {len(orders)} {'closed' if are_closed else ''} orders.")
+            self.logger.debug(f"Received order update for {len(orders)} orders.")
             has_new_order = False
             waiting_complete_init_orders = []
             symbols = set()
             pending_groups = {}  # Used when restoring orders from order storage:
             # a dict of order groups for which to check if associated self-managed orders are to be created
             for order in orders:
-                exchange_order_id: str = self.channel.exchange_manager.exchange.parse_exhange_order_id(order)
                 symbol = self.channel.exchange_manager.get_exchange_symbol(
                     self.channel.exchange_manager.exchange.parse_order_symbol(order)
                 )
-                if self.channel.exchange_manager.exchange.is_creating_order(exchange_order_id):
-                    # ignore orders that are being created
-                    self.logger.debug(
-                        f"Ignored update from order channel for {symbol} order with exchange order id "
-                        f"{exchange_order_id} as "
-                        f"this order is being created and will automatically be updated once creation is complete."
-                    )
-                    continue
                 symbols.add(symbol)
+                exchange_order_id: str = self.channel.exchange_manager.exchange.parse_exhange_order_id(order)
 
                 # if this order was not managed by order_manager before
                 is_new_order = not self.channel.exchange_manager.exchange_personal_data.orders_manager. \
                     has_order(None, exchange_order_id=exchange_order_id)
                 has_new_order |= is_new_order
 
                 # update this order
@@ -87,24 +79,14 @@
                 )
 
         except asyncio.CancelledError:
             self.logger.info("Update tasks cancelled.")
         except Exception as e:
             self.logger.exception(e, True, f"Exception when triggering update: {e}")
 
-    async def _restore_required_virtual_orders(self):
-        """
-        Restore virtual orders that would not be restored otherwise
-        Should only be called once or will create the same virtual orders multiple times
-        """
-        pending_groups = {}
-        await orders_storage_operations.create_required_virtual_orders(
-            pending_groups, self.channel.exchange_manager
-        )
-
     async def _handle_open_order_update(
         self, symbol, order_dict, exchange_order_id, is_from_bot, is_new_order, pending_groups
     ):
         """
         Create or update an open Order from exchange data
         :param symbol: the order symbol
         :param order_dict: the order dict
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders_updater.py`

 * *Files 0% similar despite different names*

```diff
@@ -72,15 +72,14 @@
                         self.channel.exchange_manager.exchange_name,
                         commons_enums.InitializationEventExchangeTopics.POSITIONS.value
                     ),
                 ],
                 self.DEPENDENCIES_TIMEOUT
             )
             await self.fetch_and_push(is_from_bot=False, retry_till_success=True)
-            await self._restore_required_virtual_orders()
         except errors.NotSupported:
             self.logger.error(f"{self.channel.exchange_manager.exchange_name} is not supporting open orders updates")
             await self.pause()
         except Exception as e:
             self.logger.exception(e, True, f"Fail to initialize orders : {e}")
 
     async def start(self) -> None:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/channel/orders_updater_simulator.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,11 +29,7 @@
             self._set_initialized_event(symbol)
 
     async def ignore_recent_trades_update(self, exchange: str, exchange_id: str,
                                           cryptocurrency: str, symbol: str, recent_trades: list):
         """
         Used to subscribe at least one recent trades consumer during backtesting
         """
-
-    async def _restore_required_virtual_orders(self):
-        # nothing to do
-        pass
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/decimal_order_adapter.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/decimal_order_adapter.py`

 * *Files 24% similar despite different names*

```diff
@@ -12,19 +12,16 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import math
 import decimal
 
-import octobot_commons.symbols as commons_symbols
-
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
-import octobot_trading.enums as enums
 import octobot_trading.exchanges as exchanges
 import octobot_trading.personal_data as personal_data
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc
 
 DECIMAL_SCIENTIFIC_NOTATION_EXP = "E-"
 
 
@@ -36,33 +33,14 @@
             return decimal.Decimal(str(min_limit))
         min_precision = symbol_market[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
         return decimal.Decimal(f"1e-{min_precision}")
     except KeyError:
         raise errors.NotSupported("Impossible to get the minimal order size for the this exchange")
 
 
-def get_minimal_order_cost(symbol_market) -> float:
-    try:
-        min_cost = symbol_market[Ecmsc.LIMITS.value][Ecmsc.LIMITS_COST.value].get(Ecmsc.LIMITS_COST_MIN.value, None)
-        if min_cost:
-            return min_cost
-
-        min_amount = symbol_market[Ecmsc.LIMITS.value][Ecmsc.LIMITS_AMOUNT.value].get(
-            Ecmsc.LIMITS_AMOUNT_MIN.value, None
-        )
-        min_price = symbol_market[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value].get(
-            Ecmsc.LIMITS_PRICE_MIN.value, None
-        )
-        if min_amount and min_price:
-            return min_amount * min_price
-    except KeyError:
-        pass
-    raise errors.NotSupported("Impossible to get the minimal order size for the this exchange")
-
-
 def decimal_adapt_price(symbol_market, price, truncate=True):
     maximal_price_digits = symbol_market[Ecmsc.PRECISION.value].get(
                                                 Ecmsc.PRECISION_PRICE.value,
                                                 constants.CURRENCY_DEFAULT_MAX_PRICE_DIGITS)
     return decimal_trunc_with_n_decimal_digits(price, maximal_price_digits, truncate)
 
 
@@ -122,37 +100,14 @@
 
     other_orders_quantity = max_value / price
     valid_other_orders_quantity = decimal_adapt_quantity(symbol_market, other_orders_quantity)
     orders += [(valid_other_orders_quantity, price)] * int(nb_full_orders)
     return orders
 
 
-def decimal_adapt_order_quantity_because_fees(
-    exchange_manager, symbol: str, order_type: enums.TraderOrderType, quantity: decimal.Decimal, price: decimal.Decimal,
-    taker_or_maker: enums.ExchangeConstantsMarketPropertyColumns, side: enums.TradeOrderSide,
-    quote_available_funds: decimal.Decimal
-) -> decimal.Decimal:
-    if not exchange_manager.is_future and side == enums.TradeOrderSide.BUY:
-        # only buy orders are affected
-        computed_fee = exchange_manager.exchange.get_trade_fee(
-            symbol, order_type, quantity, price, taker_or_maker.value
-        )
-        quote = commons_symbols.parse_symbol(symbol).quote
-        # if fee paid in quote, ensure enough remaining quote asset in available portfolio
-        if currency_fee := personal_data.get_fees_for_currency(computed_fee, quote):
-            fees_in_base = (currency_fee / price) if price else constants.ZERO
-            base_quantity_from_quote = quote_available_funds / price
-            required_base_fees = fees_in_base * 2  # use 2x the fees to be sure exchanges won't refuse it
-            total_required_quote_quantity = (required_base_fees + quantity) * price
-            if quote_available_funds < total_required_quote_quantity:
-                # use maximum quantity considering fees
-                quantity = max(base_quantity_from_quote - required_base_fees, constants.ZERO)
-    return quantity
-
-
 def decimal_split_orders(total_order_price, max_cost, valid_quantity, max_quantity, price, quantity, symbol_market):
     """
     Splits too big orders into multiple ones according to the max_cost and max_quantity
     :param total_order_price:
     :param max_cost:
     :param valid_quantity:
     :param max_quantity:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/balanced_take_profit_and_stop_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/group_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/group_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/groups/one_cancels_the_other_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order.py`

 * *Files 9% similar despite different names*

```diff
@@ -21,15 +21,14 @@
 import octobot_commons.logging as logging
 
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
 import octobot_trading.personal_data.orders.states as orders_states
 import octobot_trading.personal_data.orders.order_util as order_util
-import octobot_trading.personal_data.orders.decimal_order_adapter as decimal_order_adapter
 import octobot_trading.util as util
 
 
 class Order(util.Initializable):
     """
     Order class will represent an open order in the specified exchange
     In simulation it will also define rules to be filled / canceled
@@ -55,15 +54,14 @@
         self.market = None
         self.quantity_currency = None
         self.taker_or_maker = None
         self.timestamp = 0
         self.side = side
         self.tag = None
         self.associated_entry_ids = None
-        self.broker_applied = False
 
         # original order attributes
         self.creation_time = self.exchange_manager.exchange.get_exchange_current_time()
         self.origin_price = constants.ZERO
         self.created_last_price = constants.ZERO
         self.origin_quantity = constants.ZERO
         self.origin_stop_price = constants.ZERO
@@ -134,15 +132,15 @@
                fee=None, total_cost=constants.ZERO, timestamp=None,
                order_type=None, reduce_only=None, close_position=None, position_side=None, fees_currency_side=None,
                group=None, tag=None, quantity_currency=None, exchange_creation_params=None,
                associated_entry_id=None) -> bool:
         changed: bool = False
         should_update_total_cost = False
 
-        price = current_price if (current_price and self.use_current_price_as_origin_price()) else price
+        price = current_price if self.use_current_price_as_origin_price() else price
 
         if order_id and self.order_id != order_id:
             self.order_id = order_id
 
         if exchange_order_id and self.exchange_order_id != exchange_order_id:
             self.exchange_order_id = exchange_order_id
 
@@ -280,18 +278,14 @@
         """
         Initialize order status update tasks
         """
         await orders_states.create_order_state(self, **kwargs)
         if self.is_created() and not self.is_closed():
             await self.update_order_status()
 
-    def register_broker_applied_if_enabled(self):
-        if not self.simulated and self.trader and self.trader.exchange_manager:
-            self.broker_applied = self.trader.exchange_manager.is_broker_enabled
-
     def _on_origin_price_change(self, previous_price, price_time):
         """
         Called when origin price just changed.
         Override if necessary
         :param previous_price: the previous origin_price
         :param price_time: time starting from when the price should be considered
         """
@@ -325,31 +319,23 @@
         return isinstance(self.state, orders_states.PendingCreationOrderState)
 
     def is_open(self):
         # also check is_initialized to avoid considering uncreated orders as open
         return self.state is None or self.state.is_open()
 
     def is_filled(self):
-        if self.state is None:
-            return self.status is enums.OrderStatus.FILLED
         return self.state.is_filled() or (self.state.is_closed() and self.status is enums.OrderStatus.FILLED)
 
     def is_cancelled(self):
-        if self.state is None:
-            return self.status is enums.OrderStatus.CANCELED
         return self.state.is_canceled() or (self.state.is_closed() and self.status is enums.OrderStatus.CANCELED)
 
     def is_cancelling(self):
-        if self.state is None:
-            return self.status is enums.OrderStatus.PENDING_CANCEL
         return self.state.state is enums.OrderStates.CANCELING or self.status is enums.OrderStatus.PENDING_CANCEL
 
     def is_closed(self):
-        if self.state is None:
-            return self.status is enums.OrderStatus.CLOSED
         return self.state.is_closed() if self.state is not None else self.status is enums.OrderStatus.CLOSED
 
     def is_refreshing(self):
         return self.state is not None and self.state.is_refreshing()
 
     def can_be_edited(self):
         # orders that are not yet open or already open can be edited
@@ -373,99 +359,66 @@
     @contextlib.contextmanager
     def order_state_creation(self):
         try:
             yield
         except errors.InvalidOrderState as exc:
             logging.get_logger(self.get_logger_name()).exception(exc, True, f"Error when creating order state: {exc}")
 
-    async def on_pending_creation(self, is_from_exchange_data=False, enable_associated_orders_creation=True):
+    async def on_pending_creation(self, is_from_exchange_data=False):
         with self.order_state_creation():
             state_class = orders_states.PendingCreationChainedOrderState if self.is_waiting_for_chained_trigger \
                 else orders_states.PendingCreationOrderState
-            self.state = state_class(
-                self, is_from_exchange_data=is_from_exchange_data,
-                enable_associated_orders_creation=enable_associated_orders_creation
-            )
+            self.state = state_class(self, is_from_exchange_data=is_from_exchange_data)
             await self.state.initialize()
 
-    async def on_open(self, force_open=False, is_from_exchange_data=False, enable_associated_orders_creation=True):
+    async def on_open(self, force_open=False, is_from_exchange_data=False):
         with self.order_state_creation():
             if isinstance(self.state, orders_states.PendingCreationOrderState):
                 await self.state.trigger_terminate()
             if isinstance(self.state, orders_states.OpenOrderState):
                 if not self.state.is_initialized:
                     logging.get_logger(self.get_logger_name()).error(f"on_open called with existing "
                                                                      f"uninitialized OpenOrderState.")
                 # state has already been created and initialized
                 return
-            self.state = orders_states.OpenOrderState(
-                self, is_from_exchange_data=is_from_exchange_data,
-                enable_associated_orders_creation=enable_associated_orders_creation
-            )
+            self.state = orders_states.OpenOrderState(self, is_from_exchange_data=is_from_exchange_data)
             await self.state.initialize(forced=force_open)
 
-    async def on_fill(self, force_fill=False, is_from_exchange_data=False, enable_associated_orders_creation=None):
-        enable_associated_orders_creation = self.state.enable_associated_orders_creation \
-            if (self.state and enable_associated_orders_creation is None) \
-            else (enable_associated_orders_creation or True)
+    async def on_fill(self, force_fill=False, is_from_exchange_data=False):
         logging.get_logger(self.get_logger_name()).debug(f"on_fill triggered for {self}")
         if (self.is_open() and not self.is_refreshing()) or self.is_pending_creation():
             with self.order_state_creation():
-                self.state = orders_states.FillOrderState(
-                    self, is_from_exchange_data=is_from_exchange_data,
-                    enable_associated_orders_creation=enable_associated_orders_creation
-                )
+                self.state = orders_states.FillOrderState(self, is_from_exchange_data=is_from_exchange_data)
                 await self.state.initialize(forced=force_fill)
         else:
             logging.get_logger(self.get_logger_name()).debug(f"Trying to fill a refreshing or previously filled "
                                                              f"or canceled order: "
                                                              f"ignored fill call for {self}")
 
-    async def on_close(self, force_close=False, is_from_exchange_data=False, enable_associated_orders_creation=None):
-        enable_associated_orders_creation = self.state.enable_associated_orders_creation \
-            if (self.state and enable_associated_orders_creation is None) \
-            else (enable_associated_orders_creation or True)
+    async def on_close(self, force_close=False, is_from_exchange_data=False):
         with self.order_state_creation():
-            self.state = orders_states.CloseOrderState(
-                self, is_from_exchange_data=is_from_exchange_data,
-                enable_associated_orders_creation=enable_associated_orders_creation
-            )
+            self.state = orders_states.CloseOrderState(self, is_from_exchange_data=is_from_exchange_data)
             await self.state.initialize(forced=force_close)
 
-    async def on_cancel(
-            self, is_from_exchange_data=False, force_cancel=False, enable_associated_orders_creation=None,
-            ignored_order=None
-    ):
-        enable_associated_orders_creation = self.state.enable_associated_orders_creation \
-            if (self.state and enable_associated_orders_creation is None) \
-            else (enable_associated_orders_creation or True)
+    async def on_cancel(self, is_from_exchange_data=False, force_cancel=False, ignored_order=None):
         with self.order_state_creation():
-            self.state = orders_states.CancelOrderState(
-                self, is_from_exchange_data=is_from_exchange_data,
-                enable_associated_orders_creation=enable_associated_orders_creation
-            )
+            self.state = orders_states.CancelOrderState(self, is_from_exchange_data=is_from_exchange_data)
             await self.state.initialize(forced=force_cancel, ignored_order=ignored_order)
 
     def on_fill_actions(self):
         """
         Perform on_fill actions
         """
         self.status = enums.OrderStatus.FILLED
 
-    async def on_filled(self, enable_associated_orders_creation):
+    async def on_filled(self):
         """
         Filling complete callback
         """
-        if enable_associated_orders_creation:
-            await self._trigger_chained_orders()
-        elif self.chained_orders:
-            logging.get_logger(self.get_logger_name()).info(
-                f"Skipped chained orders creation for {len(self.chained_orders)} chained orders: "
-                f"enable_associated_orders_creation is {enable_associated_orders_creation}"
-            )
+        await self._trigger_chained_orders()
 
     def associate_to_entry(self, entry_order_id):
         if self.associated_entry_ids is None:
             self.associated_entry_ids = []
         if entry_order_id not in self.associated_entry_ids:
             self.associated_entry_ids.append(entry_order_id)
             return True
@@ -473,35 +426,28 @@
 
     def update_quantity_with_order_fees(self, other_order):
         relevant_fees_amount = order_util.get_fees_for_currency(other_order.fee, self.quantity_currency)
         if relevant_fees_amount:
             logger = logging.get_logger(self.get_logger_name())
             fees_str = f"Paid {self.quantity_currency} fees: {relevant_fees_amount}, " \
                        f"initial order size: {self.origin_quantity}"
-            if relevant_fees_amount >= self.origin_quantity:
+            if relevant_fees_amount > self.origin_quantity:
                 logger.error(f"Impossible to update chained order amount according to triggering order fees: "
                              f"fees are larger than then chained order size. {fees_str}")
                 return False
-            self.origin_quantity = decimal_order_adapter.decimal_adapt_quantity(
-                self.exchange_manager.exchange.get_market_status(self.symbol, with_fixer=False),
-                self.origin_quantity - relevant_fees_amount
-            )
-            fees_str = f"{fees_str}, updated size: {self.origin_quantity}"
+            self.origin_quantity -= relevant_fees_amount
             logger.debug(f"Updating chained order quantity with triggering order fees. {fees_str}")
         return True
 
-    async def update_price_if_outdated(self):
-        """
-        Implement if necessary
-        """
-
     async def _trigger_chained_orders(self):
         logger = logging.get_logger(self.get_logger_name())
         for index, order in enumerate(self.chained_orders):
-            can_be_created = await order_util.adapt_chained_order_before_creation(self, order)
+            can_be_created = True
+            if order.update_with_triggering_order_fees:
+                can_be_created = order.update_quantity_with_order_fees(self)
             if can_be_created and order.should_be_created():
                 logger.debug(f"Creating chained order {index + 1}/{len(self.chained_orders)}")
                 await order_util.create_as_chained_order(order)
             else:
                 logger.debug(f"Skipping cancelled chained order {index + 1}/{len(self.chained_orders)}")
 
     async def set_as_chained_order(self, triggered_by, has_been_bundled, exchange_creation_params,
@@ -538,36 +484,31 @@
         try:
             # requires fees to be from exchange and having a not None exchange original cost
             return self.fee[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value] \
                    and self.fee[enums.FeePropertyColumns.EXCHANGE_ORIGINAL_COST.value] is not None
         except KeyError:
             return False
 
-    def get_computed_fee(self, forced_value=None, use_origin_quantity_and_price=False):
+    def get_computed_fee(self, forced_value=None):
         is_from_exchange = False
-        price = self.origin_price if use_origin_quantity_and_price else self.filled_price
-        quantity = self.origin_quantity if use_origin_quantity_and_price else self.filled_quantity
-        # consider worse case taker fees when using use_origin_quantity_and_price as the order is not filled yet
-        taker_or_maker = enums.ExchangeConstantsOrderColumns.TAKER.value \
-            if use_origin_quantity_and_price else self.taker_or_maker
         if self.fees_currency_side is enums.FeesCurrencySide.UNDEFINED:
-            computed_fee = self.exchange_manager.exchange.get_trade_fee(
-                self.symbol, self.order_type, quantity, price, taker_or_maker
-            )
+            computed_fee = self.exchange_manager.exchange.get_trade_fee(self.symbol, self.order_type,
+                                                                        self.filled_quantity, self.filled_price,
+                                                                        self.taker_or_maker)
             value = computed_fee[enums.FeePropertyColumns.COST.value]
             currency = computed_fee[enums.FeePropertyColumns.CURRENCY.value]
             is_from_exchange = computed_fee[enums.FeePropertyColumns.IS_FROM_EXCHANGE.value]
         else:
             symbol_fees = self.exchange_manager.exchange.get_fees(self.symbol)
-            fees = decimal.Decimal(f"{symbol_fees[taker_or_maker]}")
+            fees = decimal.Decimal(f"{symbol_fees[self.taker_or_maker]}")
             if self.fees_currency_side is enums.FeesCurrencySide.CURRENCY:
-                value = quantity / price * fees
+                value = self.filled_quantity / self.filled_price * fees
                 currency = self.currency
             else:
-                value = quantity * price * fees
+                value = self.filled_quantity * self.filled_price * fees
                 currency = self.market
         return {
             enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: is_from_exchange,
             enums.FeePropertyColumns.COST.value: forced_value if forced_value is not None else value,
             enums.FeePropertyColumns.CURRENCY.value: currency,
         }
 
@@ -688,18 +629,14 @@
         if other_order.state is not None:
             await other_order.state.replace_order(self)
 
     def update_from_storage_order_details(self, order_details):
         # rebind order attributes that are not stored on exchange
         order_dict = order_details.get(constants.STORAGE_ORIGIN_VALUE, {})
         self.tag = order_dict.get(enums.ExchangeConstantsOrderColumns.TAG.value, self.tag)
-        self.broker_applied = order_dict.get(
-            enums.ExchangeConstantsOrderColumns.BROKER_APPLIED.value,
-            self.broker_applied
-        )
         self.order_id = order_dict.get(enums.ExchangeConstantsOrderColumns.ID.value, self.order_id)
         self.exchange_order_id = order_dict.get(enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value,
                                                 self.exchange_order_id)
         self.trader_creation_kwargs = order_details.get(enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value,
                                                         self.trader_creation_kwargs)
         self.exchange_creation_params = order_details.get(enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value,
                                                           self.exchange_creation_params)
@@ -728,23 +665,14 @@
         if self.quantity_currency == self.currency:
             # quantity in BTC for BTC/USDT => cost = BTC * price(BTC in USDT)
             self.total_cost = quantity * price
         else:
             # quantity in USDT for BTC/USDT => cost = price(BTC in USDT)
             self.total_cost = quantity
 
-    def update_order_filled_values(self, ideal_price: decimal.Decimal):
-        if not self.filled_price:
-            # keep order.filled_price if already set (!= 0)
-            self.filled_price = order_util.get_valid_filled_price(self, ideal_price)
-        if not self.filled_quantity or self.exchange_manager.trader.simulate:
-            # keep self.filled_quantity if already set (!= 0) in real trading
-            self.filled_quantity = self.origin_quantity
-        self._update_total_cost()
-
     def consider_as_canceled(self):
         self.status = enums.OrderStatus.CANCELED
         if self.canceled_time == 0:
             self.canceled_time = self.timestamp
 
     def update_order_from_raw(self, raw_order):
         self.status = order_util.parse_order_status(raw_order)
@@ -783,27 +711,26 @@
         filled_price = self.filled_price if self.filled_price > 0 else self.origin_price
         return {
             enums.ExchangeConstantsOrderColumns.ID.value: self.order_id,
             enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value: self.exchange_order_id,
             enums.ExchangeConstantsOrderColumns.SYMBOL.value: self.symbol,
             enums.ExchangeConstantsOrderColumns.PRICE.value: filled_price,
             enums.ExchangeConstantsOrderColumns.STATUS.value: self.status.value,
-            enums.ExchangeConstantsOrderColumns.TIMESTAMP.value: self.creation_time or self.timestamp,
+            enums.ExchangeConstantsOrderColumns.TIMESTAMP.value: self.timestamp,
             enums.ExchangeConstantsOrderColumns.TYPE.value: self.exchange_order_type.value
             if self.exchange_order_type else None,
             enums.ExchangeConstantsOrderColumns.SIDE.value: self.side.value,
             enums.ExchangeConstantsOrderColumns.AMOUNT.value: self.origin_quantity,
             enums.ExchangeConstantsOrderColumns.COST.value: self.total_cost,
             enums.ExchangeConstantsOrderColumns.QUANTITY_CURRENCY.value: self.quantity_currency,
             enums.ExchangeConstantsOrderColumns.FILLED.value: self.filled_quantity,
             enums.ExchangeConstantsOrderColumns.FEE.value: self.fee,
             enums.ExchangeConstantsOrderColumns.REDUCE_ONLY.value: self.reduce_only,
             enums.ExchangeConstantsOrderColumns.TAG.value: self.tag,
             enums.ExchangeConstantsOrderColumns.SELF_MANAGED.value: self.is_self_managed(),
-            enums.ExchangeConstantsOrderColumns.BROKER_APPLIED.value: self.broker_applied,
         }
 
     def clear(self):
         if self.state is not None:
             self.state.clear()
         self.trader = None
         self.exchange_manager = None
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_adapter.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_factory.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,44 +9,31 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import octobot_commons.logging as logging
-
 import octobot_trading.personal_data as personal_data
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 
 
 def create_order_from_raw(trader, raw_order):
     _, order_type = personal_data.parse_order_type(raw_order)
     return create_order_from_type(trader, order_type)
 
 
-def create_order_instance_from_raw(
-    trader, raw_order, force_open_or_pending_creation=False, has_just_been_created=False
-):
-    try:
-        order = create_order_from_raw(trader, raw_order)
-        order.update_from_raw(raw_order)
-        if has_just_been_created:
-            order.register_broker_applied_if_enabled()
-        if force_open_or_pending_creation \
-                and order.status not in (enums.OrderStatus.OPEN, enums.OrderStatus.PENDING_CREATION):
-            order.status = enums.OrderStatus.OPEN
-        return order
-    except Exception as err:
-        # log unparsable order to fix it
-        logging.get_logger(__name__).exception(
-            err, True, f"Unexpected {err} ({err.__class__.__name__}) error when parsing row order {raw_order}"
-        )
-        raise
+def create_order_instance_from_raw(trader, raw_order, force_open_or_pending_creation=False):
+    order = create_order_from_raw(trader, raw_order)
+    order.update_from_raw(raw_order)
+    if force_open_or_pending_creation \
+            and order.status not in (enums.OrderStatus.OPEN, enums.OrderStatus.PENDING_CREATION):
+        order.status = enums.OrderStatus.OPEN
+    return order
 
 
 def create_order_from_type(trader, order_type, side=None):
     if side is None:
         return personal_data.TraderOrderTypeClasses[order_type](trader)
     return personal_data.TraderOrderTypeClasses[order_type](trader, side=side)
 
@@ -155,8 +142,7 @@
                 order,
                 chained_order.get(enums.StoredOrdersAttr.HAS_BEEN_BUNDLED.value, False),
                 chained_order.get(enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value, {}),
                 chained_order.get(enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES.value, False),
                 **chained_order.get(enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value, {}),
             )
             order.add_chained_order(chained_order_inst)
-            logging.get_logger(order.get_logger_name()).debug(f"Restored chained order: {chained_order_inst}")
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_group.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_state.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,25 +20,23 @@
 import octobot_trading.enums as enums
 import octobot_trading.errors
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.personal_data.state as state_class
 
 
 class OrderState(state_class.State):
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True):
+    def __init__(self, order, is_from_exchange_data):
         super().__init__(is_from_exchange_data)
 
         # ensure order has not been cleared
         self.ensure_not_cleared(order)
 
         # related order
         self.order = order
 
-        self.enable_associated_orders_creation = enable_associated_orders_creation
-
     def is_created(self) -> bool:
         """
         :return: True if the Order is created
         """
         return True
 
     def is_open(self) -> bool:
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/order_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/order_util.py`

 * *Files 24% similar despite different names*

```diff
@@ -21,17 +21,15 @@
 import octobot_commons.symbols as symbol_util
 import octobot_commons.constants as commons_constants
 import octobot_commons.logging as logging
 import octobot_commons.timestamp_util as timestamp_util
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
 import octobot_trading.errors as errors
-import octobot_trading.personal_data.orders.decimal_order_adapter as decimal_order_adapter
 import octobot_trading.exchanges.util.exchange_market_status_fixer as exchange_market_status_fixer
-import octobot_trading.personal_data.orders.states.fill_order_state as fill_order_state
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc
 
 
 LOGGER_NAME = "order_util"
 
 
 def is_valid(element, key):
@@ -101,98 +99,17 @@
     if total_order_price < min_cost:
         if min_cost is None:
             logging.get_logger(LOGGER_NAME).error("Invalid min_cost from exchange")
         return False
     return True
 
 
-def get_split_orders_count_and_increment(
-    lower_price, higher_price, quantity, orders_count, symbol_market, add_increment_to_min_price
-) \
-        -> (int, decimal.Decimal):
-    """
-    :param lower_price: smallest order price
-    :param higher_price: largest order price
-    :param quantity: total quantity to handle
-    :param orders_count: ideal orders count
-    :param symbol_market: description of the market to trade on
-    :param add_increment_to_min_price: when true, uses lower_price + increment to check min values against symbol market
-    :return: the exchange compatible orders count and price increment
-    """
-    min_quantity, max_quantity, min_cost, max_cost, min_price, max_price = get_min_max_amounts(symbol_market)
-    min_quantity = None if min_quantity is None else decimal.Decimal(f"{min_quantity}")
-    max_quantity = None if max_quantity is None else decimal.Decimal(f"{max_quantity}")
-    min_cost = None if min_cost is None else decimal.Decimal(f"{min_cost}")
-    max_cost = None if max_cost is None else decimal.Decimal(f"{max_cost}")
-    min_price = None if min_price is None else decimal.Decimal(f"{min_price}")
-    max_price = None if max_price is None else decimal.Decimal(f"{max_price}")
-
-    limit_check = _ensure_orders_size(
-        lower_price, higher_price, quantity, orders_count,
-        min_quantity, min_cost, min_price,
-        max_quantity, max_cost, max_price,
-        symbol_market, add_increment_to_min_price
-    )
-
-    while limit_check > 0:
-        if limit_check == 1:
-            if orders_count > 1:
-                orders_count -= 1
-            else:
-                # not enough funds to create orders
-                logging.get_logger(LOGGER_NAME).warning(f"Not enough funds to create order.")
-                return 0, constants.ZERO
-        elif limit_check == 2:
-            if orders_count < 40:
-                orders_count += 1
-            else:
-                # too many orders to create, must be a problem
-                logging.get_logger(LOGGER_NAME).error("Too many orders to create.")
-                return 0, constants.ZERO
-        limit_check = _ensure_orders_size(
-            lower_price, higher_price, quantity, orders_count,
-            min_quantity, min_cost, min_price,
-            max_quantity, max_cost, max_price,
-            symbol_market, add_increment_to_min_price
-        )
-    return orders_count, (higher_price - lower_price) / orders_count
-
-
-def _ensure_orders_size(lower_price, higher_price, quantity, orders_count,
-                        min_quantity, min_cost, min_price,
-                        max_quantity, max_cost, max_price,
-                        symbol_market, add_increment_to_min_price):
-    increment = (higher_price - lower_price) / orders_count
-    first_price = (lower_price + increment) if add_increment_to_min_price else lower_price
-    last_price = lower_price + (increment * orders_count)
-    order_vol = decimal_order_adapter.decimal_adapt_quantity(symbol_market, quantity / orders_count)
-
-    if _are_orders_too_small(min_quantity, min_cost, min_price, first_price, order_vol):
-        return 1
-    elif _are_orders_too_large(max_quantity, max_cost, max_price, last_price, order_vol):
-        return 2
-    return 0
-
-
-def _are_orders_too_small(min_quantity, min_cost, min_price, price, volume):
-    return (min_price and price < min_price) or \
-           (min_quantity and volume < min_quantity) or \
-           (min_cost and price * volume < min_cost)
-
-
-def _are_orders_too_large(max_quantity, max_cost, max_price, price, volume):
-    return (max_price and price > max_price) or \
-           (max_quantity and volume > max_quantity) or \
-           (max_cost and price * volume > max_cost)
-
-
 async def get_up_to_date_price(exchange_manager, symbol: str, timeout: int = None, base_error: str = None):
     exchange_time = exchange_manager.exchange.get_exchange_current_time()
-    base_error = base_error or f"Can't get the necessary {exchange_manager.exchange_name} " \
-                               f"price data to create a new {symbol} order on the " \
+    base_error = base_error or f"Can't get the necessary price data to create a new {symbol} order on the " \
                                f"{timestamp_util.convert_timestamp_to_datetime(exchange_time)} " \
                                f"(timestamp: {exchange_time}):"
     try:
         mark_price = await exchange_manager.exchange_symbols_data.get_exchange_symbol_data(symbol) \
             .prices_manager.get_mark_price(timeout=timeout)
     except asyncio.TimeoutError:
         raise asyncio.TimeoutError(f"{base_error} mark price is not available")
@@ -202,21 +119,15 @@
 
 
 async def get_pre_order_data(exchange_manager, symbol: str, timeout: int = None,
                              portfolio_type=commons_constants.PORTFOLIO_AVAILABLE,
                              target_price=None):
     price = target_price or await get_up_to_date_price(exchange_manager, symbol, timeout=timeout)
     symbol_market = exchange_manager.exchange.get_market_status(symbol, with_fixer=False)
-    currency_available, market_available, market_quantity = get_portfolio_amounts(
-        exchange_manager, symbol, price, portfolio_type=portfolio_type
-    )
-    return currency_available, market_available, market_quantity, price, symbol_market
 
-
-def get_portfolio_amounts(exchange_manager, symbol, price, portfolio_type=commons_constants.PORTFOLIO_AVAILABLE):
     currency, market = symbol_util.parse_symbol(symbol).base_and_quote()
     portfolio = exchange_manager.exchange_personal_data.portfolio_manager.portfolio
     currency_available = portfolio.get_currency_portfolio(currency).available \
         if portfolio_type == commons_constants.PORTFOLIO_AVAILABLE else portfolio.get_currency_portfolio(currency).total
     market_available = portfolio.get_currency_portfolio(market).available \
         if portfolio_type == commons_constants.PORTFOLIO_AVAILABLE else portfolio.get_currency_portfolio(market).total
 
@@ -228,15 +139,15 @@
         else:
             market_available *= pair_future_contract.current_leverage / price
             market_quantity = currency_available = market_available
     elif exchange_manager.is_margin:
         market_quantity = constants.ZERO  # TODO
     else:
         market_quantity = market_available / price if price else constants.ZERO
-    return currency_available, market_available, market_quantity
+    return currency_available, market_available, market_quantity, price, symbol_market
 
 
 def get_futures_max_order_size(exchange_manager, symbol, side, current_price, reduce_only,
                                current_symbol_holding, market_quantity):
     # use position margin when trading futures and reducing the position
     current_position = exchange_manager.exchange_personal_data.positions_manager.get_symbol_position(
         symbol,
@@ -303,26 +214,14 @@
         return position.symbol_contract.current_leverage * available_quantity / \
             (two_way_fees + constants.ONE / price)
     # Returns the maximum order quantity in currency.
     return position.symbol_contract.current_leverage * available_quantity / \
         (two_way_fees + price)
 
 
-def get_locked_funds(order):
-    forecasted_fees = order.get_computed_fee(use_origin_quantity_and_price=not order.is_filled())
-    if order.side == enums.TradeOrderSide.BUY:
-        # locking quote to buy
-        quote_fees = get_fees_for_currency(forecasted_fees, order.market)
-        return order.origin_quantity * order.origin_price + quote_fees
-    else:
-        # locking base to sell
-        base_fees = get_fees_for_currency(forecasted_fees, order.currency)
-        return order.origin_quantity + base_fees
-
-
 def total_fees_from_order_dict(order_dict, currency):
     return get_fees_for_currency(order_dict[enums.ExchangeConstantsOrderColumns.FEE.value], currency)
 
 
 def get_fees_for_currency(fee, currency):
     if fee and fee[enums.FeePropertyColumns.CURRENCY.value] == currency:
         return decimal.Decimal(str(fee[enums.FeePropertyColumns.COST.value]))
@@ -346,15 +245,15 @@
     return fees
 
 
 def parse_order_status(raw_order):
     try:
         return enums.OrderStatus(raw_order[enums.ExchangeConstantsOrderColumns.STATUS.value])
     except KeyError:
-        return enums.OrderStatus.UNKNOWN
+        return KeyError("Could not parse new order status")
     except ValueError:
         if raw_order[enums.ExchangeConstantsOrderColumns.STATUS.value] == "cancelled":
             # few exchanges use "cancelled" which is not in enums.ExchangeConstantsOrderColumns.STATUS
             raw_order[enums.ExchangeConstantsOrderColumns.STATUS.value] = enums.OrderStatus.CANCELED.value
             return enums.OrderStatus.CANCELED
         raise
 
@@ -375,28 +274,28 @@
                             enums.TraderOrderType.TAKE_PROFIT_LIMIT]:
         return enums.PNLTransactionSource.LIMIT_ORDER
     if is_stop_order(order.order_type):
         return enums.PNLTransactionSource.STOP_ORDER
     return enums.PNLTransactionSource.UNKNOWN
 
 
-def is_stop_order(order_type: enums.TraderOrderType):
+def is_stop_order(order_type):
     return order_type in [
         enums.TraderOrderType.STOP_LOSS, enums.TraderOrderType.STOP_LOSS_LIMIT,
         enums.TraderOrderType.TRAILING_STOP, enums.TraderOrderType.TRAILING_STOP_LIMIT,
     ]
 
 
 def is_take_profit_order(order_type):
     return order_type in [
         enums.TraderOrderType.TAKE_PROFIT, enums.TraderOrderType.TAKE_PROFIT_LIMIT,
     ]
 
 
-def get_trade_order_type(order_type: enums.TraderOrderType) -> enums.TradeOrderType:
+def get_trade_order_type(order_type: enums.TraderOrderType):
     if order_type in (enums.TraderOrderType.BUY_MARKET, enums.TraderOrderType.SELL_MARKET):
         return enums.TradeOrderType.MARKET
     if order_type in (enums.TraderOrderType.BUY_LIMIT, enums.TraderOrderType.SELL_LIMIT):
         return enums.TradeOrderType.LIMIT
     if order_type is enums.TraderOrderType.STOP_LOSS:
         return enums.TradeOrderType.STOP_LOSS
     if order_type is enums.TraderOrderType.TRAILING_STOP:
@@ -423,29 +322,20 @@
             # register it as pending creation order for it to be found and update when fetched
             order.exchange_manager.exchange_personal_data.orders_manager.register_pending_creation_order(order)
     else:
         # set created now to consider creation failures as created as well (the caller can always retry later on)
         order.status = enums.OrderStatus.OPEN
         # set uninitialized to allow second initialization from create_order
         order.is_initialized = False
-        order.creation_time = order.exchange_manager.exchange.get_exchange_current_time()
-        try:
-            await order.trader.create_order(
-                order,
-                loaded=False,
-                params=order.exchange_creation_params,
-                **order.trader_creation_kwargs
-            )
-        except Exception as err:
-            # log warning to be sure to keep track of the failed order details
-            logging.get_logger(LOGGER_NAME).warning(
-                f"Failed to create chained order {order.to_dict()}: {err} ({err.__class__.__name__})"
-            )
-            # propagate
-            raise
+        await order.trader.create_order(
+            order,
+            loaded=False,
+            params=order.exchange_creation_params,
+            **order.trader_creation_kwargs
+        )
 
 
 def is_associated_pending_order(pending_order, created_order):
     return created_order.exchange_order_id == pending_order.exchange_order_id or (
         created_order.symbol == pending_order.symbol and
         created_order.origin_quantity == pending_order.origin_quantity and
         created_order.origin_price == pending_order.origin_price and
@@ -472,42 +362,40 @@
             )
             created_order.clear()
             return True
     return False
 
 
 @contextlib.asynccontextmanager
-async def ensure_orders_relevancy(order=None, position=None, enable_associated_orders_creation=True):
+async def ensure_orders_relevancy(order=None, position=None):
     exchange_manager = order.exchange_manager if position is None else position.exchange_manager
     # part used in futures trading only
     if exchange_manager.exchange_personal_data.positions_manager.positions:
         position = position or exchange_manager.exchange_personal_data.positions_manager.get_order_position(order)
         pre_update_position_side = position.side
         is_pre_update_position_idle = position.is_idle()
         yield
         if not is_pre_update_position_idle and \
            (position.side != pre_update_position_side or position.is_idle()):
             # when position side is changing (from a non-idle position) or is going back to idle,
             # then associated reduce only orders must be closed
-            await _cancel_reduce_only_orders_on_position_reset(
-                exchange_manager, position.symbol, enable_associated_orders_creation
-            )
+            await _cancel_reduce_only_orders_on_position_reset(exchange_manager, position.symbol)
     else:
         # as a context manager, yield is mandatory
         yield
 
 
-async def _cancel_reduce_only_orders_on_position_reset(exchange_manager, symbol, enable_associated_orders_creation):
+async def _cancel_reduce_only_orders_on_position_reset(exchange_manager, symbol):
     for order in list(exchange_manager.exchange_personal_data.orders_manager.get_open_orders(symbol)):
         # reduce only order are automatically cancelled on exchanges, only cancel simulated orders
         if (exchange_manager.is_trader_simulated or order.is_self_managed()) \
                 and order.is_open() and order.reduce_only:
             try:
                 await order.trader.cancel_order(order)
-                if order.order_group and enable_associated_orders_creation:
+                if order.order_group:
                     await order.order_group.on_cancel(order)
             except (    # pylint: disable=try-except-raise
                 errors.OrderCancelError, errors.UnexpectedExchangeSideOrderStateError
             ):
                 # should never happen as those should be simulated orders
                 raise
 
@@ -545,75 +433,7 @@
             return constants.ZERO
         return min(order_amount / market_quantity, constants.ONE) * constants.ONE_HUNDRED
     raise errors.InvalidArgumentError(f"Unhandled side: {side}")
 
 
 def generate_order_id():
     return str(uuid.uuid4())
-
-
-def _get_possible_filled_price(
-    exchange_manager, symbol: str, side: enums.TradeOrderSide, ideal_price: decimal.Decimal
-) -> decimal.Decimal:
-    try:
-        min_price, max_price = exchange_manager.exchange_symbols_data.get_exchange_symbol_data(symbol).\
-            price_events_manager.get_min_and_max_prices()
-        if side is enums.TradeOrderSide.SELL:
-            if ideal_price < min_price:
-                return min_price
-        if side is enums.TradeOrderSide.BUY:
-            if ideal_price > max_price:
-                return max_price
-    except IndexError:
-        # no available price data
-        pass
-    return ideal_price
-
-
-def get_valid_filled_price(order, ideal_price: decimal.Decimal):
-    # ensure filled price based on ideal_price makes sense according to the current candle
-    # instead of blindly using ideal_price as this could
-    # potentially buy higher than the candle high or sell lower than the candle low,
-    # which can't happen on real conditions
-
-    if order.exchange_manager.is_backtesting:
-        # in backtesting: ensure ideal_price is with in current candle price.
-        return _get_possible_filled_price(order.exchange_manager, order.symbol, order.side, ideal_price)
-    # not in backtesting: price desync can't happen
-    return ideal_price
-
-
-async def adapt_chained_order_before_creation(base_order, chained_order):
-    can_be_created = True
-    if chained_order.update_with_triggering_order_fees:
-        can_be_created = chained_order.update_quantity_with_order_fees(base_order)
-    # ensure price is not outdated
-    await chained_order.update_price_if_outdated()
-    return can_be_created
-
-
-async def wait_for_order_fill(order, timeout, wait_for_portfolio_update):
-    if order.is_open():
-        if order.state is None:
-            logging.get_logger(LOGGER_NAME).error(
-                f"None state on created order, impossible to wait for fill, order: {order}"
-            )
-        else:
-            try:
-                await order.state.wait_for_next_state(timeout)
-            except asyncio.TimeoutError:
-                logging.get_logger(LOGGER_NAME).error(
-                    f"Timeout while waiting for {order.order_type.value} open order fill, order {order}"
-                )
-            if wait_for_portfolio_update and isinstance(order.state, fill_order_state.FillOrderState):
-                # portfolio is updated in FillOrderState: wait for this state to complete
-                try:
-                    await order.state.wait_for_next_state(timeout)
-                except asyncio.TimeoutError:
-                    logging.get_logger(LOGGER_NAME).error(
-                        f"Timeout while waiting for {order.order_type.value} filled order state to "
-                        f"complete, order {order}"
-                    )
-    if order.is_open():
-        logging.get_logger(LOGGER_NAME).error(f"Unexpected: order is still open, order {order}")
-    else:
-        logging.get_logger(LOGGER_NAME).info(f"Successfully filled order: {order}.")
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/orders_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/orders_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/orders_storage_operations.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/orders_storage_operations.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,32 +10,30 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_commons.logging as logging
-import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.order_factory as order_factory
 import octobot_trading.personal_data.orders.groups.group_util as group_util
 
 
 LOGGER_NAME = "orders_storage_operations"
 
 
 async def apply_order_storage_details_if_any(order, exchange_manager, pending_groups):
     # only real orders can be updated by stored orders
     if not exchange_manager.storage_manager.orders_storage \
-            or not exchange_manager.storage_manager.orders_storage.should_store_data():
+            or not exchange_manager.storage_manager.orders_storage.should_store_date():
         return
     order_details = await exchange_manager.storage_manager.orders_storage.get_startup_order_details(
         order.exchange_order_id
     )
     if order_details:
-        logging.get_logger(LOGGER_NAME).debug(f"Updating fetched order {order} using stored order details")
         order.update_from_storage_order_details(order_details)
         await create_orders_storage_related_elements(order, order_details, exchange_manager, pending_groups)
 
 
 async def create_orders_storage_related_elements(order, order_storage_details, exchange_manager, pending_groups):
     group = group_util.get_or_create_order_group_from_storage_order_details(order_storage_details, exchange_manager)
     if group:
@@ -43,51 +41,29 @@
         logging.get_logger(LOGGER_NAME).debug(f"Adding {order} to restored group {group}")
         pending_groups[group.name] = group
     await order_factory.restore_chained_orders_from_storage_order_details(
         order, order_storage_details, exchange_manager, pending_groups
     )
 
 
-async def create_order_from_storage_data(order_desc: dict, exchange_manager, pending_groups):
-    created_order = await order_factory.create_order_from_order_storage_details(
-        order_desc, exchange_manager, pending_groups
-    )
-    await created_order.initialize()
-    return created_order
-
-
 async def _create_storage_self_managed_orders_from_group(pending_group_id, exchange_manager, pending_groups):
     try:
         to_create_orders = exchange_manager.storage_manager.orders_storage \
             .get_startup_self_managed_orders_details_from_group(pending_group_id)
         for order_desc in to_create_orders:
-            await create_order_from_storage_data(order_desc, exchange_manager, pending_groups)
+            created_order = await order_factory.create_order_from_order_storage_details(
+                order_desc, exchange_manager, pending_groups
+            )
+            await created_order.initialize()
     except Exception as err:
         logging.get_logger(LOGGER_NAME).exception(
             err, True, f"Error when creating {pending_group_id} group self-managed orders with stored data: {err}"
         )
 
 
-async def create_required_virtual_orders(pending_groups, exchange_manager):
-    virtual_orders = exchange_manager.storage_manager.orders_storage.get_all_self_managed_startup_orders()
-    # virtual order that are not within a group will only be restored here
-    virtual_non_grouped_order_details = [
-        order
-        for order in virtual_orders
-        if order.get(enums.StoredOrdersAttr.GROUP.value, {}) == {}
-    ]
-    logger = logging.get_logger(LOGGER_NAME)
-    for order_details in virtual_non_grouped_order_details:
-        try:
-            order = await create_order_from_storage_data(order_details, exchange_manager, pending_groups)
-            logger.debug(f"Restored order from storage: {order}")
-        except Exception as err:
-            logger.exception(err, True, f"Error when restoring virtual order order using stored data: {err}")
-
-
 async def create_missing_self_managed_orders_from_storage_order_groups(pending_groups, exchange_manager):
     # create order groups' associated self-managed orders if any
     to_complete_groups = list(pending_groups.keys())
     completed_groups = set()
     max_allowed_nested_chained_orders_groups = 100
     # Loop as created self_managed orders might carry chained orders
     # themselves linked to a group with self-managed orders.
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/cancel_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/cancel_order_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,28 +18,26 @@
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 import octobot_trading.personal_data.orders.order_state as order_state
 import octobot_trading.personal_data.orders.states.order_state_factory as order_state_factory
 
 
 class CancelOrderState(order_state.OrderState):
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True):
-        super().__init__(
-            order, is_from_exchange_data, enable_associated_orders_creation=enable_associated_orders_creation
-        )
+    def __init__(self, order, is_from_exchange_data):
+        super().__init__(order, is_from_exchange_data)
         self.state = enums.OrderStates.CANCELING \
             if ((not self.order.simulated and not self.is_status_cancelled()) or self.is_status_pending()) \
             else enums.OrderStates.CANCELED
 
     async def initialize_impl(self, forced=False, ignored_order=None) -> None:
         if forced:
             self.state = enums.OrderStates.CANCELED
             self.order.status = enums.OrderStatus.CANCELED
 
-        if self.order.order_group and self.enable_associated_orders_creation:
+        if self.order.order_group:
             await self.order.order_group.on_cancel(self.order, ignored_orders=[ignored_order])
 
         await super().initialize_impl()
 
     def is_pending(self) -> bool:
         return self.state is enums.OrderStates.CANCELING
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/close_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/close_order_state.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,18 +14,16 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.order_state as order_state
 
 
 class CloseOrderState(order_state.OrderState):
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True, force_close=True):
-        super().__init__(
-            order, is_from_exchange_data, enable_associated_orders_creation=enable_associated_orders_creation
-        )
+    def __init__(self, order, is_from_exchange_data, force_close=True):
+        super().__init__(order, is_from_exchange_data)
         self.state = enums.States.CLOSED if is_from_exchange_data or force_close or self.order.simulated \
             else enums.States.CLOSING
 
     async def initialize_impl(self, forced=False) -> None:
         if forced:
             self.state = enums.States.CLOSED
         return await super().initialize_impl()
@@ -36,33 +34,29 @@
     def is_closed(self) -> bool:
         return self.state is enums.States.CLOSED
 
     async def on_refresh_successful(self):
         """
         Verify the order is properly closed
         """
-        if self.order is None or self.order.is_cleared():
-            self.get_logger().debug("Skipping on_refresh_successful as order is cleared")
-            return
         if self.order.status is enums.OrderStatus.CLOSED:
             self.state = enums.States.CLOSED
             await self.update()
 
     async def terminate(self):
         """
         Handle order to trade conversion
         """
         try:
             self.log_event_message(enums.StatesMessages.CLOSED)
 
             # add to trade history and notify
             self.ensure_not_cleared(self.order)
             await self.order.exchange_manager.exchange_personal_data.handle_trade_instance_update(
-                self.order.trader.convert_order_to_trade(self.order)
-            )
+                self.order.trader.convert_order_to_trade(self.order))
 
             # remove order from open_orders
             self.order.exchange_manager.exchange_personal_data.orders_manager.remove_order_instance(self.order)
         except Exception as e:
             self.get_logger().exception(e, True, f"Fail to execute close state termination : {e}.")
             raise
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/fill_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/fill_order_state.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,18 +17,16 @@
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.order_state as order_state
 import octobot_trading.personal_data.orders.order_util as order_util
 import octobot_trading.personal_data.orders.states.order_state_factory as order_state_factory
 
 
 class FillOrderState(order_state.OrderState):
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True):
-        super().__init__(
-            order, is_from_exchange_data, enable_associated_orders_creation=enable_associated_orders_creation
-        )
+    def __init__(self, order, is_from_exchange_data):
+        super().__init__(order, is_from_exchange_data)
         self.state = enums.OrderStates.FILLING \
             if ((
                     (not self.order.simulated and not self.order.is_self_managed())
                     and not self.is_status_filled()
                 ) or self.is_status_pending()) \
             else enums.OrderStates.FILLED
 
@@ -77,38 +75,33 @@
     async def terminate(self):
         """
         Perform order filling updates
         Replace the order state by a close state
         `force_close = True` because we know that the order is successfully filled.
         """
         try:
-            self.ensure_not_cleared(self.order)
-
             self.log_event_message(enums.StatesMessages.FILLED)
 
             # call filling actions
             self.order.on_fill_actions()
-            
-            self.ensure_not_cleared(self.order)
 
             # set executed time
             self.order.executed_time = self.order.generate_executed_time()
-            
+
             # compute trading fees
             try:
                 if self.order.exchange_manager is not None and not self.order.has_exchange_fetched_fees():
                     self.order.fee = self.order.get_computed_fee()
             except KeyError:
                 self.get_logger().error(f"Fail to compute trading fees for {self.order}.")
 
-            async with order_util.ensure_orders_relevancy(
-                order=self.order, enable_associated_orders_creation=self.enable_associated_orders_creation
-            ):
+            self.ensure_not_cleared(self.order)
+            async with order_util.ensure_orders_relevancy(order=self.order):
                 # Trigger order group
-                if self.order.order_group and self.enable_associated_orders_creation:
+                if self.order.order_group:
                     await self.order.order_group.on_fill(self.order)
 
                 # always make sure this order has not been cleared when the is a risk to avoid AttributeError
                 self.ensure_not_cleared(self.order)
                 # update portfolio with filled order and position if any
                 async with self.order.exchange_manager.exchange_personal_data.portfolio_manager.portfolio.lock:
                     self.ensure_not_cleared(self.order)
@@ -117,14 +110,14 @@
 
                 # notify order filled
                 await self.order.exchange_manager.exchange_personal_data.handle_order_update_notification(
                     self.order, enums.OrderUpdateType.STATE_CHANGE
                 )
 
                 # call order on_filled callback
-                await self.order.on_filled(self.enable_associated_orders_creation)
+                await self.order.on_filled()
 
             # set close state
             await self.order.on_close(force_close=True)  # TODO force ?
         except Exception as e:
             self.get_logger().exception(e, True, f"Fail to execute fill state termination : {e}.")
             raise
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/open_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/open_order_state.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,18 +17,16 @@
 
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.order_state as order_state
 import octobot_trading.personal_data.orders.states.order_state_factory as order_state_factory
 
 
 class OpenOrderState(order_state.OrderState):
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True):
-        super().__init__(
-            order, is_from_exchange_data, enable_associated_orders_creation=enable_associated_orders_creation
-        )
+    def __init__(self, order, is_from_exchange_data):
+        super().__init__(order, is_from_exchange_data)
         self.state = enums.States.OPEN if \
             is_from_exchange_data \
             or self.order.simulated \
             or self.order.is_self_managed() \
             or self.order.status is enums.OrderStatus.OPEN \
             else enums.States.OPENING
 
@@ -61,15 +59,15 @@
     async def on_refresh_successful(self):
         """
         Verify the order is properly created and still OrderStatus.OPEN
         """
         # skip refresh process if the current order state is not the same as the one triggering this
         # on_refresh_successful to avoid synchronization issues (state already got refreshed by another mean)
         if self.order is None:
-            self.get_logger().debug(f"on_refresh_successful triggered on cleared order: ignoring update.")
+            self.get_logger().warning(f"on_refresh_successful triggered on cleared order: ignoring update.")
         elif self.state is self.order.state.state:
             if self.order.status is enums.OrderStatus.OPEN:
                 self.state = enums.States.OPEN
                 await self.update()
             else:
                 if self.order.status is enums.OrderStatus.CLOSED:
                     self.order.status = enums.OrderStatus.FILLED
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/order_state_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/order_state_factory.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,33 +13,22 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 
 
-async def create_order_state(
-    order, is_from_exchange_data=False, enable_associated_orders_creation=True, ignore_states=None
-):
+async def create_order_state(order, is_from_exchange_data=False, ignore_states=None):
     if ignore_states is None:
         ignore_states = []
 
     if order.status is enums.OrderStatus.PENDING_CREATION \
        and enums.States.PENDING_CREATION not in ignore_states:
-        await order.on_pending_creation(enable_associated_orders_creation=enable_associated_orders_creation)
+        await order.on_pending_creation()
     elif order.status is enums.OrderStatus.OPEN and enums.States.OPEN not in ignore_states:
-        await order.on_open(
-            force_open=False, is_from_exchange_data=is_from_exchange_data,
-            enable_associated_orders_creation=enable_associated_orders_creation
-        )
+        await order.on_open(force_open=False, is_from_exchange_data=is_from_exchange_data)
     elif order.status in constants.FILL_ORDER_STATUS_SCOPE \
             and enums.OrderStates.FILLED not in ignore_states \
             and enums.States.CLOSED not in ignore_states:
-        await order.on_fill(
-            force_fill=False, is_from_exchange_data=is_from_exchange_data,
-            enable_associated_orders_creation=enable_associated_orders_creation
-        )
+        await order.on_fill(force_fill=False, is_from_exchange_data=is_from_exchange_data)
     elif order.status in constants.CANCEL_ORDER_STATUS_SCOPE and enums.OrderStates.CANCELED not in ignore_states:
-        await order.on_cancel(
-            force_cancel=False, is_from_exchange_data=is_from_exchange_data,
-            enable_associated_orders_creation=enable_associated_orders_creation
-        )
+        await order.on_cancel(force_cancel=False, is_from_exchange_data=is_from_exchange_data)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/pending_creation_chained_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/states/pending_creation_order_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/states/pending_creation_order_state.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,18 +21,16 @@
 import octobot_trading.errors
 import octobot_trading.exchange_channel as exchange_channel
 import octobot_trading.personal_data.orders.order_state as order_state
 
 
 class PendingCreationOrderState(order_state.OrderState):
 
-    def __init__(self, order, is_from_exchange_data, enable_associated_orders_creation=True):
-        super().__init__(
-            order, is_from_exchange_data, enable_associated_orders_creation=enable_associated_orders_creation
-        )
+    def __init__(self, order, is_from_exchange_data):
+        super().__init__(order, is_from_exchange_data)
         self.state = enums.States.PENDING_CREATION
 
     async def _synchronize_with_exchange(self, force_synchronization: bool = False) -> None:
         """
         Ask OrdersChannel Internal producer to refresh the order from the exchange
         :param force_synchronization: When True, for the update of the order from the exchange
         :return: the result of OrdersProducer.update_order_from_exchange()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/buy_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/sell_limit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/buy_market_order.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,14 +10,13 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.enums as enums
-import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
+import octobot_trading.personal_data.orders.types.market.market_order as market_order
 
 
-class SellLimitOrder(limit_order.LimitOrder):
-    def __init__(self, trader, side=enums.TradeOrderSide.SELL):
-        super().__init__(trader, side)
-
+class BuyMarketOrder(market_order.MarketOrder):
+    def __init__(self, trader, side=None):
+        super().__init__(trader, side=enums.TradeOrderSide.BUY)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,33 +15,25 @@
 #  License along with this library.
 import decimal
 
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
 
 
-class StopLossLimitOrder(limit_order.LimitOrder):
-    # TO CHECK: is it used anywhere ?
+class TakeProfitLimitOrder(limit_order.LimitOrder):
     UNINITIALIZED_LIMIT_PRICE = decimal.Decimal("-1")
 
     def __init__(self, trader, side=enums.TradeOrderSide.SELL, limit_price=UNINITIALIZED_LIMIT_PRICE):
         super().__init__(trader, side)
-        self.trigger_above = False
         self.limit_price = limit_price
 
-    def is_counted_in_available_funds(self):
-        return False
-
-    async def update_price_if_outdated(self):
-        pass
-
-    async def on_filled(self, enable_associated_orders_creation):
-        await limit_order.LimitOrder.on_filled(self, enable_associated_orders_creation)
+    async def on_filled(self):
+        await limit_order.LimitOrder.on_filled(self)
         # TODO replace with chained order ?
-        await self.trader.create_artificial_order(enums.TraderOrderType.SELL_MARKET
+        await self.trader.create_artificial_order(enums.TraderOrderType.SELL_LIMIT
                                                   if self.side is enums.TradeOrderSide.SELL
-                                                  else enums.TraderOrderType.BUY_MARKET,
+                                                  else enums.TraderOrderType.BUY_LIMIT,
                                                   self.symbol, self.origin_stop_price,
                                                   self.origin_quantity,
                                                   self.limit_price
                                                   if self.limit_price != self.UNINITIALIZED_LIMIT_PRICE else
                                                   self.origin_stop_price)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/stop_loss_order.py`

 * *Files 6% similar despite different names*

```diff
@@ -21,23 +21,20 @@
     def __init__(self, trader, side=enums.TradeOrderSide.SELL):
         super().__init__(trader, side)
         self.trigger_above = self.side is enums.TradeOrderSide.BUY
 
     def is_counted_in_available_funds(self):
         return False
 
-    async def update_price_if_outdated(self):
-        pass
-
     def _filled_maker_or_taker(self):
         # Creates a market order when filled, which is taker
         return enums.ExchangeConstantsMarketPropertyColumns.TAKER.value
 
-    async def on_filled(self, enable_associated_orders_creation):
-        await limit_order.LimitOrder.on_filled(self, enable_associated_orders_creation)
+    async def on_filled(self):
+        await limit_order.LimitOrder.on_filled(self)
         if not self.trader.simulate and self.is_self_managed():
             # TODO replace with chained order ?
             await self.trader.create_artificial_order(enums.TraderOrderType.SELL_MARKET
                                                       if self.side is enums.TradeOrderSide.SELL
                                                       else enums.TraderOrderType.BUY_MARKET,
                                                       self.symbol, self.origin_stop_price,
                                                       self.origin_quantity, self.origin_stop_price)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/take_profit_limit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/stop_loss_limit_order.py`

 * *Files 11% similar despite different names*

```diff
@@ -15,28 +15,30 @@
 #  License along with this library.
 import decimal
 
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.types.limit.limit_order as limit_order
 
 
-class TakeProfitLimitOrder(limit_order.LimitOrder):
+class StopLossLimitOrder(limit_order.LimitOrder):
+    # TO CHECK: is it used anywhere ?
     UNINITIALIZED_LIMIT_PRICE = decimal.Decimal("-1")
 
     def __init__(self, trader, side=enums.TradeOrderSide.SELL, limit_price=UNINITIALIZED_LIMIT_PRICE):
         super().__init__(trader, side)
+        self.trigger_above = False
         self.limit_price = limit_price
 
-    async def update_price_if_outdated(self):
-        pass
+    def is_counted_in_available_funds(self):
+        return False
 
-    async def on_filled(self, enable_associated_orders_creation):
-        await limit_order.LimitOrder.on_filled(self, enable_associated_orders_creation)
+    async def on_filled(self):
+        await limit_order.LimitOrder.on_filled(self)
         # TODO replace with chained order ?
-        await self.trader.create_artificial_order(enums.TraderOrderType.SELL_LIMIT
+        await self.trader.create_artificial_order(enums.TraderOrderType.SELL_MARKET
                                                   if self.side is enums.TradeOrderSide.SELL
-                                                  else enums.TraderOrderType.BUY_LIMIT,
+                                                  else enums.TraderOrderType.BUY_MARKET,
                                                   self.symbol, self.origin_stop_price,
                                                   self.origin_quantity,
                                                   self.limit_price
                                                   if self.limit_price != self.UNINITIALIZED_LIMIT_PRICE else
                                                   self.origin_stop_price)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/limit/take_profit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/limit/take_profit_order.py`

 * *Files 8% similar despite different names*

```diff
@@ -21,23 +21,20 @@
     def __init__(self, trader, side=enums.TradeOrderSide.SELL):
         super().__init__(trader, side)
         self.trigger_above = self.side is enums.TradeOrderSide.SELL
 
     def is_counted_in_available_funds(self):
         return False
 
-    async def update_price_if_outdated(self):
-        pass
-
     def _filled_maker_or_taker(self):
         # Creates a market order when filled, which is taker
         return enums.ExchangeConstantsMarketPropertyColumns.TAKER.value
 
-    async def on_filled(self, enable_associated_orders_creation):
-        await limit_order.LimitOrder.on_filled(self, enable_associated_orders_creation)
+    async def on_filled(self):
+        await limit_order.LimitOrder.on_filled(self)
         if not self.trader.simulate and self.is_self_managed():
             # TODO replace with chained order ?
             await self.trader.create_artificial_order(enums.TraderOrderType.SELL_MARKET
                                                       if self.side is enums.TradeOrderSide.SELL
                                                       else enums.TraderOrderType.BUY_MARKET,
                                                       self.symbol, self.origin_stop_price,
                                                       self.origin_quantity, self.origin_stop_price)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/buy_market_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/sell_market_order.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,10 +13,10 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.enums as enums
 import octobot_trading.personal_data.orders.types.market.market_order as market_order
 
 
-class BuyMarketOrder(market_order.MarketOrder):
+class SellMarketOrder(market_order.MarketOrder):
     def __init__(self, trader, side=None):
-        super().__init__(trader, side=enums.TradeOrderSide.BUY)
+        super().__init__(trader, side=enums.TradeOrderSide.SELL)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/market_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/market/market_order.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,15 +26,17 @@
             # # In trading simulation wait for the next asyncio loop iteration to ensure this order status
             # # is updated before leaving this method
             # await asyncio_tools.wait_asyncio_next_cycle()
 
     def on_fill_actions(self):
         self.taker_or_maker = enums.ExchangeConstantsMarketPropertyColumns.TAKER.value
         self.origin_price = self.created_last_price
-        self.update_order_filled_values(self.created_last_price)
+        self.filled_price = self.created_last_price
+        self.filled_quantity = self.origin_quantity
+        self._update_total_cost()
         order_class.Order.on_fill_actions(self)
 
     def can_be_edited(self):
         # instantly filled orders can't be edited
         return False
 
     def use_current_price_as_origin_price(self):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/market/sell_market_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,14 +9,10 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import octobot_trading.enums as enums
-import octobot_trading.personal_data.orders.types.market.market_order as market_order
 
-
-class SellMarketOrder(market_order.MarketOrder):
-    def __init__(self, trader, side=None):
-        super().__init__(trader, side=enums.TradeOrderSide.SELL)
+PROJECT_NAME = "OctoBot-Trading"
+VERSION = "2.4.9"  # major.minor.revision
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/trailing_stop_limit_order.py`

 * *Files 13% similar despite different names*

```diff
@@ -21,16 +21,16 @@
     UNINITIALIZED_LIMIT_PRICE = -1
 
     def __init__(self, trader, side=enums.TradeOrderSide.SELL, limit_price=UNINITIALIZED_LIMIT_PRICE):
         super().__init__(trader, side)
         self.order_type = enums.TraderOrderType.TRAILING_STOP_LIMIT
         self.limit_price = limit_price
 
-    async def on_filled(self, enable_associated_orders_creation):
-        await trailing_stop_order.TrailingStopOrder.on_filled(self, enable_associated_orders_creation)
+    async def on_filled(self):
+        await trailing_stop_order.TrailingStopOrder.on_filled(self)
         # TODO replace with chained order ?
         await self.trader.create_artificial_order(enums.TraderOrderType.SELL_LIMIT
                                                   if self.side is enums.TradeOrderSide.SELL else enums.TraderOrderType.BUY_LIMIT,
                                                   self.symbol, self.origin_stop_price,
                                                   self.origin_quantity,
                                                   self.limit_price
                                                   if self.limit_price != self.UNINITIALIZED_LIMIT_PRICE else
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/trailing/trailing_stop_order.py`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
         super().__init__(trader, side=side)
         self.order_type = enums.TraderOrderType.TRAILING_STOP
         self.trailing_stop_price_hit_event = None
         self.trailing_price_hit_event = None
         self.wait_for_stop_price_hit_event_task = None
         self.wait_for_price_hit_event_task = None
         self.trailing_percent = trailing_percent
-        self.allow_instant_fill = constants.ALLOW_SIMULATED_ORDERS_INSTANT_FILL
+        self.allow_instant_fill = True
 
     async def update_order_status(self, force_refresh=False):
         if not self.trader.simulate and (not self.is_synchronized_with_exchange or force_refresh):
             await self.default_exchange_update_order_status()
         await self._reset_events(self.origin_price, self.creation_time)
 
     async def set_trailing_percent(self, trailing_percent):
@@ -139,19 +139,19 @@
         """
         prices_manager = self.exchange_manager.exchange_symbols_data. \
             get_exchange_symbol_data(self.symbol).prices_manager
         logging.get_logger(self.get_logger_name()).debug(f"New price hit {prices_manager.mark_price}, "
                                                          f"replacing stop...")
         await self._reset_events(decimal.Decimal(str(prices_manager.mark_price)), prices_manager.mark_price_set_time)
 
-    async def on_filled(self, enable_associated_orders_creation):
+    async def on_filled(self):
         """
         Create an artificial when trailing stop is filled
         """
-        await order_class.Order.on_filled(self, enable_associated_orders_creation)
+        await order_class.Order.on_filled(self)
         # TODO replace with chained order ?
         await self.trader.create_artificial_order(enums.TraderOrderType.SELL_MARKET
                                                   if self.side is enums.TradeOrderSide.SELL
                                                   else enums.TraderOrderType.BUY_MARKET,
                                                   self.symbol, self.origin_stop_price,
                                                   self.origin_quantity, self.origin_stop_price)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/unknown_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/unknown_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/orders/types/unsupported_order.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/orders/types/unsupported_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -76,15 +76,14 @@
 from octobot_trading.personal_data.portfolios.portfolio_util import (
     parse_decimal_portfolio,
     parse_decimal_config_portfolio,
     filter_empty_values,
     portfolio_to_float,
     get_draw_down,
     get_coefficient_of_determination,
-    get_asset_price_from_converter_or_tickers,
 )
 from octobot_trading.personal_data.portfolios.history import (
     create_historical_asset_value_from_dict_like_object,
     HistoricalAssetValue,
     HistoricalPortfolioValueManager,
 )
 
@@ -113,13 +112,12 @@
     "SpotAsset",
     "parse_decimal_portfolio",
     "parse_decimal_config_portfolio",
     "filter_empty_values",
     "portfolio_to_float",
     "get_draw_down",
     "get_coefficient_of_determination",
-    "get_asset_price_from_converter_or_tickers",
     "create_historical_asset_value_from_dict_like_object",
     "get_draw_down",
     "HistoricalAssetValue",
     "HistoricalPortfolioValueManager",
 ]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/asset.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/future_asset.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/future_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/margin_asset.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/margin_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/assets/spot_asset.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/assets/spot_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance_updater.py`

 * *Files 3% similar despite different names*

```diff
@@ -53,21 +53,16 @@
                 # avoid spamming on disconnected situation
                 await asyncio.sleep(constants.DEFAULT_FAILED_REQUEST_RETRY_TIME)
             except errors.NotSupported:
                 self.logger.warning(
                     f"{self.channel.exchange_manager.exchange_name} is not supporting updates"
                 )
                 await self.pause()
-            except errors.AuthenticationError as err:
-                self.logger.exception(
-                    err, True, f"Authentication error when fetching balance: {err}. Retrying in the next update cycle"
-                )
-                await asyncio.sleep(self.BALANCE_REFRESH_TIME)
             except Exception as e:
-                self.logger.exception(e, True, f"Failed to update balance : {e}")
+                self.logger.error(f"Failed to update balance : {e}")
 
     async def fetch_and_push(self):
         await self.push((await self.fetch_portfolio()))
 
     async def fetch_portfolio(self):
         """
         Fetch portfolio from exchange
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/channel/balance_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_asset_value.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_asset_value.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_asset_value_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/history/historical_portfolio_value_manager.py`

 * *Files 4% similar despite different names*

```diff
@@ -57,39 +57,29 @@
                                          f"[{self.portfolio_manager.exchange_manager.exchange_name}]")
         self.saved_time_frames = self.portfolio_manager.exchange_manager.config.get(
             commons_constants.CONFIG_SAVED_HISTORICAL_TIMEFRAMES,
             constants.DEFAULT_SAVED_HISTORICAL_TIMEFRAMES
         )
         self.data_source = data_source or self.__class__.DEFAULT_DATA_SOURCE
         self.version = version or self.__class__.DEFAULT_DATA_VERSION
-        try:
-            self.starting_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
-        except AttributeError:
-            if self.portfolio_manager.exchange_manager.is_backtesting and \
-               not self.portfolio_manager.exchange_manager.exchange.connector.exchange_importers:
-                # Can happen on backtesting without datafiles (used in particular setups). Only this case is acceptable
-                self.starting_time = 0
-            else:
-                raise
+        self.starting_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
         self.last_update_time = self.starting_time
         self.starting_portfolio = None
         self.historical_ending_portfolio = None
         self.historical_starting_portfolio_values = {}
         self.ending_portfolio = None
 
         self.max_history_size = self.__class__.MAX_HISTORY_SIZE
         self.historical_portfolio_value = sortedcontainers.SortedDict()
 
     async def initialize_impl(self):
         """
         Reset the portfolio instance
         """
-        # don't load any previous portfolio value on backtesting
-        if not self.portfolio_manager.exchange_manager.is_backtesting:
-            await self._reload_historical_portfolio_value()
+        await self._reload_historical_portfolio_value()
 
     async def reset_history(self):
         self.starting_time = self.portfolio_manager.exchange_manager.exchange.get_exchange_current_time()
         self.last_update_time = self.starting_time
         self.starting_portfolio = None
         self.ending_portfolio = None
         self.historical_portfolio_value = sortedcontainers.SortedDict()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio.py`

 * *Files 0% similar despite different names*

```diff
@@ -132,15 +132,15 @@
         """
         raise NotImplementedError("update_portfolio_data_from_withdrawal is not implemented")
 
     def update_portfolio_available_from_order(self, order, is_new_order=True):
         """
         Realize portfolio availability update
         :param order: the order that triggers the portfolio update
-        :param is_new_order: True when the order is being created, False when cancelled
+        :param is_new_order: True when the order is being created
         """
         raise NotImplementedError("update_portfolio_available_from_order is not implemented")
 
     def update_portfolio_from_filled_order(self, order):
         """
         update_portfolio performs the update of the total / available quantity of a currency
         It is called only when an order is filled to update the real quantity of the currency to be set in "total" field
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,23 +42,21 @@
         self.portfolio = None
         self.portfolio_profitability = None
         self.portfolio_value_holder = None
         self.historical_portfolio_value_manager = None
         self.reference_market = None
         self._is_initialized_event_set = False
         self._forced_portfolio = None
-        self._enable_portfolio_update_from_order = True
 
     async def initialize_impl(self):
         """
         Reset the portfolio instance
         """
 
-        if (self.exchange_manager.is_storage_enabled() or self.exchange_manager.is_backtesting) \
-                and self.historical_portfolio_value_manager is None:
+        if self.exchange_manager.is_storage_enabled() and self.historical_portfolio_value_manager is None:
             self.historical_portfolio_value_manager = personal_data.HistoricalPortfolioValueManager(self)
             await self.historical_portfolio_value_manager.initialize()
         self.set_forced_portfolio_initial_config(
             self.config[commons_constants.CONFIG_SIMULATOR][commons_constants.CONFIG_STARTING_PORTFOLIO]
         )
         self._reset_portfolio()
 
@@ -81,15 +79,15 @@
         """
         Handle a balance update from an order update
         :param order: the order
         :param require_exchange_update: when True, will sync with exchange portfolio, otherwise will predict the
         portfolio changes using order data (as in trading simulator)
         :return: True if the portfolio was updated
         """
-        if self.trader.is_enabled and self._enable_portfolio_update_from_order:
+        if self.trader.is_enabled:
             async with self.portfolio_history_update():
                 if self.trader.simulate or not require_exchange_update:
                     return self._refresh_simulated_trader_portfolio_from_order(order)
                 # on real trading only:
                 # reload portfolio to ensure portfolio sync
                 return await self._refresh_real_trader_portfolio()
         return False
@@ -178,15 +176,15 @@
         try:
             yield
         finally:
             if self.historical_portfolio_value_manager is not None:
                 try:
                     await self.historical_portfolio_value_manager.on_portfolio_update()
                 except Exception as err:
-                    self.logger.exception(err, True, f"Error when updating portfolio history: {err}")
+                    self.logger.exception(f"Error when updating portfolio history: {err}")
 
     def handle_profitability_recalculation(self, force_recompute_origin_portfolio):
         """
         Called before PortfolioProfitability's portfolio profitability recalculation
         to ensure portfolio values are available
         :param force_recompute_origin_portfolio: when True, force origin portfolio computation
         """
@@ -199,25 +197,14 @@
         :param mark_price: the updated mark price in Decimal
         :return: True if profitability changed
         """
         return self.portfolio_profitability. \
             update_profitability(force_recompute_origin_portfolio=self.portfolio_value_holder.
                                  update_origin_crypto_currencies_values(symbol, mark_price))
 
-    @contextlib.contextmanager
-    def disabled_portfolio_update_from_order(self):
-        """
-        Can be used to locally disable portfolio refresh when an order is updated
-        """
-        self._enable_portfolio_update_from_order = False
-        try:
-            yield
-        finally:
-            self._enable_portfolio_update_from_order = True
-
     async def _refresh_real_trader_portfolio(self) -> bool:
         """
         Call BALANCE_CHANNEL producer to refresh real trader portfolio
         :return: True if the portfolio was updated
         """
         return await exchange_channel.get_chan(
             constants.BALANCE_CHANNEL, self.exchange_manager.id
@@ -262,15 +249,14 @@
         :param order: the order that should update portfolio
         :return: True if the portfolio was updated
         """
         try:
             if order.is_filled():
                 self.portfolio.update_portfolio_from_filled_order(order)
             else:
-                # order cancelled
                 self.portfolio.update_portfolio_available(order, is_new_order=False)
             return True
         except errors.PortfolioNegativeValueError as portfolio_negative_value_error:
             self.logger.exception(portfolio_negative_value_error, True,
                                   f"Failed to update portfolio : {portfolio_negative_value_error} "
                                   f"for order {order.to_dict()}")
         return False
@@ -292,18 +278,14 @@
     def _load_simulated_portfolio_from_history(self):
         portfolio_amount_dict = personal_data.parse_decimal_config_portfolio(
             {
                 symbol: value
                 for symbol, value in self.historical_portfolio_value_manager.historical_ending_portfolio.items()
             }
         )
-        for asset_dict in portfolio_amount_dict.values():
-            # ignore loaded available value as simulated orders are not kept throughout instance
-            # and therefore can't lock funds
-            asset_dict[commons_constants.PORTFOLIO_AVAILABLE] = asset_dict[commons_constants.PORTFOLIO_TOTAL]
         self.handle_balance_update(self.portfolio.get_portfolio_from_amount_dict(portfolio_amount_dict))
 
     def set_forced_portfolio_initial_config(self, portfolio_config):
         forced_portfolio_initial_config = copy.deepcopy(portfolio_config)
         # ensure free and total amounts are present
         for key in list(forced_portfolio_initial_config):
             if not isinstance(forced_portfolio_initial_config[key], dict):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_profitability.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_profitability.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,16 +11,14 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_commons.logging as logging
 import octobot_commons.symbols as symbol_util
-import octobot_commons.tree as commons_tree
-import octobot_commons.enums as commons_enums
 
 import octobot_trading.util as util
 import octobot_trading.constants as constants
 
 
 class PortfolioProfitability:
     """
@@ -64,33 +62,22 @@
         """
         Get profitability calls get_currencies_prices to update required data
         Then calls get_portfolio_current_value to set the current value of portfolio_current_value attribute
         :return: True if changed else False
         """
         self._reset_before_profitability_calculation()
         try:
-            set_init_event = self.portfolio_manager.portfolio_value_holder.portfolio_current_value == constants.ZERO
             self.portfolio_manager.handle_profitability_recalculation(force_recompute_origin_portfolio)
             self._update_profitability_calculation()
-            if set_init_event:
-                self._set_initialized_event()
             return self.profitability_diff != constants.ZERO
         except KeyError as missing_data_exception:
             self.logger.warning(f"Missing {missing_data_exception} ticker data to calculate profitability")
         except Exception as missing_data_exception:
             self.logger.exception(missing_data_exception, True, str(missing_data_exception))
 
-    def _set_initialized_event(self):
-        commons_tree.EventProvider.instance().trigger_event(
-            self.portfolio_manager.exchange_manager.bot_id, commons_tree.get_exchange_path(
-                self.portfolio_manager.exchange_manager.exchange_name,
-                commons_enums.InitializationEventExchangeTopics.PROFITABILITY.value
-            )
-        )
-
     def _reset_before_profitability_calculation(self):
         """
         Prepare profitability calculation
         """
         self.profitability_diff = self.profitability_percent
         self.profitability = constants.ZERO
         self.profitability_percent = constants.ZERO
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_util.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,37 +10,32 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
-
 import octobot_trading.personal_data.portfolios.asset as asset
 import octobot_trading.constants as constants
 import octobot_trading.enums as enums
-import octobot_trading.errors as errors
-
 import octobot_commons.constants as commons_constants
 import octobot_commons.logging as commons_logging
 import octobot_commons.symbols as symbol_util
-
 import numpy as numpy
 
 
-def parse_decimal_portfolio(portfolio, as_decimal=True):
+def parse_decimal_portfolio(portfolio):
     decimal_portfolio = {}
     for symbol, symbol_balance in portfolio.items():
         if isinstance(symbol_balance, dict):
             decimal_portfolio[symbol] = {}
             portfolio_to_fill = decimal_portfolio[symbol]
             for balance_type, balance_val in symbol_balance.items():
                 if isinstance(balance_val, (int, float, decimal.Decimal)):
-                    portfolio_to_fill[balance_type] = decimal.Decimal(str(balance_val)) \
-                        if as_decimal else float(balance_val)
+                    portfolio_to_fill[balance_type] = decimal.Decimal(str(balance_val))
     return decimal_portfolio
 
 
 def parse_decimal_config_portfolio(portfolio):
     return {
         symbol: {k: decimal.Decimal(str(v)) for k, v in symbol_balance.items()} if isinstance(symbol_balance, dict)
         else decimal.Decimal(str(symbol_balance))
@@ -197,31 +192,7 @@
     if pnl_data:
         # calculate r
         corr_matrix = numpy.corrcoef(best_case, pnl_data)
         corr = corr_matrix[0, 1]
         coefficient_of_determination = corr ** 2
 
     return round(coefficient_of_determination, 3)
-
-
-def get_asset_price_from_converter_or_tickers(
-    exchange_manager, to_convert_asset: str, target_asset: str, symbol: str, tickers: dict
-):
-    # 1. try with converter
-    try:
-        price = exchange_manager.exchange_personal_data.portfolio_manager. \
-            portfolio_value_holder.value_converter.evaluate_value(
-                to_convert_asset, constants.ONE, raise_error=True,
-                target_currency=target_asset, init_price_fetchers=False
-            )
-        if price == constants.ZERO:
-            raise errors.MissingPriceDataError
-    except errors.MissingPriceDataError:
-        # 2. try with tickers
-        try:
-            price = decimal.Decimal(str(
-                tickers[symbol][enums.ExchangeConstantsTickersColumns.CLOSE.value]
-                or tickers[symbol][enums.ExchangeConstantsTickersColumns.PREVIOUS_CLOSE.value]
-            ))
-        except KeyError:
-            price = None
-    return price
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/portfolio_value_holder.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/portfolio_value_holder.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 import copy
 
 import octobot_commons.logging as logging
 import octobot_commons.symbols as symbol_util
 
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
-import octobot_trading.enums as enums
 import octobot_trading.personal_data.portfolios.value_converter as value_converter
 
 
 class PortfolioValueHolder:
     """
     PortfolioValueHolder calculates the current and the origin portfolio value in reference market for each updates
     """
@@ -113,59 +112,25 @@
         """
         holdings = self.get_current_crypto_currencies_values()
         return {
             currency: self._get_currency_value(self.portfolio_manager.portfolio.portfolio, currency, holdings)
             for currency in holdings.keys()
         }
 
-    def get_assets_holdings_value(self, assets, target_unit, init_price_fetchers=False):
-        total_value = constants.ZERO
-        for asset, asset_holdings in self.portfolio_manager.portfolio.portfolio.items():
-            if asset not in assets:
-                continue
-            try:
-                total_value += self.value_converter.evaluate_value(
-                    asset, asset_holdings.total, raise_error=True,
-                    target_currency=target_unit, init_price_fetchers=init_price_fetchers
-                )
-            except errors.MissingPriceDataError:
-                self.logger.info(f"Missing {asset} price conversion, ignoring {float(asset_holdings.total)} holdings.")
-        return total_value
-
-    def get_traded_assets_holdings_value(self, unit):
-        assets = set()
-        for symbol in self.portfolio_manager.exchange_manager.exchange_config.traded_symbols:
-            assets.add(symbol.base)
-            assets.add(symbol.quote)
-        return self.get_assets_holdings_value(
-            assets, unit
-        )
-
-    def get_holdings_ratio(self, currency, traded_symbols_only=False, include_assets_in_open_orders=False):
-        if traded_symbols_only:
-            total_holdings_value = self.get_traded_assets_holdings_value(self.portfolio_manager.reference_market)
-        else:
-            # consider all assets for total_holdings_value
-            total_holdings_value = self.portfolio_current_value
-        if not total_holdings_value:
-            return constants.ZERO
-        currency_holdings = self.portfolio_manager.portfolio.get_currency_portfolio(currency).total
-        if include_assets_in_open_orders:
-            # add assets in open orders to currency_holdings
-            assets_in_open_orders = constants.ZERO
-            for order in self.portfolio_manager.exchange_manager.exchange_personal_data.orders_manager.get_open_orders():
-                symbol = symbol_util.parse_symbol(order.symbol)
-                if order.side is enums.TradeOrderSide.BUY and symbol.base == currency:
-                    assets_in_open_orders += order.origin_quantity
-                elif order.side is enums.TradeOrderSide.SELL and symbol.quote == currency:
-                    assets_in_open_orders += order.total_cost
-            currency_holdings += assets_in_open_orders
-        # compute ratio
-        current_holdings_value = self.value_converter.evaluate_value(currency, currency_holdings)
-        return current_holdings_value / total_holdings_value
+    def get_currency_holding_ratio(self, currency):
+        """
+        Return the holdings ratio for the specified currency
+        :return: the holdings ratio
+        """
+        if self.portfolio_current_value:
+            return self.value_converter.evaluate_value(
+                currency,
+                self.portfolio_manager.portfolio.get_currency_portfolio(currency).total
+            ) / self.portfolio_current_value
+        return constants.ZERO
 
     def handle_profitability_recalculation(self, force_recompute_origin_portfolio):
         """
         Initialize values required by portfolio profitability to perform its profitability calculation
         :param force_recompute_origin_portfolio: when True, force origin portfolio computation
         """
         self._update_portfolio_and_currencies_current_value()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/sub_portfolio.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/sub_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/future_portfolio.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/future_portfolio.py`

 * *Files 3% similar despite different names*

```diff
@@ -124,15 +124,14 @@
             funding_fee = position.value * funding_rate
             # When inverse contract, decrease a currency market equivalent quantity from currency balance
             if position.symbol_contract.is_inverse_contract():
                 self._update_future_portfolio_data(position.currency, wallet_value=-funding_fee)
             # When non-inverse contract, decrease directly market quantity
             else:
                 self._update_future_portfolio_data(position.market, wallet_value=-funding_fee)
-            self.logger.debug(f"Updated position from funding fees ({str(-funding_fee)}) : {position}")
         except (decimal.DivisionByZero, decimal.InvalidOperation) as e:
             self.logger.error(f"Failed to update from funding : {position} ({e})")
 
     def update_portfolio_from_pnl(self, position):
         """
         Updates the portfolio from a Position PNL update
         TODO: manage portfolio PNL update when using cross margin
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/types/margin_portfolio.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/types/margin_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/portfolios/value_converter.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/portfolios/value_converter.py`

 * *Files 14% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 #  License along with this library.
 import asyncio
 import decimal
 
 import octobot_commons.logging as logging
 import octobot_commons.symbols as symbol_util
 import octobot_commons.asyncio_tools as asyncio_tools
-import octobot_commons.constants as commons_constants
 
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
 
 
 class ValueConverter:
     """
@@ -52,125 +51,82 @@
 
     def update_last_price(self, symbol, price):
         if symbol not in self.last_prices_by_trading_pair:
             self.reset_missing_price_bridges()
             self.logger.debug(f"Initialized last price for {symbol}")
         self.last_prices_by_trading_pair[symbol] = price
 
-    def evaluate_value(self, currency, quantity, raise_error=True, target_currency=None, init_price_fetchers=True):
+    def evaluate_value(self, currency, quantity, raise_error=True):
         """
         Evaluate value returns the currency quantity value in the reference (attribute) currency
         :param currency: the currency to evaluate
         :param quantity: the currency quantity
         :param raise_error: will catch exception if False
-        :param target_currency: asset to evaluate currency into, defaults to self.portfolio_manager.reference_market
-        :param init_price_fetchers: will ask for missing ticker if price can't be converted if False
         :return: the currency value
         """
-        target_currency = target_currency or self.portfolio_manager.reference_market
         # easy case --> the current currency is the reference currency or the quantity is 0
-        if currency == target_currency or quantity == constants.ZERO:
+        if currency == self.portfolio_manager.reference_market or quantity == constants.ZERO:
             return quantity
-        currency_value = self._try_get_value_of_currency(
-            currency, quantity, target_currency, raise_error, init_price_fetchers
-        )
+        currency_value = self._try_get_value_of_currency(currency, quantity, raise_error)
         return self._check_currency_initialization(currency, currency_value)
 
-    def get_usd_like_value(self, currency, quantity, raise_error=True, init_price_fetchers=True):
-        if self.is_usd_like_coin(currency):
-            return quantity
-        if symbol := self.get_usd_like_symbol_from_symbols(currency, self.last_prices_by_trading_pair):
-            base, quote = symbol_util.parse_symbol(symbol).base_and_quote()
-            usd_like_currency = base if self.is_usd_like_coin(base) else quote
-            return self.evaluate_value(
-                currency, quantity, raise_error=raise_error,
-                target_currency=usd_like_currency, init_price_fetchers=init_price_fetchers
-            )
-        raise errors.MissingPriceDataError(
-            f"Can't convert {currency} to any of {commons_constants.USD_LIKE_COINS} using last_prices_by_trading_pair: "
-            f"{list(self.last_prices_by_trading_pair)}"
-        )
-
-    @staticmethod
-    def get_usd_like_symbol_from_symbols(currency: str, symbols) -> str:
-        # look for symbols using USD_LIKE_COINS priorities
-        for usd_like_coin in commons_constants.USD_LIKE_COINS:
-            for symbol in symbols:
-                base_and_quote = symbol_util.parse_symbol(symbol).base_and_quote()
-                if currency in base_and_quote and usd_like_coin in base_and_quote:
-                    return symbol
-        return None
-
-    @staticmethod
-    def can_convert_symbol_to_usd_like(symbol: str) -> bool:
-        base, quote = symbol_util.parse_symbol(symbol).base_and_quote()
-        for usd_like_coins in commons_constants.USD_LIKE_COINS:
-            if usd_like_coins == base or usd_like_coins == quote:
-                return True
-        return False
-
-    @staticmethod
-    def is_usd_like_coin(coin) -> bool:
-        return coin in commons_constants.USD_LIKE_COINS
-
     def _check_currency_initialization(self, currency, currency_value):
         """
         Check if the currency has to be removed from self.initializing_symbol_prices and return currency_value
         :param currency: the currency to check
         :param currency_value: the currency value
         :return: currency_value after checking
         """
         if currency_value > constants.ZERO and currency in self.initializing_symbol_prices:
             self.initializing_symbol_prices.remove(currency)
         return currency_value
 
-    def _try_get_value_of_currency(self, currency, quantity, target_currency, raise_error, init_price_fetchers):
+    def _try_get_value_of_currency(self, currency, quantity, raise_error):
         """
         try_get_value_of_currency will try to get the value of the given currency quantity in reference market.
         It will try to get it from a trading pair that fit with the exchange availability.
         :return: the value found of this currency quantity, if not found returns 0.
         """
         settlement_asset = self.portfolio_manager.reference_market \
             if self.portfolio_manager.exchange_manager.is_future else None
         try:
             # 1. try from existing pairs (as is and reversed)
             return self.convert_currency_value_using_last_prices(
                 quantity, currency,
-                target_currency,
+                self.portfolio_manager.reference_market,
                 settlement_asset=settlement_asset
             )
         except errors.MissingPriceDataError as missing_data_exception:
             if not self.portfolio_manager.exchange_manager.is_future:
                 try:
                     # 2. try from existing indirect pairs
                     value = self.try_convert_currency_value_using_multiple_pairs(
-                        currency, target_currency, quantity, []
+                        currency, self.portfolio_manager.reference_market, quantity, []
                     )
                     if value is not None:
                         return value
                 except (errors.MissingPriceDataError, errors.PendingPriceDataError):
                     pass
             symbol = symbol_util.merge_currencies(
-                currency, target_currency, settlement_asset=settlement_asset
+                currency, self.portfolio_manager.reference_market, settlement_asset=settlement_asset
             )
             reversed_symbol = symbol_util.merge_currencies(
-                target_currency, currency, settlement_asset=settlement_asset
+                self.portfolio_manager.reference_market, currency, settlement_asset=settlement_asset
             )
-            if init_price_fetchers:
-                # 3. if the pair or reversed pair is traded on exchange, use it to price "currency"
-                if not any(
-                    self.portfolio_manager.exchange_manager.symbol_exists(s)
-                    for s in (symbol, reversed_symbol)
-                ) and currency not in self.missing_currency_data_in_exchange:
-                    self._inform_no_matching_symbol(currency, target_currency)
-                    self.missing_currency_data_in_exchange.add(currency)
-                if not self.portfolio_manager.exchange_manager.is_backtesting:
-                    self._try_to_ask_ticker_missing_symbol_data(currency, symbol, reversed_symbol)
-            if not self.portfolio_manager.exchange_manager.is_backtesting and raise_error:
-                raise missing_data_exception
+            # 3. if the pair or reversed pair is traded on exchange, use it to price "currency"
+            if not any(
+                self.portfolio_manager.exchange_manager.symbol_exists(s)
+                for s in (symbol, reversed_symbol)
+            ) and currency not in self.missing_currency_data_in_exchange:
+                self._inform_no_matching_symbol(currency)
+                self.missing_currency_data_in_exchange.add(currency)
+            if not self.portfolio_manager.exchange_manager.is_backtesting:
+                self._try_to_ask_ticker_missing_symbol_data(currency, symbol, reversed_symbol)
+                if raise_error:
+                    raise missing_data_exception
         return constants.ZERO
 
     def _try_to_ask_ticker_missing_symbol_data(self, currency, symbol, reversed_symbol):
         """
         Try to ask the ticker producer to watch additional symbols
         to collect missing data required for profitability calculation
         :param currency: the concerned currency
@@ -210,22 +166,22 @@
             )
         else:
             asyncio_tools.run_coroutine_in_asyncio_loop(
                 self.portfolio_manager.exchange_manager.exchange_config.add_watched_symbols(symbols_to_add),
                 self._bot_main_loop
             )
 
-    def _inform_no_matching_symbol(self, currency, target_currency):
+    def _inform_no_matching_symbol(self, currency):
         """
         Log a missing currency pair to calculate the portfolio profitability
         :param currency: the concerned currency
         """
         # do not log warning in backtesting or tests
         if not self.portfolio_manager.exchange_manager.is_backtesting:
-            self.logger.warning(f"No trading pair including {currency} and {target_currency} on"
+            self.logger.warning(f"No trading pair including {currency} and {self.portfolio_manager.reference_market} on"
                                 f" {self.portfolio_manager.exchange_manager.exchange_name}. {currency} "
                                 f"can't be valued for portfolio and profitability.")
 
     def convert_currency_value_using_last_prices(
         self, quantity, current_currency, target_currency, settlement_asset=None
     ):
         try:
@@ -237,15 +193,15 @@
         except KeyError:
             pass
         try:
             reversed_symbol = symbol_util.merge_currencies(
                 target_currency, current_currency, settlement_asset=settlement_asset
             )
             return quantity / self._get_last_price_data(reversed_symbol)
-        except (KeyError, decimal.DivisionByZero, decimal.InvalidOperation):
+        except (KeyError, decimal.DivisionByZero):
             pass
         raise errors.MissingPriceDataError(
             f"no price data to evaluate {current_currency} price in {target_currency}"
         )
 
     def try_convert_currency_value_using_multiple_pairs(
             self, currency, target, quantity, base_bridge
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/channel/positions_updater_simulator.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/position_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/position_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/positions_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/positions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/active_position_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/active_position_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/idle_position_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/idle_position_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/liquidate_position_state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/liquidate_position_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/states/position_state_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/states/position_state_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/inverse_position.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/inverse_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/positions/types/linear_position.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/positions/types/linear_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/state.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,14 +21,15 @@
 
 from octobot_trading.personal_data.trades.trades_manager import (
     TradesManager,
 )
 from octobot_trading.personal_data.trades.trade_factory import (
     create_trade_instance_from_raw,
     create_trade_from_order,
+    create_trade_instance,
     create_trade_from_dict,
 )
 from octobot_trading.personal_data.trades.channel import (
     TradesProducer,
     TradesChannel,
     TradesUpdater,
 )
@@ -36,23 +37,22 @@
     Trade,
 )
 from octobot_trading.personal_data.trades.trade_pnl import (
     TradePnl,
 )
 from octobot_trading.personal_data.trades.trades_util import (
     compute_win_rate,
-    aggregate_trades_by_exchange_order_id,
 )
 
 __all__ = [
     "TradesManager",
     "TradesProducer",
     "TradesChannel",
     "create_trade_instance_from_raw",
     "create_trade_from_order",
+    "create_trade_instance",
     "create_trade_from_dict",
     "TradesUpdater",
     "Trade",
     "TradePnl",
     "compute_win_rate",
-    "aggregate_trades_by_exchange_order_id",
 ]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/trades.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/trades.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/channel/trades_updater.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/channel/trades_updater.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,22 +29,21 @@
         self.trader = trader
         self.exchange_manager = trader.exchange_manager
 
         self.status = enums.OrderStatus.OPEN
         self.creation_time = self.exchange_manager.exchange.get_exchange_current_time()
 
         self.trade_id = trader.parse_order_id(None)
+        # One order might create multiple trades when matched to multiple open orders.
+        # Current implementation creates only one trade per order
+        # TODO: update this comment when handling multiple trades per order
         self.origin_order_id = None
         self.exchange_order_id = None
-        # One order might create multiple trades when matched to multiple open orders.
-        # in this case those trades would share the same exchange_order_id
-        self.exchange_trade_id = None
         self.simulated = True
         self.is_closing_order = False
-        self.is_from_this_octobot = True
 
         self.symbol = None
         self.currency = None
         self.market = None
         self.taker_or_maker = None
         self.origin_price = constants.ZERO
         self.origin_quantity = constants.ZERO
@@ -57,20 +56,19 @@
         self.executed_price = constants.ZERO
         self.trade_profitability = constants.ZERO
         self.total_cost = constants.ZERO
         self.reduce_only = False
         self.tag = None
         self.quantity_currency = None
         self.associated_entry_ids = None
-        self.broker_applied = False
 
         # raw exchange trade type, used to create trade dict
         self.exchange_trade_type = None
 
-    def update_from_order(self, order, creation_time=0, canceled_time=0, executed_time=0, exchange_trade_id=None):
+    def update_from_order(self, order, creation_time=0, canceled_time=0, executed_time=0):
         self.currency = order.currency
         self.market = order.market
         self.taker_or_maker = order.taker_or_maker
         self.executed_quantity = order.filled_quantity
         self.executed_price = order.filled_price
         self.origin_price = order.origin_price
         self.origin_quantity = order.origin_quantity
@@ -79,27 +77,24 @@
         self.trade_type = order.order_type
         self.exchange_trade_type = order.exchange_order_type
         self.status = order.status
         self.fee = order.fee
         self.trade_id = order.order_id
         self.origin_order_id = order.order_id
         self.exchange_order_id = order.exchange_order_id
-        self.exchange_trade_id = exchange_trade_id or self.exchange_trade_id
         self.simulated = order.simulated
         self.side = order.side
         self.creation_time = order.creation_time if order.creation_time > 0 else creation_time
         self.canceled_time = order.canceled_time if order.canceled_time > 0 else canceled_time
         self.executed_time = order.executed_time if order.executed_time > 0 else executed_time
         self.symbol = order.symbol
         self.is_closing_order = order.status in self.CLOSING_TRADE_ORDER_STATUS
-        self.is_from_this_octobot = order.is_from_this_octobot
         self.reduce_only = order.reduce_only
         self.tag = order.tag
         self.associated_entry_ids = order.associated_entry_ids
-        self.broker_applied = order.broker_applied
 
     def get_time(self):
         return self.executed_time if self.has_been_executed() else self.canceled_time
 
     def get_quantity(self):
         return self.executed_quantity if self.has_been_executed() else self.origin_quantity
 
@@ -107,15 +102,14 @@
         return self.status is not enums.OrderStatus.CANCELED and self.status is not enums.OrderStatus.EXPIRED
 
     def to_dict(self):
         return {
             enums.ExchangeConstantsOrderColumns.ID.value: self.trade_id,
             enums.ExchangeConstantsOrderColumns.ORDER_ID.value: self.origin_order_id,
             enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value: self.exchange_order_id,
-            enums.ExchangeConstantsOrderColumns.EXCHANGE_TRADE_ID.value: self.exchange_trade_id,
             enums.ExchangeConstantsOrderColumns.SYMBOL.value: self.symbol,
             enums.ExchangeConstantsOrderColumns.MARKET.value: self.market,
             enums.ExchangeConstantsOrderColumns.PRICE.value: self.executed_price,
             enums.ExchangeConstantsOrderColumns.STATUS.value: self.status.value,
             enums.ExchangeConstantsOrderColumns.TIMESTAMP.value: self.get_time(),
             enums.ExchangeConstantsOrderColumns.TYPE.value: self.exchange_trade_type.value,
             enums.ExchangeConstantsOrderColumns.SIDE.value: self.side.value,
@@ -123,24 +117,22 @@
             enums.ExchangeConstantsOrderColumns.COST.value: self.total_cost,
             enums.ExchangeConstantsOrderColumns.QUANTITY_CURRENCY.value: self.quantity_currency,
             enums.ExchangeConstantsOrderColumns.TAKER_OR_MAKER.value: self.taker_or_maker,
             enums.ExchangeConstantsOrderColumns.FEE.value: self.fee,
             enums.ExchangeConstantsOrderColumns.REDUCE_ONLY.value: self.reduce_only,
             enums.ExchangeConstantsOrderColumns.TAG.value: self.tag,
             enums.ExchangeConstantsOrderColumns.ENTRIES.value: self.associated_entry_ids,
-            enums.ExchangeConstantsOrderColumns.BROKER_APPLIED.value: self.broker_applied,
             enums.TradeExtraConstants.CREATION_TIME.value: self.creation_time,
         }
 
     @classmethod
     def from_dict(cls, trader, trade_dict):
         trade = cls(trader)
-        trade.trade_id = trade_dict.get(enums.ExchangeConstantsOrderColumns.ID.value, trade.trade_id)
+        trade.trade_id = trade_dict.get(enums.ExchangeConstantsOrderColumns.ID.value)
         trade.origin_order_id = trade_dict.get(enums.ExchangeConstantsOrderColumns.ORDER_ID.value)
-        trade.exchange_trade_id = trade_dict.get(enums.ExchangeConstantsOrderColumns.EXCHANGE_TRADE_ID.value)
         trade.exchange_order_id = trade_dict.get(enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value)
         trade.symbol = trade_dict.get(enums.ExchangeConstantsOrderColumns.SYMBOL.value)
         trade.currency, trade.market = commons_symbols.parse_symbol(trade.symbol).base_and_quote()
         trade.market = trade_dict.get(enums.ExchangeConstantsOrderColumns.MARKET.value)
         trade.executed_price = decimal.Decimal(str(trade_dict.get(enums.ExchangeConstantsOrderColumns.PRICE.value)))
         trade.status = enums.OrderStatus(trade_dict.get(enums.ExchangeConstantsOrderColumns.STATUS.value,
                                                         enums.OrderStatus.CLOSED.value))
@@ -164,16 +156,9 @@
         trade.fee = copy.copy(trade_dict.get(enums.ExchangeConstantsOrderColumns.FEE.value))
         if trade.fee and enums.FeePropertyColumns.COST.value in trade.fee:
             trade.fee[enums.FeePropertyColumns.COST.value] = \
                 decimal.Decimal(str(trade.fee[enums.FeePropertyColumns.COST.value]))
         trade.reduce_only = trade_dict.get(enums.ExchangeConstantsOrderColumns.REDUCE_ONLY.value)
         trade.tag = trade_dict.get(enums.ExchangeConstantsOrderColumns.TAG.value)
         trade.associated_entry_ids = trade_dict.get(enums.ExchangeConstantsOrderColumns.ENTRIES.value)
-        trade.broker_applied = trade_dict.get(
-            enums.ExchangeConstantsOrderColumns.BROKER_APPLIED.value, trade.broker_applied
-        )
         trade.creation_time = trade_dict.get(enums.TradeExtraConstants.CREATION_TIME.value)
         return trade
-
-    def clear(self):
-        self.trader = None
-        self.exchange_manager = None
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade_factory.py`

 * *Files 26% similar despite different names*

```diff
@@ -26,36 +26,64 @@
         order.update_from_raw(raw_trade)
         if order.status is enums.OrderStatus.CANCELED:
             # ensure order is considered canceled
             order.consider_as_canceled()
         else:
             # ensure order is considered filled
             order.consider_as_filled()
-        exchange_trade_id = raw_trade.get(enums.ExchangeConstantsOrderColumns.EXCHANGE_TRADE_ID.value)
-        return create_trade_from_order(order, exchange_trade_id=exchange_trade_id)
+        return create_trade_from_order(order)
     except KeyError:
         # Funding trade candidate
         return None
 
 
 def create_trade_from_order(order,
                             close_status=None,
                             creation_time=0,
                             canceled_time=0,
-                            executed_time=0,
-                            exchange_trade_id=None):
+                            executed_time=0):
     if close_status is not None:
         order.status = close_status
     trade = trade_class.Trade(order.trader)
     trade.update_from_order(order,
                             canceled_time=canceled_time,
                             creation_time=creation_time,
-                            executed_time=executed_time,
-                            exchange_trade_id=exchange_trade_id)
+                            executed_time=executed_time)
     if trade.get_time() < constants.MINIMUM_VAL_TRADE_TIME:
         logging.get_logger("TradeFactory").error(f"Trade with invalid trade time ({trade.get_time()}) "
                                                  f"from order: {order}")
     return trade
 
 
+def create_trade_instance(trader,
+                          order_type,
+                          symbol,
+                          status=enums.OrderStatus.CLOSED,
+                          order_id=None,
+                          exchange_order_id=None,
+                          filled_price=constants.ZERO,
+                          quantity_filled=constants.ZERO,
+                          total_cost=constants.ZERO,
+                          canceled_time=0,
+                          creation_time=0,
+                          executed_time=0):
+    order = order_factory.create_order_from_type(trader=trader, order_type=order_type)
+    order.update(order_type=order_type,
+                 symbol=symbol,
+                 current_price=filled_price,
+                 quantity=quantity_filled,
+                 price=filled_price,
+                 order_id=trader.parse_order_id(order_id),
+                 exchange_order_id=trader.parse_order_id(exchange_order_id),
+                 filled_price=filled_price,
+                 quantity_filled=quantity_filled,
+                 fee=None,  # TODO
+                 total_cost=total_cost)
+    return create_trade_from_order(order,
+                                   close_status=status,
+                                   canceled_time=canceled_time,
+                                   creation_time=creation_time,
+                                   executed_time=executed_time)
+
+
 def create_trade_from_dict(trader, trade_dict):
     return trade_class.Trade.from_dict(trader, trade_dict)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trade_pnl.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trade_pnl.py`

 * *Files 2% similar despite different names*

```diff
@@ -82,15 +82,15 @@
         return self.get_close_price() * self.get_total_close_quantity()
 
     def get_close_ratio(self):
         try:
             if self.entries[0].side is enums.TradeOrderSide.BUY:
                 return min(self.get_total_close_quantity() / self.get_total_entry_quantity(), constants.ONE)
             return min(self.get_close_total_cost() / self.get_entry_total_cost(), constants.ONE)
-        except (IndexError, decimal.DivisionByZero, decimal.InvalidOperation) as err:
+        except (IndexError, decimal.DivisionByZero) as err:
             raise errors.IncompletePNLError from err
 
     def get_closed_entry_value(self) -> decimal.Decimal:
         return self.get_entry_price() * self.get_total_entry_quantity()
 
     def get_closed_close_value(self) -> decimal.Decimal:
         return self.get_close_price() * self.get_closed_pnl_quantity()
@@ -155,13 +155,13 @@
         """
         :return: the pnl profits as flat value and percent
         """
         close_holdings = self.get_closed_close_value() - self.get_paid_regular_fees_in_quote()
         entry_holdings = self.get_closed_entry_value() * self.get_close_ratio()
         try:
             percent_profit = (close_holdings * constants.ONE_HUNDRED / entry_holdings) - constants.ONE_HUNDRED
-        except (decimal.DivisionByZero, decimal.InvalidOperation):
+        except decimal.DivisionByZero:
             percent_profit = constants.ZERO
         return (
             close_holdings - entry_holdings,
             percent_profit
         )
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trades_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trades_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -157,9 +157,10 @@
                 self.trader.exchange_manager.exchange_name,
                 commons_enums.InitializationEventExchangeTopics.TRADES.value
             )
         )
 
     def clear(self):
         for trade in self.trades.values():
-            trade.clear()
+            trade.trader = None
+            trade.exchange_manager = None
         self._reset_trades()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/trades/trades_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/trades/trades_util.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,16 +9,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import decimal
-
 import octobot_trading.enums as trading_enums
 import octobot_trading.constants as constants
 import octobot_trading.personal_data as personal_data
 
 
 _LOSING_ORDER_TYPES = [
     trading_enums.TradeOrderType.STOP_LOSS,
@@ -64,32 +62,7 @@
                     lost_trades_count += constants.ONE
                 else:
                     won_trades_count += constants.ONE
     total_counted_trades = won_trades_count + lost_trades_count
     if total_counted_trades > constants.ZERO:
         return won_trades_count / total_counted_trades
     return constants.ZERO
-
-
-def aggregate_trades_by_exchange_order_id(trades: list) -> dict:
-    aggregated_trades_by_exchange_order_id = {}
-    for trade in trades:
-        if trade.exchange_order_id not in aggregated_trades_by_exchange_order_id:
-            # initialise as a new trade that will contain the aggregation
-            aggregated_trades_by_exchange_order_id[trade.exchange_order_id] = personal_data.create_trade_from_dict(
-                trade.trader, trade.to_dict()
-            )
-        else:
-            # include other trades from the same order id into the aggregated trade
-            to_update = aggregated_trades_by_exchange_order_id[trade.exchange_order_id]
-            try:
-                to_update.executed_price = (
-                    to_update.executed_quantity * to_update.executed_price + trade.executed_quantity * trade.executed_price
-                ) / (to_update.executed_quantity + trade.executed_quantity)
-            except (decimal.DivisionByZero, decimal.InvalidOperation):
-                to_update.executed_price = constants.ZERO
-            to_update.executed_quantity += trade.executed_quantity
-            to_update.total_cost += trade.total_cost
-            to_update.fee[trading_enums.FeePropertyColumns.COST.value] \
-                += trade.fee[trading_enums.FeePropertyColumns.COST.value]
-            to_update.executed_time = max(to_update.executed_time, trade.executed_time)
-    return aggregated_trades_by_exchange_order_id
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transaction.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transaction_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transaction_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/transactions_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/transactions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/blockchain_transaction.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/blockchain_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/fee_transaction.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/fee_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/realised_pnl_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/personal_data/transactions/types/transfer_transaction.py` & `OctoBot-Trading-2.4.9/octobot_trading/personal_data/transactions/types/transfer_transaction.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/channel/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/channel/remote_trading_signal.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/channel/remote_trading_signal.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/channel/remote_trading_signal_channel_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/channel/signal_producer.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/channel/signal_producer.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/signal_creation.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/signal_creation.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/trading_signal_bundle_builder.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/trading_signal_bundle_builder.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,24 +28,14 @@
     def build(self) -> signals.SignalBundle:
         """
         Link bundled an grouped orders and create a signal_bundle.SignalBundle from registered signals
         """
         self._pack_referenced_orders_together()
         return super().build()
 
-    def sort_signals(self):
-        # https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts
-        # move cancelled order signals at the beginning of the list, leave others as is while keeping initial order
-        def _sort_key(signal):
-            return 0 if signal.content[trading_enums.TradingSignalCommonsAttrs.ACTION.value] == \
-                trading_enums.TradingSignalOrdersActions.CANCEL.value else 1
-
-        self.signals = sorted(self.signals, key=_sort_key)
-        return self
-
     def add_created_order(self, order, exchange_manager, target_amount=None, target_position=None):
         if target_amount is None and target_position is None:
             raise trading_errors.InvalidArgumentError("target_amount or target_position has to be provided")
         if not self._update_pending_orders(order, exchange_manager,
                                            trading_enums.TradingSignalOrdersActions.CREATE,
                                            target_amount=target_amount,
                                            target_position=target_position):
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/signals/util.py` & `OctoBot-Trading-2.4.9/octobot_trading/signals/util.py`

 * *Files 2% similar despite different names*

```diff
@@ -57,16 +57,14 @@
         trading_enums.TradingSignalOrdersAttrs.POST_ONLY.value: False,
         trading_enums.TradingSignalOrdersAttrs.GROUP_ID.value:
             None if order.order_group is None else order.order_group.name,
         trading_enums.TradingSignalOrdersAttrs.GROUP_TYPE.value:
             None if order.order_group is None else order.order_group.__class__.__name__,
         trading_enums.TradingSignalOrdersAttrs.TAG.value: order.tag,
         trading_enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: order.associated_entry_ids,
-        trading_enums.TradingSignalOrdersAttrs.UPDATE_WITH_TRIGGERING_ORDER_FEES.value:
-            order.update_with_triggering_order_fees,
         trading_enums.TradingSignalOrdersAttrs.ORDER_ID.value: order.order_id,
         trading_enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value:
             None if order.triggered_by is None else order.triggered_by.order_id
         if order.has_been_bundled else None,
         trading_enums.TradingSignalOrdersAttrs.CHAINED_TO.value:
             None if order.triggered_by is None else order.triggered_by.order_id,
         trading_enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -24,15 +24,14 @@
 from octobot_trading.storage.trades_storage import (
     TradesStorage,
 )
 
 from octobot_trading.storage import orders_storage
 from octobot_trading.storage.orders_storage import (
     OrdersStorage,
-    restore_order_storage_origin_value,
 )
 
 from octobot_trading.storage import portfolio_storage
 from octobot_trading.storage.portfolio_storage import (
     PortfolioStorage,
 )
 
@@ -58,15 +57,14 @@
     get_account_type_suffix,
 )
 
 __all__ = [
     "AbstractStorage",
     "TradesStorage",
     "OrdersStorage",
-    "restore_order_storage_origin_value",
     "PortfolioStorage",
     "CandlesStorage",
     "TransactionsStorage",
     "StorageManager",
     "get_account_type_suffix_from_exchange_manager",
     "get_account_type_suffix_from_run_metadata",
     "get_account_type_suffix",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/abstract_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/abstract_storage.py`

 * *Files 15% similar despite different names*

```diff
@@ -27,16 +27,16 @@
 
 class AbstractStorage:
     IS_LIVE_CONSUMER = True
     USE_LIVE_CONSUMER_IN_BACKTESTING = False
     LIVE_CHANNEL = None
     IS_HISTORICAL = True
     HISTORY_TABLE = None
-    AUTH_UPDATE_DEBOUNCE_DURATION = 10
-    FLUSH_DEBOUNCE_DURATION = 5   # avoid disc spam on multiple quick live updated
+    AUTH_UPDATE_DEBOUNCE_DURATION = 1
+    FLUSH_DEBOUNCE_DURATION = 0.5   # avoid disc spam on multiple quick live updated
 
     def __init__(self, exchange_manager, plot_settings: commons_display.PlotSettings,
                  use_live_consumer_in_backtesting=None, is_historical=None):
         self.exchange_manager = exchange_manager
         self.plot_settings: commons_display.PlotSettings = plot_settings
         self.consumer = None
         self.use_live_consumer_in_backtesting = use_live_consumer_in_backtesting \
@@ -165,27 +165,7 @@
             if isinstance(val, decimal.Decimal):
                 sanitized[key] = float(val)
             elif isinstance(val, dict):
                 sanitized[key] = cls.sanitize_for_storage(val)
             elif isinstance(val, types.FunctionType):
                 raise ValueError(f"{val.__name__} is a function, it can't be serialized")
         return sanitized
-
-    @staticmethod
-    def hard_reset_and_retry_if_necessary(fn):
-        """
-        Will retry the given function if a database hard reset error is raised
-        Warning: when it happens, will also completely reset the database
-        """
-        async def wrapper(*args, **kwargs):
-            try:
-                return await fn(*args, **kwargs)
-            except Exception as err:
-                database = args[0]._get_db()    # pylint: disable=protected-access
-                if database.is_hard_reset_error(err):
-                    logging.get_logger(args[0].__class__.__name__).warning(
-                        f"Resetting database due to [{err}] error"
-                    )
-                    await database.hard_reset()
-                    return await fn(*args, **kwargs)
-                raise
-        return wrapper
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/candles_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/candles_storage.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,15 +47,14 @@
         await super().stop(**kwargs)
 
     async def _store_candles_when_available(self):
         await util.wait_for_topic_init(self.exchange_manager, self._init_timeout,
                                        commons_enums.InitializationEventExchangeTopics.CANDLES.value)
         await self.store_candles()
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def store_candles(self):
         if not self.enabled:
             return
         for symbol in self.exchange_manager.exchange_config.traded_symbol_pairs:
             symbol_db = self._get_db(symbol)
             await symbol_db.delete(self.HISTORY_TABLE, None)
             for time_frame in self.exchange_manager.exchange_config.get_relevant_time_frames():
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/orders_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/orders_storage.py`

 * *Files 14% similar despite different names*

```diff
@@ -17,15 +17,14 @@
 import decimal
 import time
 
 import octobot_commons.channels_name as channels_name
 import octobot_commons.enums as commons_enums
 import octobot_commons.databases as commons_databases
 import octobot_commons.logging as commons_logging
-import octobot_commons.authentication as authentication
 
 import octobot_trading.enums as enums
 import octobot_trading.constants as constants
 import octobot_trading.storage.abstract_storage as abstract_storage
 import octobot_trading.storage.util as storage_util
 
 
@@ -36,15 +35,19 @@
     ENABLE_HISTORICAL_ORDER_UPDATES_STORAGE = constants.ENABLE_HISTORICAL_ORDERS_UPDATES_STORAGE
 
     def __init__(self, exchange_manager, use_live_consumer_in_backtesting=None, is_historical=None):
         super().__init__(exchange_manager, plot_settings=None,
                          use_live_consumer_in_backtesting=use_live_consumer_in_backtesting, is_historical=is_historical)
         self.startup_orders = {}
 
-    def should_store_data(self):
+    def should_register_live_consumer(self):
+        # live orders should only be stored on real trading
+        return self.should_store_date()
+
+    def should_store_date(self):
         return not self.exchange_manager.is_trader_simulated \
             and not self.exchange_manager.is_backtesting
 
     async def on_start(self):
         await self._load_startup_orders()
 
     async def _live_callback(
@@ -53,23 +56,20 @@
         exchange_id: str,
         cryptocurrency: str,
         symbol: str,
         order: dict,
         update_type: str,
         is_from_bot: bool,
     ):
-        await self.trigger_debounced_update_auth_data(False)
         # only store the current snapshot of open orders when order updates are received
-        if self.should_store_data():
-            await self._update_history()
-            if self.ENABLE_HISTORICAL_ORDER_UPDATES_STORAGE:
-                await self._add_historical_open_orders(order, update_type)
-            await self.trigger_debounced_flush()
+        await self._update_history()
+        if self.ENABLE_HISTORICAL_ORDER_UPDATES_STORAGE:
+            await self._add_historical_open_orders(order, update_type)
+        await self.trigger_debounced_flush()
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def _update_history(self):
         await self._get_db().replace_all(
             self.HISTORY_TABLE,
             [
                 _format_order(order, self.exchange_manager)
                 for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders()
             ],
@@ -80,24 +80,14 @@
         update_time = time.time()
         await self._get_db().log(
             self.HISTORICAL_OPEN_ORDERS_TABLE,
             _format_order_update(self.exchange_manager, order_dict, update_type, update_time),
             cache=False,
         )
 
-    async def _update_auth_data(self, _):
-        authenticator = authentication.Authenticator.instance()
-        snapshot = [
-            _format_order(order, self.exchange_manager)
-            for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders()
-        ]
-        if authenticator.is_initialized():
-            # also update when history is empty to reset trade history
-            await authenticator.update_orders(snapshot, self.exchange_manager.exchange_name)
-
     async def _store_history(self):
         await self._update_history()
         await self._get_db().flush()
 
     def _get_db(self):
         return commons_databases.RunDatabasesProvider.instance().get_orders_db(
             self.exchange_manager.bot_id,
@@ -108,36 +98,30 @@
     async def get_historical_orders_updates(self):
         return copy.deepcopy(await self._get_db().all(self.HISTORICAL_OPEN_ORDERS_TABLE))
 
     async def get_startup_order_details(self, order_exchange__id):
         return self.startup_orders.get(order_exchange__id, None)
 
     async def _load_startup_orders(self):
-        if self.should_store_data():
+        if self.should_store_date():
             self.startup_orders = {
-                _get_startup_order_key(order): from_order_document(order)
+                _get_startup_order_key(order): _from_order_document(order)
                 for order in copy.deepcopy(await self._get_db().all(self.HISTORY_TABLE))
                 if order    # skip empty order details (error when serializing)
             }
         else:
             self.startup_orders = {}
 
     def get_startup_self_managed_orders_details_from_group(self, group_id):
         return [
             order
-            for order in self.get_all_self_managed_startup_orders()
+            for order in self.startup_orders.values()
             if order.get(enums.StoredOrdersAttr.GROUP.value, {}).get(enums.StoredOrdersAttr.GROUP_ID.value, None)
             == group_id
-        ]
-
-    def get_all_self_managed_startup_orders(self):
-        return [
-            order
-            for order in self.startup_orders.values()
-            if order.get(constants.STORAGE_ORIGIN_VALUE, {})
+            and order.get(constants.STORAGE_ORIGIN_VALUE, {})
             .get(enums.ExchangeConstantsOrderColumns.SELF_MANAGED.value, False)
         ]
 
     @classmethod
     async def clear_database_history(cls, database, flush=True):
         await super().clear_database_history(database, flush=False)
         if cls.ENABLE_HISTORICAL_ORDER_UPDATES_STORAGE:
@@ -165,30 +149,28 @@
         _format_order(chained_order, exchange_manager)
         for chained_order in order.chained_orders
     ]
 
 
 def _format_order(order, exchange_manager):
     try:
-        formatted = {
+        return {
             constants.STORAGE_ORIGIN_VALUE: OrdersStorage.sanitize_for_storage(order.to_dict()),
+            enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value:
+                OrdersStorage.sanitize_for_storage(order.exchange_creation_params),
+            enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value:
+                OrdersStorage.sanitize_for_storage(order.trader_creation_kwargs),
+            enums.StoredOrdersAttr.HAS_BEEN_BUNDLED.value: order.has_been_bundled,
+            enums.StoredOrdersAttr.ENTRIES.value: order.associated_entry_ids,
+            enums.StoredOrdersAttr.GROUP.value: _get_group_dict(order),
+            enums.StoredOrdersAttr.CHAINED_ORDERS.value:
+                _get_chained_orders(order, exchange_manager),
+            enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES.value:
+                order.update_with_triggering_order_fees,
         }
-        for key, val in (
-            (enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS, OrdersStorage.sanitize_for_storage(order.exchange_creation_params)),
-            (enums.StoredOrdersAttr.TRADER_CREATION_KWARGS, OrdersStorage.sanitize_for_storage(order.trader_creation_kwargs)),
-            (enums.StoredOrdersAttr.HAS_BEEN_BUNDLED, order.has_been_bundled),
-            (enums.StoredOrdersAttr.ENTRIES, order.associated_entry_ids),
-            (enums.StoredOrdersAttr.GROUP, _get_group_dict(order)),
-            (enums.StoredOrdersAttr.CHAINED_ORDERS, _get_chained_orders(order, exchange_manager)),
-            (enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES, order.update_with_triggering_order_fees),
-        ):
-            # do not include default values
-            if val:
-                formatted[key.value] = val
-        return formatted
     except Exception as err:
         commons_logging.get_logger(OrdersStorage.__name__).exception(err, True, f"Error when formatting order: {err}")
     return {}
 
 
 def _format_order_update(exchange_manager, order_dict, update_type, update_time):
     order_id = order_dict[enums.ExchangeConstantsOrderColumns.ID.value]
@@ -211,42 +193,35 @@
             details = {
                 constants.STORAGE_ORIGIN_VALUE: OrdersStorage.sanitize_for_storage(order_dict),
             }
     order_update[enums.StoredOrdersAttr.ORDER_DETAILS.value] = details
     return order_update
 
 
-def from_order_document(order_document):
+def _from_order_document(order_document):
     order_dict = dict(order_document)
     try:
-        restore_order_storage_origin_value(order_dict[constants.STORAGE_ORIGIN_VALUE])
-        for chained_order in order_dict.get(enums.StoredOrdersAttr.CHAINED_ORDERS.value, []):
-            from_order_document(chained_order)
+        origin_val = order_dict[constants.STORAGE_ORIGIN_VALUE]
+        origin_val[enums.ExchangeConstantsOrderColumns.AMOUNT.value] = \
+            decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.AMOUNT.value]))
+        origin_val[enums.ExchangeConstantsOrderColumns.COST.value] = \
+            decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.COST.value]))
+        origin_val[enums.ExchangeConstantsOrderColumns.FILLED.value] = \
+            decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.FILLED.value]))
+        origin_val[enums.ExchangeConstantsOrderColumns.PRICE.value] = \
+            decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.PRICE.value]))
+        if origin_val[enums.ExchangeConstantsOrderColumns.FEE.value] and \
+                enums.FeePropertyColumns.COST.value in origin_val[enums.ExchangeConstantsOrderColumns.FEE.value]:
+            origin_val[enums.ExchangeConstantsOrderColumns.FEE.value][enums.FeePropertyColumns.COST.value] = \
+                decimal.Decimal(str(
+                    origin_val[enums.ExchangeConstantsOrderColumns.FEE.value][enums.FeePropertyColumns.COST.value]
+                ))
     except Exception as err:
         commons_logging.get_logger(OrdersStorage.__name__).exception(
             err, True, f"Error when reading: {err} order: {order_document}"
         )
     return order_dict
 
-
-def restore_order_storage_origin_value(origin_val):
-    origin_val[enums.ExchangeConstantsOrderColumns.AMOUNT.value] = \
-        decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.AMOUNT.value]))
-    origin_val[enums.ExchangeConstantsOrderColumns.COST.value] = \
-        decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.COST.value]))
-    origin_val[enums.ExchangeConstantsOrderColumns.FILLED.value] = \
-        decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.FILLED.value]))
-    origin_val[enums.ExchangeConstantsOrderColumns.PRICE.value] = \
-        decimal.Decimal(str(origin_val[enums.ExchangeConstantsOrderColumns.PRICE.value]))
-    if origin_val[enums.ExchangeConstantsOrderColumns.FEE.value] and \
-            enums.FeePropertyColumns.COST.value in origin_val[enums.ExchangeConstantsOrderColumns.FEE.value]:
-        origin_val[enums.ExchangeConstantsOrderColumns.FEE.value][enums.FeePropertyColumns.COST.value] = \
-            decimal.Decimal(str(
-                origin_val[enums.ExchangeConstantsOrderColumns.FEE.value][enums.FeePropertyColumns.COST.value]
-            ))
-    return origin_val
-
-
 def _get_startup_order_key(order_dict):
     # use exchange id if available, fallback to order_id (for self managed orders)
     return order_dict[constants.STORAGE_ORIGIN_VALUE][enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value] or \
         order_dict[constants.STORAGE_ORIGIN_VALUE][enums.ExchangeConstantsOrderColumns.ID.value]
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/portfolio_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/portfolio_storage.py`

 * *Files 3% similar despite different names*

```diff
@@ -25,15 +25,14 @@
 
 class PortfolioStorage(abstract_storage.AbstractStorage):
     IS_LIVE_CONSUMER = False
     IS_HISTORICAL = True
     PRICE_INIT_TIMEOUT = 30
     HISTORY_TABLE = commons_enums.RunDatabases.HISTORICAL_PORTFOLIO_VALUE.value
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def store_history(self, reset=False):
         if not self.enabled:
             return
         portfolio_db = self.get_db()
         hist_portfolio_values_manager = self.exchange_manager.exchange_personal_data.\
             portfolio_manager.historical_portfolio_value_manager
         metadata = hist_portfolio_values_manager.get_metadata()
@@ -76,27 +75,24 @@
                         commons_tree.get_exchange_path(
                             self.exchange_manager.exchange_name,
                             commons_enums.InitializationEventExchangeTopics.PRICE.value,
                             symbol=symbol,
                         ),
                         self.PRICE_INIT_TIMEOUT
                     )
-            # skip portfolio history on simulated trading
-            histories = {} if self.exchange_manager.is_trader_simulated else {
-                history_val[portfolio_history.HistoricalAssetValue.TIMESTAMP_KEY]:
-                    history_val[portfolio_history.HistoricalAssetValue.VALUES_KEY]
-                for history_val in history
-            }
             await authenticator.update_portfolio(
                 full_history[-1][portfolio_history.HistoricalAssetValue.VALUES_KEY],
                 full_history[0][portfolio_history.HistoricalAssetValue.VALUES_KEY],
-                float(hist_portfolio_values_manager.portfolio_manager.portfolio_profitability.profitability_percent),
                 hist_portfolio_values_manager.portfolio_manager.reference_market,
                 hist_portfolio_values_manager.ending_portfolio,
-                histories,
+                {
+                    history_val[portfolio_history.HistoricalAssetValue.TIMESTAMP_KEY]:
+                        history_val[portfolio_history.HistoricalAssetValue.VALUES_KEY]
+                    for history_val in history
+                },
                 hist_portfolio_values_manager.portfolio_manager.portfolio_value_holder.current_crypto_currencies_values,
                 reset
             )
             self._to_update_auth_data_ids_buffer.clear()
 
     def get_db(self):
         return self._get_db()
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/storage_manager.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/storage_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/trades_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/trades_storage.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,28 +13,25 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library
 import octobot_commons.channels_name as channels_name
 import octobot_commons.enums as commons_enums
 import octobot_commons.authentication as authentication
 import octobot_commons.databases as commons_databases
-import octobot_commons.symbols as commons_symbols
 
 import octobot_trading.enums as enums
-import octobot_trading.errors as errors
 import octobot_trading.constants as constants
 import octobot_trading.storage.abstract_storage as abstract_storage
 import octobot_trading.storage.util as storage_util
 
 
 class TradesStorage(abstract_storage.AbstractStorage):
     LIVE_CHANNEL = channels_name.OctoBotTradingChannelsName.TRADES_CHANNEL.value
     HISTORY_TABLE = commons_enums.DBTables.TRADES.value
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def _live_callback(
         self,
         exchange: str,
         exchange_id: str,
         cryptocurrency: str,
         symbol: str,
         trade: dict,
@@ -53,31 +50,25 @@
                 )
             )
             await self.trigger_debounced_flush()
             self._to_update_auth_data_ids_buffer.add(trade[enums.ExchangeConstantsOrderColumns.ID.value])
             await self.trigger_debounced_update_auth_data(False)
 
     async def _update_auth_data(self, reset):
-        # skip trades history on simulated trading
-        if self.exchange_manager.is_trader_simulated:
-            return
         authenticator = authentication.Authenticator.instance()
         history = [
-            self._get_trade_dict_with_usd_like_volume(trade)
+            trade.to_dict()
             for trade in self.exchange_manager.exchange_personal_data.trades_manager.trades.values()
-            if trade.status is not enums.OrderStatus.CANCELED
-            and trade.is_from_this_octobot
-            and trade.trade_id in self._to_update_auth_data_ids_buffer
+            if trade.status is not enums.OrderStatus.CANCELED and trade.trade_id in self._to_update_auth_data_ids_buffer
         ]
         if (history or reset) and authenticator.is_initialized():
             # also update when history is empty to reset trade history
             await authenticator.update_trades(history, self.exchange_manager.exchange_name, reset)
             self._to_update_auth_data_ids_buffer.clear()
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def _store_history(self):
         database = self._get_db()
         await database.replace_all(
             self.HISTORY_TABLE,
             [
                 _format_trade(
                     trade.to_dict(),
@@ -90,27 +81,14 @@
                 for trade in self.exchange_manager.exchange_personal_data.trades_manager.trades.values()
                 if trade.status is not enums.OrderStatus.CANCELED
             ],
             cache=False,
         )
         await database.flush()
 
-    def _get_trade_dict_with_usd_like_volume(self, trade) -> dict:
-        trade_dict = trade.to_dict()
-        parsed_symbol = commons_symbols.parse_symbol(trade.symbol)
-        cost_currency = parsed_symbol.quote if parsed_symbol.is_linear() else parsed_symbol.base
-        try:
-            usd_volume = self.exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
-                value_converter.get_usd_like_value(cost_currency, trade.total_cost)
-        except errors.MissingPriceDataError:
-            # can't evaluate USD-like volume
-            usd_volume = constants.ZERO
-        trade_dict[enums.ExchangeConstantsOrderColumns.VOLUME.value] = usd_volume
-        return trade_dict
-
     def _get_db(self):
         return commons_databases.RunDatabasesProvider.instance().get_trades_db(
             self.exchange_manager.bot_id,
             storage_util.get_account_type_suffix_from_exchange_manager(self.exchange_manager),
             self.exchange_manager.exchange_name,
         )
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/transactions_storage.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/transactions_storage.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 import octobot_trading.storage.util as storage_util
 
 
 class TransactionsStorage(abstract_storage.AbstractStorage):
     IS_LIVE_CONSUMER = False
     HISTORY_TABLE = commons_enums.DBTables.TRANSACTIONS.value
 
-    @abstract_storage.AbstractStorage.hard_reset_and_retry_if_necessary
     async def _store_history(self):
         transactions = [
             transaction
             for transaction in self.exchange_manager.exchange_personal_data.transactions_manager.transactions.values()
         ]
         y_data = self.plot_settings.y_data or [0] * len(transactions)
         await self._get_db().replace_all(
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/storage/util.py` & `OctoBot-Trading-2.4.9/octobot_trading/storage/util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/supervisors/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/supervisors/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/supervisors/abstract_portfolio_supervisor.py` & `OctoBot-Trading-2.4.9/octobot_trading/supervisors/abstract_portfolio_supervisor.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/supervisors/abstract_supervisor.py` & `OctoBot-Trading-2.4.9/octobot_trading/supervisors/abstract_supervisor.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -27,22 +27,20 @@
 from octobot_trading.util import simulator_updater_utils
 from octobot_trading.util import config_util
 
 from octobot_trading.util.simulator_updater_utils import (
     stop_and_pause,
     pause_time_consumer,
     resume_time_consumer,
-    get_time_channel,
 )
 from octobot_trading.util.config_util import (
     is_trader_enabled,
     is_trader_simulator_enabled,
     is_trade_history_loading_enabled,
     is_currency_enabled,
-    is_symbol_disabled,
     get_symbols,
     get_symbol_trading_type,
     get_symbol_types_counts,
     get_all_currencies,
     get_pairs,
     get_market_pair,
     get_reference_market,
@@ -50,21 +48,19 @@
     get_current_bot_live_id,
 )
 
 __all__ = [
     "stop_and_pause",
     "pause_time_consumer",
     "resume_time_consumer",
-    "get_time_channel",
     "Initializable",
     "is_trader_enabled",
     "is_trader_simulator_enabled",
     "is_trade_history_loading_enabled",
     "is_currency_enabled",
-    "is_symbol_disabled",
     "get_symbols",
     "get_symbol_trading_type",
     "get_symbol_types_counts",
     "get_all_currencies",
     "get_pairs",
     "get_market_pair",
     "get_reference_market",
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/config_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/config_util.py`

 * *Files 3% similar despite different names*

```diff
@@ -48,26 +48,14 @@
 def is_currency_enabled(config, currency, default_value) -> bool:
     try:
         return config[commons_constants.CONFIG_CRYPTO_CURRENCIES][currency][commons_constants.CONFIG_ENABLED_OPTION]
     except KeyError:
         return default_value
 
 
-def is_symbol_disabled(config, symbol) -> bool:
-    for currency_details in config[commons_constants.CONFIG_CRYPTO_CURRENCIES].values():
-        for pair in currency_details[commons_constants.CONFIG_CRYPTO_PAIRS]:
-            if (
-                symbol == symbol_util.parse_symbol(pair).base
-                and currency_details.get(commons_constants.CONFIG_ENABLED_OPTION, True) is False
-            ):
-                return True
-    return False
-
-
-
 def get_symbols(config, enabled_only) -> list:
     if commons_constants.CONFIG_CRYPTO_CURRENCIES in config \
             and isinstance(config[commons_constants.CONFIG_CRYPTO_CURRENCIES], dict):
         return [
             symbol
             for currency, crypto_currency_data in config[commons_constants.CONFIG_CRYPTO_CURRENCIES].items()
             if not enabled_only or is_currency_enabled(config, currency, True)
@@ -99,18 +87,17 @@
         get_symbol_trading_type(symbol) for symbol in enabled_symbols
     )
 
 
 def get_all_currencies(config, enabled_only=False) -> set:
     currencies = set()
     for symbol in get_symbols(config, enabled_only):
-        base, quote = symbol_util.parse_symbol(symbol).base_and_quote()
+        quote, base = symbol_util.parse_symbol(symbol).base_and_quote()
+        currencies.add(quote)
         currencies.add(base)
-        if quote is not None:
-            currencies.add(quote)
     return currencies
 
 
 def get_pairs(config, currency, enabled_only=False) -> list:
     return [
         symbol
         for symbol in get_symbols(config, enabled_only)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/initializable.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/initializable.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/initialization_util.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/initialization_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/simulator_updater_utils.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/simulator_updater_utils.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import async_channel.channels as channels
-import octobot_backtesting.api as backtesting_api
+import octobot_commons.channels_name as channels_name
 
 
 async def stop_and_pause(producer) -> None:
     """
     Stop and pause the provided producer
     :param producer: the producer to stop and pause
     """
@@ -32,24 +32,20 @@
 
 async def pause_time_consumer(producer) -> None:
     """
     Unregister the provided producer's time consumer
     :param producer: the producer to pause
     """
     if producer.time_consumer is not None:
-        await get_time_channel(producer).remove_consumer(producer.time_consumer)
+        await channels.get_chan(
+            channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).remove_consumer(producer.time_consumer)
 
 
 async def resume_time_consumer(producer, producer_time_callback) -> None:
     """
     Register the provided producer's time consumer
     :param producer: the producer to resume
     :param producer_time_callback: the producer TIME_CHANNEL callback
     """
     if producer.time_consumer is None and not producer.channel.is_paused:
-        producer.time_consumer = await get_time_channel(producer).new_consumer(producer_time_callback)
-
-
-def get_time_channel(producer):
-    return channels.get_chan(
-        backtesting_api.get_backtesting_time_channel_name(producer.channel.exchange_manager.exchange.backtesting)
-    )
+        producer.time_consumer = await channels.get_chan(
+            channels_name.OctoBotBacktestingChannelsName.TIME_CHANNEL.value).new_consumer(producer_time_callback)
```

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/__init__.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/octobot_trading/util/test_tools/websocket_test_tools.py` & `OctoBot-Trading-2.4.9/octobot_trading/util/test_tools/websocket_test_tools.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/requirements.txt` & `OctoBot-Trading-2.4.9/requirements.txt`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,19 @@
-numpy==1.26.3
+numpy==1.24.3
 
 # Drakkar-Software requirements
 OctoBot-Backtesting>=1.9, <1.10
 Async-Channel>=2.2, <2.3
-OctoBot-Commons>=1.9.43, <1.10
+OctoBot-Commons>=1.9, <1.10
 OctoBot-Tentacles-Manager>=2.9, <2.10
-trading-backend>=1.2.7
+trading-backend>=1.2.3
 
 # Exchange connection requirements
-# issue from 96, need ccxt==4.2.99
-ccxt==4.2.95 # always ensure real exchanges tests (in tests_additional and authenticated exchange tests) are passing before changing the ccxt version
+ccxt==3.1.52 # always ensure real exchanges tests (in tests_additional and authenticated exchange tests) are passing before changing the ccxt version
 
 cryptography # Never specify a version (managed by https://github.com/Drakkar-Software/OctoBot-PyPi-Linux-Deployer)
 
 # OrderBook requirement
 sortedcontainers==2.4.0
 
 # Scripting requirements
 tinydb==4.5.2
-
-# Caching
-cachetools==5.3.2
```

### Comparing `OctoBot-Trading-2.4.85/setup.py` & `OctoBot-Trading-2.4.9/setup.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/__init__.py` & `OctoBot-Trading-2.4.9/tests/api/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_channels.py` & `OctoBot-Trading-2.4.9/tests/api/test_channels.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_exchange.py` & `OctoBot-Trading-2.4.9/tests/api/test_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_modes.py` & `OctoBot-Trading-2.4.9/tests/api/test_orders.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_orders.py` & `OctoBot-Trading-2.4.9/tests/api/test_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_portfolio.py` & `OctoBot-Trading-2.4.9/tests/api/test_profitability.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_profitability.py` & `OctoBot-Trading-2.4.9/tests/api/test_symbol_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_symbol_data.py` & `OctoBot-Trading-2.4.9/tests/api/test_trader.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/api/test_trader.py` & `OctoBot-Trading-2.4.9/tests/api/test_trades.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/cli/__init__.py` & `OctoBot-Trading-2.4.9/tests/cli/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/contracts/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/contracts/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/contracts/test_future_contract.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/contracts/test_future_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/contracts/test_margin_contract.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/contracts/test_margin_contract.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/funding/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/funding/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/funding/test_funding_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/funding/test_funding_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/kline/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/kline/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/kline/test_kline_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/kline/test_kline_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/test_candles_adapter.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/test_candles_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/ohlcv/test_candles_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/ohlcv/test_candles_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/order_book/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/order_book/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/order_book/test_order_book_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/order_book/test_order_book_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/prices/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/prices/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/prices/test_price_events_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/prices/test_price_events_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/prices/test_prices_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/prices/test_prices_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/recent_trades/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/recent_trades/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/recent_trades/test_recent_trades_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/recent_trades/test_recent_trades_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/test_exchange_symbols_data.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/test_exchange_symbols_data.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/ticker/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/ticker/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchange_data/ticker/test_ticker_manager.py` & `OctoBot-Trading-2.4.9/tests/exchange_data/ticker/test_ticker_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -10,27 +10,25 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
-import copy
 import os
 import mock
 import pytest
 import pytest_asyncio
 
 import octobot_commons.constants as commons_constants
 from octobot_backtesting.backtesting import Backtesting
 from octobot_backtesting.constants import CONFIG_BACKTESTING
 import octobot_backtesting.time as backtesting_time
 from octobot_commons.asyncio_tools import wait_asyncio_next_cycle
 from octobot_commons.enums import TimeFrames
-import octobot_trading.exchanges.connectors.ccxt.ccxt_clients_cache as ccxt_clients_cache
 
 from octobot_commons.tests.test_config import load_test_config
 from octobot_trading.api.exchange import create_exchange_builder, cancel_ccxt_throttle_task
 from octobot_trading.exchanges.exchange_manager import ExchangeManager
 from octobot_trading.exchanges.implementations.default_rest_exchange import DefaultRestExchange
 from octobot_trading.exchanges.connectors.ccxt.ccxt_connector import CCXTConnector
 from octobot_trading.exchanges.traders.trader_simulator import TraderSimulator
@@ -41,37 +39,28 @@
 import tests.exchanges.connectors.ccxt.mock_exchanges_data as mock_exchanges_data
 
 pytestmark = pytest.mark.asyncio
 
 TESTS_FOLDER = "tests"
 TESTS_STATIC_FOLDER = os.path.join(TESTS_FOLDER, "static")
 DEFAULT_EXCHANGE_NAME = "binanceus"
-DEFAULT_LIQUID_EXCHANGE_NAME = "bitget"
 DEFAULT_FUTURE_EXCHANGE_NAME = "bybit"
 
 
-def _load_liquid_exchange_test_config():
-    default_config = load_test_config()
-    default_config[commons_constants.CONFIG_EXCHANGES][DEFAULT_LIQUID_EXCHANGE_NAME] = \
-        copy.deepcopy(default_config[commons_constants.CONFIG_EXCHANGES][DEFAULT_EXCHANGE_NAME])
-    return default_config
-
-
 class MockedCCXTConnector(CCXTConnector):
     @classmethod
     def get_name(cls):
         return DEFAULT_EXCHANGE_NAME
 
-    async def load_symbol_markets(self, reload=False, market_filter=None):
-        if forced_markets := mock_exchanges_data.MOCKED_EXCHANGE_SYMBOL_DETAILS.get(
-            self.exchange_manager.exchange_name, None
-        ):
-            ccxt_clients_cache.set_exchange_parsed_markets(self.exchange_manager.exchange_name, forced_markets)
+    async def load_symbol_markets(self, reload=False, forced_markets=None):
+        if forced_markets is None:
+            forced_markets = mock_exchanges_data.MOCKED_EXCHANGE_INFO.get(self.exchange_manager.exchange_name, None)
         await super().load_symbol_markets(
             reload=reload,
+            forced_markets=forced_markets
         )
 
     def _should_authenticate(self):
         return False
 
 
 class MockedRestExchange(DefaultRestExchange):
@@ -128,29 +117,14 @@
         cancel_ccxt_throttle_task()
         await exchange_manager_instance.stop()
         # let updaters gracefully shutdown
         await wait_asyncio_next_cycle()
 
 
 @pytest_asyncio.fixture
-async def liquid_exchange_manager():
-    exchange_manager_instance = ExchangeManager(_load_liquid_exchange_test_config(), DEFAULT_LIQUID_EXCHANGE_NAME)
-    exchange_manager_instance.is_spot_only = True
-    exchange_manager_instance.is_simulated = False
-    await exchange_manager_instance.initialize()
-    try:
-        yield exchange_manager_instance
-    finally:
-        cancel_ccxt_throttle_task()
-        await exchange_manager_instance.stop()
-        # let updaters gracefully shutdown
-        await wait_asyncio_next_cycle()
-
-
-@pytest_asyncio.fixture
 async def simulated_exchange_manager():
     exchange_manager_instance = ExchangeManager(load_test_config(), DEFAULT_EXCHANGE_NAME)
     exchange_manager_instance.is_spot_only = True
     exchange_manager_instance.is_simulated = True
     await exchange_manager_instance.initialize()
     try:
         yield exchange_manager_instance
@@ -275,15 +249,14 @@
     if hasattr(request, "param"):
         config, exchange_name, is_spot, is_margin, is_future = request.param
 
     if config is None:
         config = backtesting_config
     exchange_manager_instance = ExchangeManager(config, exchange_name)
     exchange_manager_instance.is_backtesting = True
-    exchange_manager_instance.use_cached_markets = False
     exchange_manager_instance.is_spot_only = is_spot
     exchange_manager_instance.is_margin = is_margin
     exchange_manager_instance.is_future = is_future
     exchange_manager_instance.backtesting = fake_backtesting
     exchange_manager_instance.backtesting.time_manager = backtesting_time.TimeManager(config)
     await exchange_manager_instance.initialize()
     yield exchange_manager_instance
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/connectors/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/connectors/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/mock_exchanges_data.py` & `OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/mock_exchanges_data.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,10 +11,10 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 
 
-MOCKED_EXCHANGE_SYMBOL_DETAILS = {
+MOCKED_EXCHANGE_INFO = {
     "bybit": [{'id': 'BLZUSDT', 'symbol': 'BLZ/USDT:USDT', 'base': 'BLZ', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BLZ', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 98500.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BLZUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BLZ', 'quoteCoin': 'USDT', 'launchTime': '1654497673000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '98500', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '985000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'BNBPERP', 'symbol': 'BNB/USD:USDC', 'base': 'BNB', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BNB', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 250.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BNBPERP', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BNB', 'quoteCoin': 'USD', 'launchTime': '1664459242000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '250.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '1250.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BNBUSDT', 'symbol': 'BNB/USDT:USDT', 'base': 'BNB', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BNB', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 1300.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BNBUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BNB', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '1300.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '13000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'BNXUSDT', 'symbol': 'BNX/USDT:USDT', 'base': 'BNX', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BNX', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 35000.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BNXUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BNX', 'quoteCoin': 'USDT', 'launchTime': '1677564318000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '35000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '175000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'BOBAUSDT', 'symbol': 'BOBA/USDT:USDT', 'base': 'BOBA', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BOBA', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 0.1, 'max': 9900.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BOBAUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BOBA', 'quoteCoin': 'USDT', 'launchTime': '1649231761000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '9900.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '99000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'BSVUSDT', 'symbol': 'BSV/USDT:USDT', 'base': 'BSV', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BSV', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 180.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BSVUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BSV', 'quoteCoin': 'USDT', 'launchTime': '1639105708000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '180.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '1800.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'BSWUSDT', 'symbol': 'BSW/USDT:USDT', 'base': 'BSW', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BSW', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 19500.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BSWUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BSW', 'quoteCoin': 'USDT', 'launchTime': '1648017126000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '19500', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '195000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'BTC-04AUG23', 'symbol': 'BTC/USD:USDC-230804', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1691136000000, 'expiryDatetime': '2023-08-04T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-04AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1689321600000', 'deliveryTime': '1691136000000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-11AUG23', 'symbol': 'BTC/USD:USDC-230811', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1691740800000, 'expiryDatetime': '2023-08-11T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-11AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1689926400000', 'deliveryTime': '1691740800000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-25AUG23', 'symbol': 'BTC/USD:USDC-230825', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1692950400000, 'expiryDatetime': '2023-08-25T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-25AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1686297600000', 'deliveryTime': '1692950400000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-28JUL23', 'symbol': 'BTC/USD:USDC-230728', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1690531200000, 'expiryDatetime': '2023-07-28T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-28JUL23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1683273600000', 'deliveryTime': '1690531200000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-29DEC23', 'symbol': 'BTC/USD:USDC-231229', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1703836800000, 'expiryDatetime': '2023-12-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-29DEC23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1680854400000', 'deliveryTime': '1703836800000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-29MAR24', 'symbol': 'BTC/USD:USDC-240329', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1711699200000, 'expiryDatetime': '2024-03-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-29MAR24', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1688716800000', 'deliveryTime': '1711699200000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTC-29SEP23', 'symbol': 'BTC/USD:USDC-230929', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1695974400000, 'expiryDatetime': '2023-09-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.5}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.001, 'max': 10.0}, 'price': {'min': 0.5, 'max': 999999.0}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTC-29SEP23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1679644800000', 'deliveryTime': '1695974400000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.50', 'maxPrice': '999999.00', 'tickSize': '0.50'}, 'lotSizeFilter': {'maxOrderQty': '10.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '50.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTCPERP', 'symbol': 'BTC/USD:USDC', 'base': 'BTC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'BTC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.1}, 'limits': {'leverage': {'min': 1.0, 'max': 125.0}, 'amount': {'min': 0.001, 'max': 20.0}, 'price': {'min': 0.1, 'max': 199999.8}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTCPERP', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USD', 'launchTime': '1610604231000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '125.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.10', 'maxPrice': '199999.80', 'tickSize': '0.10'}, 'lotSizeFilter': {'maxOrderQty': '20.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '100.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'BTCUSDT', 'symbol': 'BTC/USDT:USDT', 'base': 'BTC', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BTC', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.001, 'price': 0.1}, 'limits': {'leverage': {'min': 1.0, 'max': 100.0}, 'amount': {'min': 0.001, 'max': 100.0}, 'price': {'min': 0.1, 'max': 199999.8}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BTCUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BTC', 'quoteCoin': 'USDT', 'launchTime': '1584230400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '100.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.10', 'maxPrice': '199999.80', 'tickSize': '0.10'}, 'lotSizeFilter': {'maxOrderQty': '100.000', 'minOrderQty': '0.001', 'qtyStep': '0.001', 'postOnlyMaxOrderQty': '1000.000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'BUSDUSDT', 'symbol': 'BUSD/USDT:USDT', 'base': 'BUSD', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'BUSD', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 100000.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'BUSDUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'BUSD', 'quoteCoin': 'USDT', 'launchTime': '1676340857000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '100000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '500000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'C98USDT', 'symbol': 'C98/USDT:USDT', 'base': 'C98', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'C98', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 31200.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'C98USDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'C98', 'quoteCoin': 'USDT', 'launchTime': '1635120000000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '31200.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '312000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CEEKUSDT', 'symbol': 'CEEK/USDT:USDT', 'base': 'CEEK', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CEEK', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 18200.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CEEKUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CEEK', 'quoteCoin': 'USDT', 'launchTime': '1658127698000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '18200', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '182000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CELOUSDT', 'symbol': 'CELO/USDT:USDT', 'base': 'CELO', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CELO', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 0.1, 'max': 17400.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CELOUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CELO', 'quoteCoin': 'USDT', 'launchTime': '1641367582000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '17400.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '174000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CELRUSDT', 'symbol': 'CELR/USDT:USDT', 'base': 'CELR', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CELR', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 775600.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CELRUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CELR', 'quoteCoin': 'USDT', 'launchTime': '1635120000000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '775600', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '7756000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CFXUSDT', 'symbol': 'CFX/USDT:USDT', 'base': 'CFX', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CFX', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 1.0, 'max': 500000.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CFXUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CFX', 'quoteCoin': 'USDT', 'launchTime': '1676883925000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '500000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '2500000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'CHRUSDT', 'symbol': 'CHR/USDT:USDT', 'base': 'CHR', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CHR', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 50200.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CHRUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CHR', 'quoteCoin': 'USDT', 'launchTime': '1637193600000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '50200.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '502000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CHZUSDT', 'symbol': 'CHZ/USDT:USDT', 'base': 'CHZ', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CHZ', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 700000.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CHZUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CHZ', 'quoteCoin': 'USDT', 'launchTime': '1633996800000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '700000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '7000000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'CKBUSDT', 'symbol': 'CKB/USDT:USDT', 'base': 'CKB', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CKB', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 10.0, 'price': 5e-06}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 10.0, 'max': 740000.0}, 'price': {'min': 5e-06, 'max': 9.99999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CKBUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CKB', 'quoteCoin': 'USDT', 'launchTime': '1644901148000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '6', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.000005', 'maxPrice': '9.999990', 'tickSize': '0.000005'}, 'lotSizeFilter': {'maxOrderQty': '740000', 'minOrderQty': '10', 'qtyStep': '10', 'postOnlyMaxOrderQty': '7400000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'COMBOUSDT', 'symbol': 'COMBO/USDT:USDT', 'base': 'COMBO', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'COMBO', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 0.1, 'max': 18000.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'COMBOUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'COMBO', 'quoteCoin': 'USDT', 'launchTime': '1686210792000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '18000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '90000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'COMPUSDT', 'symbol': 'COMP/USDT:USDT', 'base': 'COMP', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'COMP', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 640.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'COMPUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'COMP', 'quoteCoin': 'USDT', 'launchTime': '1628726400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '640.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '6400.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'COREUSDT', 'symbol': 'CORE/USDT:USDT', 'base': 'CORE', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CORE', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 10000.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'COREUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CORE', 'quoteCoin': 'USDT', 'launchTime': '1675927514000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '10000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '50000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'COTIUSDT', 'symbol': 'COTI/USDT:USDT', 'base': 'COTI', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'COTI', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 16.67}, 'amount': {'min': 1.0, 'max': 182000.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'COTIUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'COTI', 'quoteCoin': 'USDT', 'launchTime': '1638445117000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '16.67', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '182000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '1820000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CROUSDT', 'symbol': 'CRO/USDT:USDT', 'base': 'CRO', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CRO', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 90000.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CROUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CRO', 'quoteCoin': 'USDT', 'launchTime': '1637625600000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '90000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '900000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CRVUSDT', 'symbol': 'CRV/USDT:USDT', 'base': 'CRV', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CRV', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 70000.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CRVUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CRV', 'quoteCoin': 'USDT', 'launchTime': '1635120000000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '70000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '700000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'CTCUSDT', 'symbol': 'CTC/USDT:USDT', 'base': 'CTC', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CTC', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 1.0, 'max': 3500.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CTCUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CTC', 'quoteCoin': 'USDT', 'launchTime': '1652774270000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '3500', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '35000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CTKUSDT', 'symbol': 'CTK/USDT:USDT', 'base': 'CTK', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CTK', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 16.67}, 'amount': {'min': 0.1, 'max': 17200.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CTKUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CTK', 'quoteCoin': 'USDT', 'launchTime': '1638444847000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '16.67', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '17200.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '172000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CTSIUSDT', 'symbol': 'CTSI/USDT:USDT', 'base': 'CTSI', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CTSI', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 156000.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CTSIUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CTSI', 'quoteCoin': 'USDT', 'launchTime': '1648018511000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '156000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '1560000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CVCUSDT', 'symbol': 'CVC/USDT:USDT', 'base': 'CVC', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CVC', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 1.0, 'max': 91800.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CVCUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CVC', 'quoteCoin': 'USDT', 'launchTime': '1638285651000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '91800', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '918000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'CVXUSDT', 'symbol': 'CVX/USDT:USDT', 'base': 'CVX', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'CVX', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 1200.0}, 'price': {'min': 0.005, 'max': 9999.99}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'CVXUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'CVX', 'quoteCoin': 'USDT', 'launchTime': '1650440282000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.005', 'maxPrice': '9999.990', 'tickSize': '0.005'}, 'lotSizeFilter': {'maxOrderQty': '1200.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '12000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DARUSDT', 'symbol': 'DAR/USDT:USDT', 'base': 'DAR', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DAR', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 27525.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DARUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DAR', 'quoteCoin': 'USDT', 'launchTime': '1651467113000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '27525.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '275250.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DASHUSDT', 'symbol': 'DASH/USDT:USDT', 'base': 'DASH', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DASH', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 410.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DASHUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DASH', 'quoteCoin': 'USDT', 'launchTime': '1633996800000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '410.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '4100.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DENTUSDT', 'symbol': 'DENT/USDT:USDT', 'base': 'DENT', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DENT', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 100.0, 'price': 1e-06}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 100.0, 'max': 9800000.0}, 'price': {'min': 1e-06, 'max': 1.999998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DENTUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DENT', 'quoteCoin': 'USDT', 'launchTime': '1642068928000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '6', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.000001', 'maxPrice': '1.999998', 'tickSize': '0.000001'}, 'lotSizeFilter': {'maxOrderQty': '9800000', 'minOrderQty': '100', 'qtyStep': '100', 'postOnlyMaxOrderQty': '98000000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DGBUSDT', 'symbol': 'DGB/USDT:USDT', 'base': 'DGB', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DGB', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 10.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 10.0, 'max': 351400.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DGBUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DGB', 'quoteCoin': 'USDT', 'launchTime': '1648452331000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '351400', 'minOrderQty': '10', 'qtyStep': '10', 'postOnlyMaxOrderQty': '3514000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DODOUSDT', 'symbol': 'DODO/USDT:USDT', 'base': 'DODO', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DODO', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 46000.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DODOUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DODO', 'quoteCoin': 'USDT', 'launchTime': '1650457800000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '46000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '460000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DOGEUSDT', 'symbol': 'DOGE/USDT:USDT', 'base': 'DOGE', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DOGE', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 75.0}, 'amount': {'min': 1.0, 'max': 10000000.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DOGEUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DOGE', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '75.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '10000000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '100000000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'DOTUSDT', 'symbol': 'DOT/USDT:USDT', 'base': 'DOT', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DOT', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.1, 'max': 32900.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DOTUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DOT', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '32900.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '329000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'DUSKUSDT', 'symbol': 'DUSK/USDT:USDT', 'base': 'DUSK', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DUSK', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 12.5}, 'amount': {'min': 1.0, 'max': 52500.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DUSKUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DUSK', 'quoteCoin': 'USDT', 'launchTime': '1639673130000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '12.50', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '52500', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '525000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'DYDXUSDT', 'symbol': 'DYDX/USDT:USDT', 'base': 'DYDX', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'DYDX', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 45000.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'DYDXUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'DYDX', 'quoteCoin': 'USDT', 'launchTime': '1633910400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '45000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '450000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'EDUUSDT', 'symbol': 'EDU/USDT:USDT', 'base': 'EDU', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'EDU', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 20000.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'EDUUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'EDU', 'quoteCoin': 'USDT', 'launchTime': '1683273334000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '20000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '100000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'EGLDUSDT', 'symbol': 'EGLD/USDT:USDT', 'base': 'EGLD', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'EGLD', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 1300.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'EGLDUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'EGLD', 'quoteCoin': 'USDT', 'launchTime': '1637596800000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '1300.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '13000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'ENJUSDT', 'symbol': 'ENJ/USDT:USDT', 'base': 'ENJ', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'ENJ', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 116000.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ENJUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ENJ', 'quoteCoin': 'USDT', 'launchTime': '1635696000000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '116000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '1160000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'ENSUSDT', 'symbol': 'ENS/USDT:USDT', 'base': 'ENS', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'ENS', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.01}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 1600.0}, 'price': {'min': 0.01, 'max': 19999.98}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ENSUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ENS', 'quoteCoin': 'USDT', 'launchTime': '1636675200000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.01', 'maxPrice': '19999.98', 'tickSize': '0.01'}, 'lotSizeFilter': {'maxOrderQty': '1600.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '16000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'EOSUSDT', 'symbol': 'EOS/USDT:USDT', 'base': 'EOS', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'EOS', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.1, 'max': 55000.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'EOSUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'EOS', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '55000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '550000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'ETCPERP', 'symbol': 'ETC/USD:USDC', 'base': 'ETC', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETC', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.005}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.1, 'max': 500.0}, 'price': {'min': 0.005, 'max': 9999.99}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETCPERP', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ETC', 'quoteCoin': 'USD', 'launchTime': '1661990400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.005', 'maxPrice': '9999.990', 'tickSize': '0.005'}, 'lotSizeFilter': {'maxOrderQty': '500.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '2500.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETCUSDT', 'symbol': 'ETC/USDT:USDT', 'base': 'ETC', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'ETC', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.005}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.1, 'max': 10000.0}, 'price': {'min': 0.005, 'max': 9999.99}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETCUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ETC', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.005', 'maxPrice': '9999.990', 'tickSize': '0.005'}, 'lotSizeFilter': {'maxOrderQty': '10000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '100000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'ETH-04AUG23', 'symbol': 'ETH/USD:USDC-230804', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1691136000000, 'expiryDatetime': '2023-08-04T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-04AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1689321600000', 'deliveryTime': '1691136000000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-11AUG23', 'symbol': 'ETH/USD:USDC-230811', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1691740800000, 'expiryDatetime': '2023-08-11T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-11AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1689926400000', 'deliveryTime': '1691740800000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-25AUG23', 'symbol': 'ETH/USD:USDC-230825', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1692950400000, 'expiryDatetime': '2023-08-25T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-25AUG23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1686297600000', 'deliveryTime': '1692950400000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-28JUL23', 'symbol': 'ETH/USD:USDC-230728', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1690531200000, 'expiryDatetime': '2023-07-28T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-28JUL23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1683273600000', 'deliveryTime': '1690531200000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-29DEC23', 'symbol': 'ETH/USD:USDC-231229', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1703836800000, 'expiryDatetime': '2023-12-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-29DEC23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1680854400000', 'deliveryTime': '1703836800000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-29MAR24', 'symbol': 'ETH/USD:USDC-240329', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1711699200000, 'expiryDatetime': '2024-03-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-29MAR24', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1688716800000', 'deliveryTime': '1711699200000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETH-29SEP23', 'symbol': 'ETH/USD:USDC-230929', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'future', 'spot': False, 'margin': None, 'swap': False, 'future': True, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': 1695974400000, 'expiryDatetime': '2023-09-29T08:00:00.000Z', 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.05}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 0.01, 'max': 150.0}, 'price': {'min': 0.05, 'max': 99999.9}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETH-29SEP23', 'contractType': 'LinearFutures', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1679644800000', 'deliveryTime': '1695974400000', 'deliveryFeeRate': '0', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.05', 'maxPrice': '99999.90', 'tickSize': '0.05'}, 'lotSizeFilter': {'maxOrderQty': '150.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '750.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETHPERP', 'symbol': 'ETH/USD:USDC', 'base': 'ETH', 'quote': 'USD', 'settle': 'USDC', 'baseId': 'ETH', 'quoteId': 'USD', 'settleId': 'USDC', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.01}, 'limits': {'leverage': {'min': 1.0, 'max': 66.67}, 'amount': {'min': 0.01, 'max': 400.0}, 'price': {'min': 0.01, 'max': 19999.98}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETHPERP', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USD', 'launchTime': '1659657600000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '66.67', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.01', 'maxPrice': '19999.98', 'tickSize': '0.01'}, 'lotSizeFilter': {'maxOrderQty': '400.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '2000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDC', 'copyTrading': 'none'}}, {'id': 'ETHUSDT', 'symbol': 'ETH/USDT:USDT', 'base': 'ETH', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'ETH', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.01}, 'limits': {'leverage': {'min': 1.0, 'max': 100.0}, 'amount': {'min': 0.01, 'max': 1500.0}, 'price': {'min': 0.01, 'max': 19999.98}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETHUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ETH', 'quoteCoin': 'USDT', 'launchTime': '1615766400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '2', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '100.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.01', 'maxPrice': '19999.98', 'tickSize': '0.01'}, 'lotSizeFilter': {'maxOrderQty': '1500.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '15000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'ETHWUSDT', 'symbol': 'ETHW/USDT:USDT', 'base': 'ETHW', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'ETHW', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 7500.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'ETHWUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'ETHW', 'quoteCoin': 'USDT', 'launchTime': '1663286400000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '7500.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '75000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'FETUSDT', 'symbol': 'FET/USDT:USDT', 'base': 'FET', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FET', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 250000.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FETUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FET', 'quoteCoin': 'USDT', 'launchTime': '1675759851000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '250000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '1250000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'FILUSDT', 'symbol': 'FIL/USDT:USDT', 'base': 'FIL', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FIL', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.001}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 45000.0}, 'price': {'min': 0.001, 'max': 1999.998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FILUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FIL', 'quoteCoin': 'USDT', 'launchTime': '0', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '3', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.001', 'maxPrice': '1999.998', 'tickSize': '0.001'}, 'lotSizeFilter': {'maxOrderQty': '45000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '450000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'FITFIUSDT', 'symbol': 'FITFI/USDT:USDT', 'base': 'FITFI', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FITFI', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-06}, 'limits': {'leverage': {'min': 1.0, 'max': 50.0}, 'amount': {'min': 1.0, 'max': 200000.0}, 'price': {'min': 5e-06, 'max': 9.99999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FITFIUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FITFI', 'quoteCoin': 'USDT', 'launchTime': '1652153037000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '6', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '50.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.000005', 'maxPrice': '9.999990', 'tickSize': '0.000005'}, 'lotSizeFilter': {'maxOrderQty': '200000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '2000000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'FLMUSDT', 'symbol': 'FLM/USDT:USDT', 'base': 'FLM', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FLM', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 5e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 1.0, 'max': 72500.0}, 'price': {'min': 5e-05, 'max': 99.9999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FLMUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FLM', 'quoteCoin': 'USDT', 'launchTime': '1651467612000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00005', 'maxPrice': '99.99990', 'tickSize': '0.00005'}, 'lotSizeFilter': {'maxOrderQty': '72500', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '725000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'FLOWUSDT', 'symbol': 'FLOW/USDT:USDT', 'base': 'FLOW', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FLOW', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.1, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.1, 'max': 23000.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FLOWUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FLOW', 'quoteCoin': 'USDT', 'launchTime': '1637856000000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '23000.0', 'minOrderQty': '0.1', 'qtyStep': '0.1', 'postOnlyMaxOrderQty': '230000.0'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'FLRUSDT', 'symbol': 'FLR/USDT:USDT', 'base': 'FLR', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FLR', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 10.0, 'price': 1e-05}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 10.0, 'max': 379680.0}, 'price': {'min': 1e-05, 'max': 19.99998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FLRUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FLR', 'quoteCoin': 'USDT', 'launchTime': '1678953508000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '5', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.00001', 'maxPrice': '19.99998', 'tickSize': '0.00001'}, 'lotSizeFilter': {'maxOrderQty': '379680', 'minOrderQty': '10', 'qtyStep': '10', 'postOnlyMaxOrderQty': '1898400'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}, {'id': 'FTMUSDT', 'symbol': 'FTM/USDT:USDT', 'base': 'FTM', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FTM', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 1.0, 'price': 0.0001}, 'limits': {'leverage': {'min': 1.0, 'max': 75.0}, 'amount': {'min': 1.0, 'max': 360000.0}, 'price': {'min': 0.0001, 'max': 199.9998}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FTMUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FTM', 'quoteCoin': 'USDT', 'launchTime': '1632355200000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '75.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0001', 'maxPrice': '199.9998', 'tickSize': '0.0001'}, 'lotSizeFilter': {'maxOrderQty': '360000', 'minOrderQty': '1', 'qtyStep': '1', 'postOnlyMaxOrderQty': '3600000'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'normalOnly'}}, {'id': 'FXSUSDT', 'symbol': 'FXS/USDT:USDT', 'base': 'FXS', 'quote': 'USDT', 'settle': 'USDT', 'baseId': 'FXS', 'quoteId': 'USDT', 'settleId': 'USDT', 'type': 'swap', 'spot': False, 'margin': None, 'swap': True, 'future': False, 'option': False, 'active': True, 'contract': True, 'linear': True, 'inverse': False, 'taker': 0.0006, 'maker': 0.0001, 'contractSize': 1.0, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 0.01, 'price': 0.0005}, 'limits': {'leverage': {'min': 1.0, 'max': 25.0}, 'amount': {'min': 0.01, 'max': 2400.0}, 'price': {'min': 0.0005, 'max': 999.999}, 'cost': {'min': None, 'max': None}}, 'info': {'symbol': 'FXSUSDT', 'contractType': 'LinearPerpetual', 'status': 'Trading', 'baseCoin': 'FXS', 'quoteCoin': 'USDT', 'launchTime': '1649044820000', 'deliveryTime': '0', 'deliveryFeeRate': '', 'priceScale': '4', 'leverageFilter': {'minLeverage': '1', 'maxLeverage': '25.00', 'leverageStep': '0.01'}, 'priceFilter': {'minPrice': '0.0005', 'maxPrice': '999.9990', 'tickSize': '0.0005'}, 'lotSizeFilter': {'maxOrderQty': '2400.00', 'minOrderQty': '0.01', 'qtyStep': '0.01', 'postOnlyMaxOrderQty': '24000.00'}, 'unifiedMarginTrade': True, 'fundingInterval': '480', 'settleCoin': 'USDT', 'copyTrading': 'none'}}]
 }
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/connectors/ccxt/test_ccxt_connector.py` & `OctoBot-Trading-2.4.9/tests/exchanges/connectors/ccxt/test_ccxt_connector.py`

 * *Files 11% similar despite different names*

```diff
@@ -17,15 +17,14 @@
 import decimal
 
 from mock import patch
 
 import octobot_trading.exchanges.connectors as exchange_connectors
 import octobot_trading.enums as enums
 import octobot_trading.exchange_data.contracts as contracts
-import octobot_trading.exchanges.connectors.ccxt.ccxt_clients_cache as ccxt_clients_cache
 import pytest
 
 import tests.exchanges.connectors.ccxt.mock_exchanges_data as mock_exchanges_data
 from tests.exchanges import exchange_manager, future_simulated_exchange_manager, set_future_exchange_fees
 from tests.exchanges.traders import future_trader, future_trader_simulator_with_default_linear, DEFAULT_FUTURE_SYMBOL, \
     DEFAULT_FUTURE_SYMBOL_MARGIN_TYPE, DEFAULT_FUTURE_SYMBOL_LEVERAGE
 
@@ -40,56 +39,44 @@
 
 async def test_initialize_impl_with_none_symbols_and_timeframes(ccxt_connector):
 
     class MockCCXT:
         def __init__(self):
             self.symbols = None
             self.timeframes = None
-            self.markets = {}
-            self.set_markets_calls = []
 
         async def load_markets(self, reload=False):
             pass
 
-        def set_markets(self, markets):
-            self.set_markets_calls.append(markets)
-
         def setSandboxMode(self, is_sandboxed):
             pass
 
-    with patch.object(ccxt_connector, 'client', new=MockCCXT()) as mocked_ccxt:
+    with patch.object(ccxt_connector, 'client', new=MockCCXT()):
         await ccxt_connector.initialize_impl()
         assert ccxt_connector.symbols == set()
         assert ccxt_connector.time_frames == set()
-        assert mocked_ccxt.set_markets_calls in ([[]], [])  # depends on call order
 
 
 async def test_initialize_impl_with_empty_symbols_and_timeframes(ccxt_connector):
 
     class MockCCXT:
         def __init__(self):
             self.symbols = []
             self.timeframes = []
-            self.markets = {}
-            self.set_markets_calls = []
 
         async def load_markets(self, reload=False):
             pass
 
-        def set_markets(self, markets):
-            self.set_markets_calls.append(markets)
-
         def setSandboxMode(self, is_sandboxed):
             pass
 
-    with patch.object(ccxt_connector, 'client', new=MockCCXT()) as mocked_ccxt:
+    with patch.object(ccxt_connector, 'client', new=MockCCXT()):
         await ccxt_connector.initialize_impl()
         assert ccxt_connector.symbols == set()
         assert ccxt_connector.time_frames == set()
-        assert mocked_ccxt.set_markets_calls in ([[]], [])  # depends on call order
 
 
 async def test_initialize_impl(ccxt_connector):
 
     class MockCCXT:
         def __init__(self):
             self.symbols = [
@@ -100,39 +87,33 @@
             ]
             self.timeframes = [
                 "1h",
                 "2h",
                 "4h",
                 "2h"
             ]
-            self.markets = {}
-            self.set_markets_calls = []
 
         async def load_markets(self, reload=False):
             pass
 
-        def set_markets(self, markets):
-            self.set_markets_calls.append(markets)
-
         def setSandboxMode(self, is_sandboxed):
             pass
 
-    with patch.object(ccxt_connector, 'client', new=MockCCXT()) as mocked_ccxt:
+    with patch.object(ccxt_connector, 'client', new=MockCCXT()):
         await ccxt_connector.initialize_impl()
         assert ccxt_connector.symbols == {
             "BTC/USDT",
             "ETH/USDT",
             "ETH/BTC",
         }
         assert ccxt_connector.time_frames == {
             "1h",
             "2h",
             "4h",
         }
-        assert mocked_ccxt.set_markets_calls in ([[]], [])  # depends on call order
 
 
 async def test_set_symbol_partial_take_profit_stop_loss(ccxt_connector):
     with pytest.raises(NotImplementedError):
         await ccxt_connector.set_symbol_partial_take_profit_stop_loss("BTC/USDT", False,
                                                                      enums.TakeProfitStopLossMode.PARTIAL)
 
@@ -168,21 +149,17 @@
     assert spot_ccxt_exchange.get_trade_fee(spot_symbol, enums.TraderOrderType.SELL_LIMIT, decimal.Decimal("0.45"),
                                             decimal.Decimal(10000), "maker") == \
            _get_fees("maker", "USDT", 0.001, decimal.Decimal("4.5"))
 
     # future trading
     fut_ccxt_exchange.client.options['defaultType'] = enums.ExchangeTypes.FUTURE.value
 
-    if forced_markets := mock_exchanges_data.MOCKED_EXCHANGE_SYMBOL_DETAILS.get(
-        fut_exchange_manager_inst.exchange_name, None
-    ):
-        ccxt_clients_cache.set_exchange_parsed_markets(
-            fut_exchange_manager_inst.exchange_name, forced_markets
-        )
-    await fut_ccxt_exchange.load_symbol_markets()
+    await fut_ccxt_exchange.load_symbol_markets(
+        forced_markets=mock_exchanges_data.MOCKED_EXCHANGE_INFO.get(fut_exchange_manager_inst.exchange_name, None)
+    )
     # enforce taker and maker values
     set_future_exchange_fees(fut_ccxt_exchange, future_symbol, taker=future_fees_value, maker=future_fees_value)
     assert future_fees_value / 5 <= fut_ccxt_exchange.client.markets[future_symbol]['taker'] <= future_fees_value * 5
     # linear
     assert fut_ccxt_exchange.get_trade_fee(future_symbol, enums.TraderOrderType.BUY_LIMIT, decimal.Decimal("0.45"),
                                            decimal.Decimal(10000), "taker") == \
            _get_fees("taker", "USDT", future_fees_value, decimal.Decimal("1.800000"))
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/implementations/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/implementations/test_default_rest_exchange.py` & `OctoBot-Trading-2.4.9/tests/exchanges/implementations/test_default_rest_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/implementations/test_default_websocket_exchange.py` & `OctoBot-Trading-2.4.9/tests/exchanges/implementations/test_default_websocket_exchange.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 import asyncio
 import mock
 
 import octobot_trading.exchanges as exchanges
 import octobot_trading.enums as enums
 import pytest
 
-from tests.exchanges import liquid_exchange_manager as liquid_exchange_manager_fixture, DEFAULT_EXCHANGE_NAME
+from tests.exchanges import exchange_manager as exchange_manager_fixture, DEFAULT_EXCHANGE_NAME
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 class FeedCallback:
     def __init__(self, connector, feed):
@@ -115,16 +115,16 @@
 
     @classmethod
     def get_exchange_connector_class(cls, exchange_manager):
         return cls.DEFAULT_CONNECTOR_CLASS
 
 
 @pytest.fixture
-def default_websocket_exchange(liquid_exchange_manager_fixture):
-    yield MockedWebSocketExchange(liquid_exchange_manager_fixture.config, liquid_exchange_manager_fixture)
+def default_websocket_exchange(exchange_manager_fixture):
+    yield MockedWebSocketExchange(exchange_manager_fixture.config, exchange_manager_fixture)
 
 
 async def test_start_receive_feeds_and_stop(default_websocket_exchange):
     await default_websocket_exchange.init_websocket(
         default_websocket_exchange.exchange_manager.exchange_config.traded_time_frames,
         default_websocket_exchange.exchange_manager.exchange_config.traded_symbol_pairs,
         default_websocket_exchange.exchange_manager.tentacles_setup_config
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_abstract_exchange.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_abstract_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_abstract_websocket_exchange.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_abstract_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_builder.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_builder.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_config_data.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_config_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -76,26 +76,24 @@
                 "enabled": False,
                 "pairs": ["*"],
                 "quote": "ETH"
             }
         }
         _, exchange_manager = await self.init_default(config=config)
 
+        assert "UNI/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ADA/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "MATIC/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ONT/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BNB" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
 
-        # inactive markets
-        assert "UNI/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
-
         # disabled
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
         assert "ADA/ETH" not in exchange_manager.exchange_config.traded_symbol_pairs
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
 
@@ -111,20 +109,18 @@
             },
             "Ethereum": {
                 "pairs": ["*"],
             }
         }
         _, exchange_manager = await self.init_default(config=config)
 
+        assert "TRX/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
         assert "ADA/BTC" in exchange_manager.exchange_config.traded_symbol_pairs
         assert "Bitcoin" in exchange_manager.exchange_config.traded_cryptocurrencies
 
-        # inactive markets
-        assert "TRX/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
-
         # invalid ETH wildcard config
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
 
     async def test_traded_pairs_with_add(self):
@@ -141,27 +137,25 @@
                 "quote": "ETH",
                 "add": ["ETH/USDT"]
             }
         }
 
         _, exchange_manager = await self.init_default(config=config)
 
+        assert "UNI/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ADA/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "MATIC/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "LINK/BTC" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ONT/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "AVAX/BNB" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
         assert "BTC/USDT" in exchange_manager.exchange_config.traded_symbol_pairs
 
-        # inactive markets
-        assert "UNI/BTC" not in exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"]
-
         # disabled
         assert "Ethereum" not in exchange_manager.exchange_config.traded_cryptocurrencies
         assert "ADA/ETH" not in exchange_manager.exchange_config.traded_symbol_pairs
         assert "ETH/USDT" not in exchange_manager.exchange_config.traded_symbol_pairs
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
 
@@ -191,18 +185,16 @@
                 ]
             }
         }
 
         _, exchange_manager = await self.init_default(config=config)
 
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Binance Coin"] == ["BNB/USDT"]
+        assert exchange_manager.exchange_config.traded_cryptocurrencies["Binance USD"] == ["BNB/BUSD"]
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Bitcoin"] == ["BNB/BTC"]
         assert exchange_manager.exchange_config.traded_cryptocurrencies["Tether"] == ["BNB/USDT"]
 
-        # inactive markets
-        assert exchange_manager.exchange_config.traded_cryptocurrencies["Binance USD"] == []
-
-        sorted_pairs_without_redundancy = sorted(["BNB/USDT", "BNB/BTC"])
+        sorted_pairs_without_redundancy = sorted(["BNB/USDT", "BNB/BUSD", "BNB/BTC"])
         assert sorted(exchange_manager.exchange_config.traded_symbol_pairs) == sorted_pairs_without_redundancy
 
         cancel_ccxt_throttle_task()
         await exchange_manager.stop()
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_factory.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_exchange_manager.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_exchange_manager.py`

 * *Files 4% similar despite different names*

```diff
@@ -36,15 +36,15 @@
         if not config:
             config = load_test_config()
 
         exchange_manager = ExchangeManager(config, TestExchangeManager.EXCHANGE_NAME)
         exchange_manager.is_simulated = simulated
         exchange_manager.is_backtesting = backtesting
         if backtesting:
-            exchange_manager.backtesting = Backtesting(None, [exchange_manager.id], None, [], False)
+            exchange_manager.backtesting = Backtesting(None, [exchange_manager.id], None, [])
         exchange_manager.rest_only = True
 
         await exchange_manager.initialize()
         return config, exchange_manager
 
     async def test_create_exchange(self):
         # simulated
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/test_exchanges.py` & `OctoBot-Trading-2.4.9/tests/exchanges/test_exchanges.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/traders/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/traders/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/traders/test_trader.py` & `OctoBot-Trading-2.4.9/tests/exchanges/traders/test_trader.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,26 +14,24 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import copy
 import os
 import ccxt.async_support
 import decimal
 
-import mock
 import pytest
 import time
 from mock import AsyncMock, patch, Mock
 
 from octobot_trading.errors import TooManyOpenPositionError, InvalidLeverageValue, OrderEditError
 from octobot_trading.personal_data import LinearPosition
 import octobot_commons.constants as commons_constants
 from octobot_commons.asyncio_tools import wait_asyncio_next_cycle
 from octobot_commons.tests.test_config import load_test_config
 from octobot_trading.personal_data.orders import Order
-import octobot_trading.errors as errors
 from octobot_trading.enums import TraderOrderType, TradeOrderSide, TradeOrderType, OrderStatus, \
     ExchangeConstantsPositionColumns, PositionMode, MarginType, TakeProfitStopLossMode, ExchangeSupportedElements
 from octobot_trading.exchanges.exchange_manager import ExchangeManager
 from octobot_trading.personal_data.orders.order_factory import create_order_instance, create_order_instance_from_raw
 from octobot_trading.personal_data.orders import BuyLimitOrder, BuyMarketOrder, SellLimitOrder, StopLossOrder
 from octobot_trading.personal_data.orders.types.market.sell_market_order import SellMarketOrder
 import octobot_trading.personal_data.portfolios.assets as portfolio_assets
@@ -563,17 +561,16 @@
 
         # Fill only 1st one
         limit_buy.filled_price = 4
         limit_buy.status = OrderStatus.FILLED
         with patch.object(ccxt.async_support.binanceus, "calculate_fee",
                           Mock(return_value=get_fees_mock("SOL"))) as calculate_fee_mock:
             await limit_buy.on_fill(force_fill=True)
-            # called twice: once for filled order fee calculation, once for forecasted fees calculation used to restore
-            # available amounts if relevant
-            assert calculate_fee_mock.call_count == 2
+            # ensure call ccxt calculate_fee for order fees
+            calculate_fee_mock.assert_called_once()
 
         # added filled orders as filled trades
         assert len(trades_manager.trades) == 1
         assert all(trade.status is OrderStatus.FILLED for trade in trades_manager.trades.values())
 
         assert limit_buy not in orders_manager.get_open_orders()
         assert second_limit_buy in orders_manager.get_open_orders()
@@ -608,17 +605,15 @@
         limit_buy.status = OrderStatus.FILLED
 
         assert not trades_manager.trades
 
         with patch.object(ccxt.async_support.binanceus, "calculate_fee", Mock(return_value=get_fees_mock("SOL"))) \
                 as calculate_fee_mock:
             await limit_buy.on_fill(force_fill=True)
-            # called twice: once for filled order fee calculation, once for forecasted fees calculation used to restore
-            # available amounts if relevant
-            assert calculate_fee_mock.call_count == 2
+            calculate_fee_mock.assert_called_once()
 
         assert limit_buy not in orders_manager.get_open_orders()
 
         # added filled orders as filled trades
         assert len(trades_manager.trades) == 1
         assert all(trade.status is OrderStatus.FILLED for trade in trades_manager.trades.values())
 
@@ -1081,43 +1076,12 @@
             ExchangeConstantsPositionColumns.SYMBOL.value: DEFAULT_FUTURE_SYMBOL
         }
     )
     exchange_manager_inst.exchange_personal_data.positions_manager.upsert_position_instance(position_inst)
     assert trader_inst._has_open_position(DEFAULT_FUTURE_SYMBOL)
 
 
-async def test_create_order(future_trader_simulator_with_default_linear):
-    _, exchange_manager_inst, trader_inst, default_contract = future_trader_simulator_with_default_linear
-    order_mock = mock.Mock()
-    with mock.patch.object(trader_inst, "_create_new_order", mock.AsyncMock()) as _create_new_order_mock:
-        assert await trader_inst.create_order(order_mock)
-        _create_new_order_mock.assert_called_once_with(
-            order_mock, {}, wait_for_creation=True, creation_timeout=constants.INDIVIDUAL_ORDER_SYNC_TIMEOUT
-        )
-    for err in (errors.MissingFunds, errors.AuthenticationError, errors.ExchangeCompliancyError):
-        with mock.patch.object(
-                trader_inst, "_create_new_order", mock.AsyncMock(side_effect=err)
-        ) as _create_new_order_mock:
-            with pytest.raises(err):
-                assert await trader_inst.create_order(
-                    order_mock, params="params", wait_for_creation=False, creation_timeout=1
-                )
-            _create_new_order_mock.assert_called_once_with(
-                order_mock, "params", wait_for_creation=False, creation_timeout=1
-            )
-        with mock.patch.object(
-            trader_inst, "_create_new_order", mock.AsyncMock(side_effect=ZeroDivisionError)
-        ) as _create_new_order_mock:
-            # does not raise
-            assert await trader_inst.create_order(
-                order_mock, params="params", wait_for_creation=False, creation_timeout=1
-            ) is None
-            _create_new_order_mock.assert_called_once_with(
-                order_mock, "params", wait_for_creation=False, creation_timeout=1
-            )
-
-
 def make_coroutine(response):
     async def coroutine(*args, **kwargs):
         return response
 
     return coroutine
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/types/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/types/test_websocket_exchange.py` & `OctoBot-Trading-2.4.9/tests/exchanges/types/test_websocket_exchange.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/util/__init__.py` & `OctoBot-Trading-2.4.9/tests/exchanges/util/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/util/test_exchange_market_status_fixer.py` & `OctoBot-Trading-2.4.9/tests/exchanges/util/test_exchange_market_status_fixer.py`

 * *Files 1% similar despite different names*

```diff
@@ -42,14 +42,15 @@
             },
         }
 
     @staticmethod
     def _get_precision(precision_amount=None, precision_cost=None, precision_price=None):
         return {
             Ecmsc.PRECISION_AMOUNT.value: precision_amount,
+            Ecmsc.PRECISION_COST.value: precision_cost,
             Ecmsc.PRECISION_PRICE.value: precision_price,
         }
 
     # Global
     def test_exchange_market_status_fixer_without_precision_cost_and_amount_with_price(self):
         current_price = 4564.1458
```

### Comparing `OctoBot-Trading-2.4.85/tests/exchanges/util/test_exchange_util.py` & `OctoBot-Trading-2.4.9/tests/exchanges/util/test_exchange_util.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,17 +15,15 @@
 #  License along with this library.
 import pytest
 import mock
 
 import trading_backend.exchanges
 import octobot_commons.constants as commons_constants
 import octobot_commons.configuration as commons_configuration
-import octobot_trading.constants as constants
 import octobot_trading.exchanges as exchanges
-import octobot_trading.exchanges.util.exchange_util as exchange_util
 
 from tests import event_loop
 from tests.exchanges import MockedRestExchange, MockedAutoFillRestExchange
 import octobot_tentacles_manager.api as api
 
 
 @pytest.fixture
@@ -78,25 +76,25 @@
         assert compatible is False
         assert auth is True
         assert "plop" in error and len(error) > len("plop")
         is_valid_account_mock.assert_called_once()
 
 
 def test_get_partners_explanation_message():
-    assert ".cloud/en/guides" in exchanges.get_partners_explanation_message()
+    assert ".info" in exchanges.get_partners_explanation_message()
 
 
 def test_log_time_sync_error():
     logger = mock.Mock()
     exchanges.log_time_sync_error(logger, "exchange_name", "error", "hello call")
     args = logger.error.call_args[0][0]
     assert "exchange_name".capitalize() in args
     assert "error" in args
     assert "hello call" in args
-    assert ".cloud/en/guides" in args
+    assert ".info" in args
 
 
 @pytest.mark.asyncio
 async def test_is_compatible_account_with_unchecked_exchange(exchange_config, tentacles_setup_config):
     compatible, auth, error = await exchanges.is_compatible_account("hitbtc", exchange_config, tentacles_setup_config,
                                                                     False)
     assert compatible is False
@@ -238,16 +236,7 @@
                 )
             get_tentacle_config_mock.assert_not_called()
             details = await exchanges.get_exchange_details(
                 "blip", True, tentacles_setup_config, None
             )
             assert details == supported_exchanges["blip"]
             get_tentacle_config_mock.assert_called_once()
-
-
-def test_is_error_on_this_type():
-    errors = [("api", "key", "doesn't exist"),]
-
-    assert exchange_util.is_error_on_this_type(Exception("plop"), errors) is False
-    assert exchange_util.is_error_on_this_type(Exception("api key doesn't exist"), errors) is True
-    assert exchange_util.is_error_on_this_type(Exception("api"), errors) is False
-    assert exchange_util.is_error_on_this_type(Exception("api"), errors) is False
```

### Comparing `OctoBot-Trading-2.4.85/tests/modes/__init__.py` & `OctoBot-Trading-2.4.9/tests/modes/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/modes/script_keywords/__init__.py` & `OctoBot-Trading-2.4.9/tests/modes/script_keywords/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,14 +35,15 @@
         None,
         None,
         None,
         None,
         None,
         None,
         None,
+        None,
     )
     yield context
 
 
 @pytest_asyncio.fixture
 async def mock_context(backtesting_trader):
     _, exchange_manager, trader_inst = backtesting_trader
@@ -58,17 +59,17 @@
         mock.Mock(),
         mock.Mock(),
         mock.Mock(),
         mock.Mock(),
         mock.Mock(),
         mock.Mock(),
         mock.Mock(),
+        mock.Mock(),
     )
     context.signal_builder = mock.Mock()
-    context.is_trading_signal_emitter = mock.Mock(return_value=False)
     context.orders_writer = mock.Mock(log_many=mock.AsyncMock())
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
     # init portfolio with 0.5 BTC, 20 ETH and 30000 USDT and only 0.1 available BTC
     portfolio_manager.portfolio.update_portfolio_from_balance({
         'BTC': {'available': decimal.Decimal("0.1"), 'total': decimal.Decimal("0.5")},
         'ETH': {'available': decimal.Decimal("20"), 'total': decimal.Decimal("20")},
         'USDT': {'available': decimal.Decimal("30000"), 'total': decimal.Decimal("30000")}
```

### Comparing `OctoBot-Trading-2.4.85/tests/modes/script_keywords/basic_keywords/test_account_balance.py` & `OctoBot-Trading-2.4.9/tests/modes/script_keywords/basic_keywords/test_account_balance.py`

 * *Files 6% similar despite different names*

```diff
@@ -43,86 +43,58 @@
         get_up_to_date_price.assert_called_once_with(mock_context.exchange_manager, symbol=mock_context.symbol,
                                                      timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT)
 
 
 async def test_available_account_balance(mock_context):
     current_symbol_holding = decimal.Decimal("100")
     market_quantity = decimal.Decimal("50")
-
-    async def _get_pre_order_data(
-        exchange_manager, symbol: str, timeout: int = None,
-        portfolio_type=commons_constants.PORTFOLIO_AVAILABLE,
-        target_price=None
-    ):
-        if portfolio_type == commons_constants.PORTFOLIO_AVAILABLE:
-            return current_symbol_holding, "current_market_holding", market_quantity, "current_price", "symbol_market"
-        return current_symbol_holding*2, "current_market_holding", market_quantity*2, "current_price", "symbol_market"
-
-    with mock.patch.object(trading_personal_data, "get_pre_order_data", mock.AsyncMock(side_effect=_get_pre_order_data)) \
+    ret_val = (current_symbol_holding, "current_market_holding", market_quantity, "current_price", "symbol_market")
+    with mock.patch.object(trading_personal_data, "get_pre_order_data", mock.AsyncMock(return_value=ret_val)) \
             as get_pre_order_data_mock, \
             mock.patch.object(account_balance, "_get_locked_amount_in_stop_orders",
                               mock.Mock(return_value=trading_constants.ONE)) as _get_locked_amount_in_stop_orders_mock:
         assert market_quantity == await script_keywords.available_account_balance(
             mock_context, side=trading_enums.TradeOrderSide.BUY.value, use_total_holding=False, is_stop_order=False,
             target_price=trading_constants.ZERO
         )
         get_pre_order_data_mock.assert_called_once_with(mock_context.exchange_manager, symbol=mock_context.symbol,
                                                         timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
                                                         portfolio_type=commons_constants.PORTFOLIO_AVAILABLE,
                                                         target_price=trading_constants.ZERO)
         get_pre_order_data_mock.reset_mock()
         _get_locked_amount_in_stop_orders_mock.assert_not_called()
-        assert current_symbol_holding * 2 == await script_keywords.available_account_balance(
+        assert current_symbol_holding == await script_keywords.available_account_balance(
             mock_context, side=trading_enums.TradeOrderSide.SELL.value, use_total_holding=True)
         get_pre_order_data_mock.assert_called_once_with(mock_context.exchange_manager, symbol=mock_context.symbol,
                                                         timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
                                                         portfolio_type=commons_constants.PORTFOLIO_TOTAL,
                                                         target_price=None)
         get_pre_order_data_mock.reset_mock()
         _get_locked_amount_in_stop_orders_mock.assert_not_called()
-        assert current_symbol_holding * 2 - trading_constants.ONE == await script_keywords.available_account_balance(
+        assert current_symbol_holding - trading_constants.ONE == await script_keywords.available_account_balance(
             mock_context, side=trading_enums.TradeOrderSide.SELL.value, use_total_holding=True, is_stop_order=True)
         get_pre_order_data_mock.assert_called_once_with(mock_context.exchange_manager, symbol=mock_context.symbol,
                                                         timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
                                                         portfolio_type=commons_constants.PORTFOLIO_TOTAL,
                                                         target_price=None)
         _get_locked_amount_in_stop_orders_mock.assert_called_once_with(mock_context,
                                                                        trading_enums.TradeOrderSide.SELL.value)
         get_pre_order_data_mock.reset_mock()
         _get_locked_amount_in_stop_orders_mock.reset_mock()
-        assert market_quantity * 2 - trading_constants.ONE == await script_keywords.available_account_balance(
+        assert market_quantity - trading_constants.ONE == await script_keywords.available_account_balance(
             mock_context, side=trading_enums.TradeOrderSide.BUY.value, use_total_holding=True, is_stop_order=True)
         get_pre_order_data_mock.assert_called_once_with(mock_context.exchange_manager, symbol=mock_context.symbol,
                                                         timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT,
                                                         portfolio_type=commons_constants.PORTFOLIO_TOTAL,
                                                         target_price=None)
         _get_locked_amount_in_stop_orders_mock.assert_called_once_with(mock_context,
                                                                        trading_enums.TradeOrderSide.BUY.value)
         get_pre_order_data_mock.reset_mock()
         _get_locked_amount_in_stop_orders_mock.reset_mock()
 
-        buy_1 = trading_personal_data.BuyLimitOrder(mock_context.trader)
-        buy_1.origin_quantity = decimal.Decimal("10")
-        buy_1.origin_price = decimal.Decimal("100")
-        buy_2 = trading_personal_data.BuyLimitOrder(mock_context.trader)
-        buy_2.origin_quantity = decimal.Decimal("3")
-        buy_2.origin_price = decimal.Decimal("40")
-        sell_1 = trading_personal_data.SellLimitOrder(mock_context.trader)
-        sell_1.origin_quantity = decimal.Decimal("2.21")
-        sell_1.origin_price = decimal.Decimal("200")
-        assert market_quantity + buy_1.origin_quantity + buy_2.origin_quantity == \
-           await script_keywords.available_account_balance(
-                mock_context, side=trading_enums.TradeOrderSide.BUY.value, use_total_holding=False, is_stop_order=False,
-                orders_to_be_ignored=[buy_1, buy_2, sell_1]
-            )
-        assert get_pre_order_data_mock.call_count == 2
-        _get_locked_amount_in_stop_orders_mock.assert_not_called()
-        get_pre_order_data_mock.reset_mock()
-        _get_locked_amount_in_stop_orders_mock.reset_mock()
-
 
 async def test_adapt_amount_to_holdings(null_context):
     with mock.patch.object(account_balance, "available_account_balance",
                            mock.AsyncMock(return_value=decimal.Decimal(1))) as available_account_balance_mock:
         assert await script_keywords.adapt_amount_to_holdings(null_context,
                                                               decimal.Decimal(0),
                                                               trading_enums.TradeOrderSide.SELL,
@@ -130,29 +102,26 @@
                                                               "reduce_only",
                                                               "is_stop_order",
                                                               target_price=trading_constants.ONE_HUNDRED
                                                               ) == decimal.Decimal(0)
         available_account_balance_mock.assert_called_once_with(null_context, trading_enums.TradeOrderSide.SELL,
                                                                use_total_holding=False, is_stop_order="is_stop_order",
                                                                reduce_only="reduce_only",
-                                                               target_price=trading_constants.ONE_HUNDRED,
-                                                               orders_to_be_ignored=None)
+                                                               target_price=trading_constants.ONE_HUNDRED)
         available_account_balance_mock.reset_mock()
         assert await script_keywords.adapt_amount_to_holdings(null_context,
                                                               decimal.Decimal(1),
                                                               trading_enums.TradeOrderSide.SELL,
                                                               True,
                                                               "reduce_only",
-                                                              "is_stop_order",
-                                                              orders_to_be_ignored=["plop"]) == decimal.Decimal(1)
+                                                              "is_stop_order") == decimal.Decimal(1)
         available_account_balance_mock.assert_called_once_with(null_context, trading_enums.TradeOrderSide.SELL,
                                                                use_total_holding=True, is_stop_order="is_stop_order",
                                                                reduce_only="reduce_only",
-                                                               target_price=None,
-                                                               orders_to_be_ignored=["plop"])
+                                                               target_price=None)
         assert await script_keywords.adapt_amount_to_holdings(null_context,
                                                               decimal.Decimal(2),
                                                               trading_enums.TradeOrderSide.SELL,
                                                               False,
                                                               "reduce_only",
                                                               "is_stop_order") == decimal.Decimal(1)
```

### Comparing `OctoBot-Trading-2.4.85/tests/modes/script_keywords/dsl/__init__.py` & `OctoBot-Trading-2.4.9/tests/modes/script_keywords/dsl/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/modes/script_keywords/dsl/test_quantity.py` & `OctoBot-Trading-2.4.9/tests/modes/script_keywords/dsl/test_quantity.py`

 * *Files 10% similar despite different names*

```diff
@@ -20,25 +20,18 @@
 import octobot_trading.modes.script_keywords as script_keywords
 
 
 def test_parse_quantity_types():
     assert script_keywords.parse_quantity(None) == (script_keywords.QuantityType.DELTA, None)
     assert script_keywords.parse_quantity(10) == (script_keywords.QuantityType.DELTA, decimal.Decimal(10))
     assert script_keywords.parse_quantity(-10) == (script_keywords.QuantityType.DELTA, decimal.Decimal(-10))
-    assert script_keywords.parse_quantity(1.366666663347877) == \
-           (script_keywords.QuantityType.DELTA, decimal.Decimal("1.366666663347877"))
+    assert script_keywords.parse_quantity(1.366666663347877) == (
+        script_keywords.QuantityType.DELTA, decimal.Decimal("1.366666663347877"))
     assert script_keywords.parse_quantity("-10") == (script_keywords.QuantityType.DELTA, decimal.Decimal(-10))
 
-    assert script_keywords.parse_quantity("-10d") == (script_keywords.QuantityType.DELTA_EXPLICIT, decimal.Decimal(-10))
-    assert script_keywords.parse_quantity("d-10") == (script_keywords.QuantityType.DELTA_EXPLICIT, decimal.Decimal(-10))
-    assert script_keywords.parse_quantity("d+10") == (script_keywords.QuantityType.DELTA_EXPLICIT, decimal.Decimal(10))
-    assert script_keywords.parse_quantity("d10") == (script_keywords.QuantityType.DELTA_EXPLICIT, decimal.Decimal(10))
-
-    assert script_keywords.parse_quantity("-10b") == (script_keywords.QuantityType.DELTA_BASE, decimal.Decimal(-10))
-
     assert script_keywords.parse_quantity("q") == (script_keywords.QuantityType.DELTA_QUOTE, None)
     assert script_keywords.parse_quantity("123q") == (
         script_keywords.QuantityType.DELTA_QUOTE, decimal.Decimal("123"))
     assert script_keywords.parse_quantity("q-0.11") == (
         script_keywords.QuantityType.DELTA_QUOTE, decimal.Decimal("-0.11"))
 
     assert script_keywords.parse_quantity("%") == (script_keywords.QuantityType.PERCENT, None)
@@ -90,20 +83,18 @@
     assert script_keywords.parse_quantity("wyz-0.11") == (script_keywords.QuantityType.UNKNOWN, None)
     assert script_keywords.parse_quantity("wyz12") == (script_keywords.QuantityType.UNKNOWN, None)
     assert script_keywords.parse_quantity("wyz") == (script_keywords.QuantityType.UNKNOWN, None)
 
 
 def test_parse_quantity_edge_numbers():
     assert script_keywords.parse_quantity(0) == (script_keywords.QuantityType.DELTA, decimal.Decimal(0))
-    assert script_keywords.parse_quantity(0.000000001) == \
-           (script_keywords.QuantityType.DELTA, decimal.Decimal("0.000000001"))
+    assert script_keywords.parse_quantity(0.000000001) == (
+        script_keywords.QuantityType.DELTA, decimal.Decimal("0.000000001"))
     assert script_keywords.parse_quantity(100000000000000000000) \
            == (script_keywords.QuantityType.DELTA, decimal.Decimal("100000000000000000000"))
-    assert script_keywords.parse_quantity("100000000000000000000b") \
-           == (script_keywords.QuantityType.DELTA_BASE, decimal.Decimal("100000000000000000000"))
     assert script_keywords.parse_quantity("-1e-09e%") == (
         script_keywords.QuantityType.ENTRY_PERCENT, decimal.Decimal("-1e-09"))
     assert script_keywords.parse_quantity("1e09%e") == (
         script_keywords.QuantityType.ENTRY_PERCENT, decimal.Decimal("1e09"))
     assert script_keywords.parse_quantity("1e9e") == (script_keywords.QuantityType.ENTRY, decimal.Decimal("1e9"))
     with mock.patch.object(script_keywords.QuantityType, "parse",
                            mock.Mock(return_value=(script_keywords.QuantityType.ENTRY, "e"))):
```

### Comparing `OctoBot-Trading-2.4.85/tests/modes/test_abstract_mode_consumer.py` & `OctoBot-Trading-2.4.9/tests/modes/test_abstract_mode_consumer.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,25 +9,28 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import mock
+import decimal
 import pytest
 
 import octobot_commons.constants as commons_constants
 from octobot_backtesting.backtesting import Backtesting
+from octobot_commons.asyncio_tools import wait_asyncio_next_cycle
 from octobot_commons.tests.test_config import load_test_config
 from octobot_trading.modes.channel.abstract_mode_consumer import AbstractTradingModeConsumer
-from octobot_trading.enums import EvaluatorStates, TradingModeActivityType
-from octobot_trading.constants import TRADING_MODE_ACTIVITY_REASON
+from octobot_trading.enums import EvaluatorStates
+import octobot_trading.constants as constants
+import octobot_trading.errors as errors
 from octobot_trading.exchanges.exchange_manager import ExchangeManager
-from octobot_trading.modes import AbstractTradingMode, AbstractTradingModeProducer, TradingModeActivity
+from octobot_trading.modes import AbstractTradingMode
+import octobot_trading.personal_data.portfolios.assets as portfolio_assets
 from octobot_trading.exchanges.traders.trader_simulator import TraderSimulator
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
@@ -40,16 +43,15 @@
         0.000000000000000000005
     config[commons_constants.CONFIG_SIMULATOR][commons_constants.CONFIG_STARTING_PORTFOLIO]["USDT"] = 2000
     exchange_manager = ExchangeManager(config, "binanceus")
 
     # use backtesting not to spam exchanges apis
     exchange_manager.is_simulated = True
     exchange_manager.is_backtesting = True
-    exchange_manager.use_cached_markets = False
-    exchange_manager.backtesting = Backtesting(None, [exchange_manager.id], None, [], False)
+    exchange_manager.backtesting = Backtesting(None, [exchange_manager.id], None, [])
 
     await exchange_manager.initialize()
 
     trader = TraderSimulator(config, exchange_manager)
     await trader.initialize()
     
     mode = AbstractTradingMode(config, exchange_manager)
@@ -126,34 +128,52 @@
         await consumer.create_new_orders(symbol, -1, EvaluatorStates.NEUTRAL)
     with pytest.raises(NotImplementedError):
         await consumer.create_new_orders(symbol, -1, EvaluatorStates.VERY_SHORT, xyz=1)
     with pytest.raises(NotImplementedError):
         await consumer.create_new_orders(symbol, -1, EvaluatorStates.LONG, xyz=1, aaa="bbb")
 
 
+async def test_get_holdings_ratio():
+    exchange_manager, symbol, consumer = await _get_tools()
+    exchange_manager.client_symbols = [symbol]
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
+        value_converter.last_prices_by_trading_pair[symbol] = decimal.Decimal("1000")
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
+        portfolio_current_value = decimal.Decimal("11")
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio = {}
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio["BTC"] = \
+        portfolio_assets.SpotAsset(name="BTC", available=decimal.Decimal("10"), total=decimal.Decimal("10"))
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio["USDT"] = \
+        portfolio_assets.SpotAsset(name="USDT", available=decimal.Decimal("1000"), total=decimal.Decimal("1000"))
+
+    assert consumer.get_holdings_ratio("BTC") == decimal.Decimal('0.9090909090909090909090909091')
+    assert consumer.get_holdings_ratio("USDT") == decimal.Decimal('0.09090909090909090909090909091')
+
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio.portfolio.pop("USDT")
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
+        portfolio_current_value = decimal.Decimal("10")
+    assert consumer.get_holdings_ratio("BTC") == constants.ONE
+    # add ETH and try to get ratio without symbol price
+    exchange_manager.exchange_personal_data.portfolio_manager.portfolio.\
+        get_currency_portfolio("ETH").total = decimal.Decimal(10)
+    # force not backtesting mode
+    exchange_manager.is_backtesting = False
+    # force add symbol in exchange symbols
+    exchange_manager.client_symbols.append("ETH/BTC")
+    with pytest.raises(errors.MissingPriceDataError):
+        ratio = consumer.get_holdings_ratio("ETH")
+    # let channel register proceed
+    await wait_asyncio_next_cycle()
+    assert consumer.get_holdings_ratio("BTC") == constants.ONE
+    assert consumer.get_holdings_ratio("USDT") == constants.ZERO
+    assert consumer.get_holdings_ratio("XYZ") == constants.ZERO
+
+
 async def test_get_number_of_traded_assets():
     exchange_manager, symbol, consumer = await _get_tools()
     exchange_manager.exchange_personal_data.portfolio_manager.portfolio_value_holder.\
         origin_crypto_currencies_values = {
             symbol: 1,
             "xyz": 2,
             "aaa": 3
         }
     assert consumer.get_number_of_traded_assets() == 3
-
-
-async def test_update_producer_last_activity():
-    exchange_manager, symbol, consumer = await _get_tools()
-    mode = consumer.trading_mode
-    producer = AbstractTradingModeProducer(
-        mock.Mock(exchange_manager=exchange_manager), exchange_manager.config, mode, exchange_manager
-    )
-    mode.producers.append(producer)
-    assert producer.last_activity == TradingModeActivity()
-    consumer._update_producer_last_activity(TradingModeActivityType.NOTHING_TO_DO, "plop")
-    assert producer.last_activity == TradingModeActivity(
-        TradingModeActivityType.NOTHING_TO_DO, {TRADING_MODE_ACTIVITY_REASON: "plop"}
-    )
-    consumer._update_producer_last_activity(TradingModeActivityType.CREATED_ORDERS, "11")
-    assert producer.last_activity == TradingModeActivity(
-        TradingModeActivityType.CREATED_ORDERS, {TRADING_MODE_ACTIVITY_REASON: "11"}
-    )
```

### Comparing `OctoBot-Trading-2.4.85/tests/modes/test_abstract_trading_mode.py` & `OctoBot-Trading-2.4.9/tests/modes/test_abstract_trading_mode.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,39 +12,40 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 import pytest
 import mock
-import asyncio
 
 # prevent circular import
 import octobot_trading.api
 import octobot_trading.modes as modes
 import octobot_trading.signals as signals
 import octobot_trading.constants as constants
 import octobot_commons.constants as common_constants
 import octobot_commons.errors as common_errors
-import octobot_commons.asyncio_tools as asyncio_tools
 import octobot_commons.signals.signals_emitter as signals_emitter
-import octobot_trading.exchanges.util.exchange_util as exchange_util
 
 from tests import event_loop
 from tests.exchanges import simulated_exchange_manager, simulated_trader
 from tests.personal_data.orders import buy_limit_order
 
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 @pytest.fixture
 def trading_mode(simulated_trader):
-    return _get_trading_mode(simulated_trader)
+    config, exchange_manager_inst, trader_inst = simulated_trader
+    mode = modes.AbstractTradingMode(config, exchange_manager_inst)
+    exchange_manager_inst.trading_modes = [mode]
+    mode.trading_config = {}
+    return mode
 
 
 async def test_remote_signal_publisher(trading_mode):
     with mock.patch.object(trading_mode, "should_emit_trading_signal", mock.Mock(return_value=False)) \
          as should_emit_trading_signal_mock:
         async with trading_mode.remote_signal_publisher("BTC/USDT") as builder:
             should_emit_trading_signal_mock.assert_called_once()
@@ -242,62 +243,7 @@
                 edit_order_mock.assert_called_once_with(
                     buy_limit_order, edited_quantity=constants.ONE, edited_price=constants.ONE,
                     edited_stop_price=constants.ONE, edited_current_price=constants.ONE,
                     params=None)
                 should_emit_trading_signal_mock.reset_mock()
                 edit_order_mock.reset_mock()
         emit_signal_bundle_mock.assert_not_called()
-
-
-async def test_optimize_initial_portfolio_single_call(trading_mode):
-    mode_1 = trading_mode
-    mode_2 = _get_other_trading_mode(mode_1)
-    mode_1.producers = [_get_ready_producer(mode_1)]
-    mode_2.producers = [_get_ready_producer(mode_2)]
-
-    async def waiter(sellable_assets, target_asset, tickers):
-        for _ in range(1):
-            # let other task run
-            await asyncio_tools.wait_asyncio_next_cycle()
-        return ["order_1"]
-
-    with mock.patch.object(
-        modes.AbstractTradingMode, "single_exchange_process_optimize_initial_portfolio", mock.AsyncMock(side_effect=waiter)
-    ) as single_exchange_process_optimize_initial_portfolio_mock, mock.patch.object(
-        exchange_util, "get_common_traded_quote", mock.Mock(return_value="USDT")
-    ) as get_common_traded_quote_mock:
-        mode_1_orders, mode_2_orders = await asyncio.gather(
-            mode_1.optimize_initial_portfolio(["BTC"], {}),
-            mode_2.optimize_initial_portfolio(["BTC"], {}),
-        )
-        # mode_2 did not call get_common_traded_quote_mock nor single_exchange_process_optimize_initial_portfolio_mock
-        # as mode_1 was already in process
-        get_common_traded_quote_mock.assert_called_once()
-        single_exchange_process_optimize_initial_portfolio_mock.assert_called_once_with(["BTC"], "USDT", {})
-        assert mode_1_orders == ["order_1"]
-        assert mode_2_orders == []
-
-
-def _get_trading_mode(simulated_trader):
-    config, exchange_manager_inst, trader_inst = simulated_trader
-    mode = modes.AbstractTradingMode(config, exchange_manager_inst)
-    exchange_manager_inst.trading_modes.append(mode)
-    mode.trading_config = {}
-    return mode
-
-
-def _get_other_trading_mode(first_trading_mode):
-    return _get_trading_mode(
-        (first_trading_mode.exchange_manager.config, first_trading_mode.exchange_manager, first_trading_mode.exchange_manager.trader)
-    )
-
-
-def _get_ready_producer(trading_mode):
-    producer = modes.AbstractTradingModeProducer(
-        mock.Mock(),
-        trading_mode.config,
-        trading_mode,
-        trading_mode.exchange_manager
-    )
-    producer.force_is_ready_to_trade()
-    return producer
-
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -37,28 +37,17 @@
     config, trader_inst, exchange_manager = trader_simulator
     return config, trader_inst, exchange_manager, Order(trader_inst)
 
 
 def created_order(order_type, order_type_enum, *args, **kwargs):
     order = order_type(*args, **kwargs)
     order.order_type = order_type_enum
-    order.symbol = "BTC/USDT"
     return order
 
 
-
-@pytest.fixture()
-def backtesting_buy_and_sell_limit_orders(event_loop, backtesting_trader):
-    _, _, trader_instance = backtesting_trader
-    return (
-        created_order(BuyLimitOrder, TraderOrderType.BUY_LIMIT, trader_instance),
-        created_order(SellLimitOrder, TraderOrderType.SELL_LIMIT, trader_instance)
-    )
-
-
 @pytest.fixture()
 def buy_limit_order(event_loop, simulated_trader):
     _, _, trader_instance = simulated_trader
     return created_order(BuyLimitOrder, TraderOrderType.BUY_LIMIT, trader_instance)
 
 
 @pytest.fixture()
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_balanced_take_profit_and_stop_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_group_util.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_group_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/groups/test_one_cancels_the_other_order_group.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_cancel_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_cancel_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_close_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_close_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_fill_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_fill_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_open_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_open_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_order_state_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_order_state_factory.py`

 * *Files 11% similar despite different names*

```diff
@@ -26,45 +26,41 @@
 pytestmark = pytest.mark.asyncio
 
 
 async def test_create_order_state_pending_creation(buy_limit_order):
     buy_limit_order.status = OrderStatus.PENDING_CREATION
     with mock.patch.object(personal_data.PendingCreationOrderState, "_synchronize_with_exchange", mock.AsyncMock()) as \
         _synchronize_with_exchange_mock:
-        await create_order_state(buy_limit_order, enable_associated_orders_creation=False)
+        await create_order_state(buy_limit_order)
         _synchronize_with_exchange_mock.assert_called_once()
         assert isinstance(buy_limit_order.state, personal_data.PendingCreationOrderState)
         assert buy_limit_order.state.state is States.PENDING_CREATION
-        assert buy_limit_order.state.enable_associated_orders_creation is False
 
 
 async def test_create_order_state_pending_chained_creation(buy_limit_order):
     buy_limit_order.status = OrderStatus.PENDING_CREATION
     buy_limit_order.is_waiting_for_chained_trigger = True
     await create_order_state(buy_limit_order)
     assert isinstance(buy_limit_order.state, personal_data.PendingCreationChainedOrderState)
     assert buy_limit_order.state.state is States.PENDING_CREATION
-    assert buy_limit_order.state.enable_associated_orders_creation is True  # default value
 
 
 async def test_create_order_state_open(buy_limit_order):
     buy_limit_order.status = OrderStatus.OPEN
     await create_order_state(buy_limit_order)
     assert isinstance(buy_limit_order.state, personal_data.OpenOrderState)
     assert buy_limit_order.state.state is States.OPEN
-    assert buy_limit_order.state.enable_associated_orders_creation is True  # default value
 
 
 async def test_create_order_state_cancel(buy_limit_order):
     buy_limit_order.status = OrderStatus.CANCELED
-    await create_order_state(buy_limit_order, enable_associated_orders_creation=True)
+    await create_order_state(buy_limit_order)
     # can be CANCELED or instant CLOSED
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
     assert buy_limit_order.state.state in [OrderStates.FILLED, States.CLOSED]
-    assert buy_limit_order.state.enable_associated_orders_creation is True
 
 
 async def test_create_order_state_fill(buy_limit_order):
     buy_limit_order.status = OrderStatus.FILLED
     await create_order_state(buy_limit_order)
     # can be FILLED or instant CLOSED
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
@@ -86,32 +82,26 @@
     await create_order_state(buy_limit_order, ignore_states=[])
     assert isinstance(buy_limit_order.state, personal_data.OpenOrderState)
     assert buy_limit_order.state.state is States.OPEN
 
 
 async def test_create_order_state_fill_to_open_with_ignore(buy_limit_order):
     buy_limit_order.status = OrderStatus.FILLED
-    await create_order_state(buy_limit_order, enable_associated_orders_creation=True)
+    await create_order_state(buy_limit_order)
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
-    assert buy_limit_order.state.enable_associated_orders_creation is True
     buy_limit_order.status = OrderStatus.OPEN
-    previous_state = buy_limit_order.state
-    await create_order_state(buy_limit_order, ignore_states=[States.OPEN], enable_associated_orders_creation=False)
+    await create_order_state(buy_limit_order, ignore_states=[States.OPEN])
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
-    # state did not change
-    assert buy_limit_order.state is previous_state
     # can be FILLED or instant CLOSED
     assert buy_limit_order.state.state in [OrderStates.FILLED, States.CLOSED]
-    assert buy_limit_order.state.enable_associated_orders_creation is True  # still True
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
 
 
 async def test_create_order_state_cancel_to_open_with_ignore(buy_limit_order):
     buy_limit_order.status = OrderStatus.CANCELED
     await create_order_state(buy_limit_order)
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
     buy_limit_order.status = OrderStatus.OPEN
     await create_order_state(buy_limit_order, ignore_states=[States.OPEN])
     assert isinstance(buy_limit_order.state, personal_data.CloseOrderState)
     # can be CANCELED or instant CLOSED
     assert buy_limit_order.state.state in [OrderStates.CANCELED, States.CLOSED]
-    assert buy_limit_order.state.enable_associated_orders_creation is True
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_pending_creation_chained_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/states/test_pending_creation_order_state.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/states/test_pending_creation_order_state.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_decimal_order_adapter.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_decimal_order_adapter.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,22 +10,20 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import math
-import mock
 import pytest
 import decimal
 
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc
 import octobot_trading.personal_data as personal_data
 import octobot_trading.constants as constants
-import octobot_trading.enums as enums
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
 async def test_decimal_adapt_price():
@@ -516,98 +514,7 @@
            11111111111111578.000145000156
     assert personal_data.decimal_trunc_with_n_decimal_digits(decimal.Decimal('0.00000000000001'), 7) == \
            constants.ZERO
     assert personal_data.decimal_trunc_with_n_decimal_digits(decimal.Decimal('0.11111111111111'), 7) == \
            decimal.Decimal('0.1111111')
 
     assert math.isnan(personal_data.decimal_trunc_with_n_decimal_digits(decimal.Decimal(math.nan), 12))
-
-
-async def test_decimal_adapt_order_quantity_because_fees():
-    fees = {
-        enums.FeePropertyColumns.TYPE.value: enums.ExchangeConstantsMarketPropertyColumns.TAKER.value,
-        enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.RATE.value: 0.001,
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("0.000001"),
-        enums.FeePropertyColumns.IS_FROM_EXCHANGE.value: False,
-    }
-    def _get_trade_fee(symbol: str, order_type, quantity, price, taker_or_maker):
-        return fees
-
-    exchange_manager = mock.Mock(
-        is_future=False,
-        exchange=mock.Mock(
-            get_trade_fee=mock.Mock(side_effect=_get_trade_fee)
-        )
-    )
-    symbol = "BTC/USDT"
-
-    origin_quantity = decimal.Decimal("1")
-    price = decimal.Decimal("30000")
-    taker_or_maker = enums.ExchangeConstantsMarketPropertyColumns.TAKER
-    quote_available_funds = decimal.Decimal("40000")
-
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.SELL, quote_available_funds
-    )
-    # sell: no effect
-    assert adapted is origin_quantity
-
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # buy but fees in BTC, quantity unchanged
-    assert adapted is origin_quantity
-
-    fees[enums.FeePropertyColumns.CURRENCY.value] = "USDT"
-    fees[enums.FeePropertyColumns.COST.value] = 40
-
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # sell: no still effect
-    assert adapted is origin_quantity
-
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # buy and fees in USDT but enough in quote_available_funds, quantity kept
-    assert adapted is origin_quantity
-
-    quote_available_funds = origin_quantity * price
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # buy and fees in USDT and not enough in quote_available_funds, quantity updated
-    assert adapted == origin_quantity - 2 * fees[enums.FeePropertyColumns.COST.value] / price
-
-    quote_available_funds = decimal.Decimal(100)
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # buy and fees in USDT and not enough in quote_available_funds, quantity greatly reduced
-    assert adapted == decimal.Decimal(100) / price - 2 * (fees[enums.FeePropertyColumns.COST.value] / price)
-
-    quote_available_funds = decimal.Decimal(10)
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # buy and fees in USDT and not enough in quote_available_funds to pay fees, quantity set to 0
-    assert adapted == constants.ZERO
-
-    exchange_manager.is_future = True
-    quote_available_funds = decimal.Decimal(10)
-    adapted = personal_data.decimal_adapt_order_quantity_because_fees(
-        exchange_manager, symbol, enums.TraderOrderType.BUY_LIMIT, origin_quantity,
-        price, taker_or_maker, enums.TradeOrderSide.BUY, quote_available_funds
-    )
-    # futures trading: no effect
-    assert adapted is origin_quantity
-
-    exchange_manager.is_future = False
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_double_filled_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_double_filled_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order.py`

 * *Files 20% similar despite different names*

```diff
@@ -296,110 +296,33 @@
 
 
 async def test_trigger_chained_orders(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
 
     base_order = personal_data.Order(trader_inst)
     # does nothing
-    await base_order.on_filled(True)
+    await base_order.on_filled()
 
     # with chained orders
-    order_mock_1 = mock.Mock(
-        update_price_if_outdated=mock.AsyncMock(),
-        update_quantity_with_order_fees=mock.AsyncMock(return_value=True),
-        should_be_created=mock.Mock(return_value=True)
-    )
-    order_mock_2 = mock.Mock(
-        update_price_if_outdated=mock.AsyncMock(),
-        update_quantity_with_order_fees=mock.AsyncMock(return_value=True),
-        should_be_created=mock.Mock(return_value=False)
-    )
+    order_mock_1 = mock.Mock()
+    order_mock_1.should_be_created = mock.Mock(return_value=True)
+    order_mock_2 = mock.Mock()
+    order_mock_2.should_be_created = mock.Mock(return_value=False)
     with mock.patch.object(order_util, "create_as_chained_order", mock.AsyncMock()) as create_as_chained_order_mock:
 
         base_order.add_chained_order(order_mock_1)
         base_order.add_chained_order(order_mock_2)
 
-        # does not triggers chained orders
-        await base_order.on_filled(False)
-        order_mock_1.should_be_created.assert_not_called()
-        order_mock_2.should_be_created.assert_not_called()
-        order_mock_1.update_price_if_outdated.assert_not_called()
-        order_mock_2.update_price_if_outdated.assert_not_called()
-        order_mock_1.update_quantity_with_order_fees.assert_not_called()
-        order_mock_2.update_quantity_with_order_fees.assert_not_called()
-        create_as_chained_order_mock.assert_not_called()
-
         # triggers chained orders
-        await base_order.on_filled(True)
+        await base_order.on_filled()
         order_mock_1.should_be_created.assert_called_once()
         order_mock_2.should_be_created.assert_called_once()
-        order_mock_1.update_price_if_outdated.assert_called_once()
-        order_mock_2.update_price_if_outdated.assert_called_once()
-        order_mock_1.update_quantity_with_order_fees.assert_called_once()
-        order_mock_2.update_quantity_with_order_fees.assert_called_once()
         create_as_chained_order_mock.assert_called_once_with(order_mock_1)
 
 
-def test_update_quantity_with_order_fees(trader_simulator):
-    config, exchange_manager_inst, trader_inst = trader_simulator
-
-    base_order = personal_data.Order(trader_inst)
-    base_order.symbol = "BTC/USDT"
-
-    other_order = personal_data.Order(trader_inst)
-    other_order.symbol = base_order.symbol
-    other_order.origin_quantity = decimal.Decimal(1)
-
-    # case 1: quantity_currency is not the amount unit: nothing changes
-    base_order.fee = {
-        enums.FeePropertyColumns.CURRENCY.value: "USDT",
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("1")
-    }
-    other_order.quantity_currency = "BTC"
-    assert other_order.update_quantity_with_order_fees(base_order) is True
-    assert other_order.origin_quantity == decimal.Decimal(1)    # nothing changed
-
-    # case 2: quantity_currency is the amount unit: other_order quantity is reduced
-    base_order.fee = {
-        enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("0.1")
-    }
-    other_order.quantity_currency = "BTC"
-    assert other_order.update_quantity_with_order_fees(base_order) is True
-    assert other_order.origin_quantity == decimal.Decimal("0.9")    # 1 - 0.1
-    other_order.origin_quantity = decimal.Decimal(1)
-
-    # case 3: quantity_currency is the amount unit and is too large: return False
-    base_order.fee = {
-        enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("1")
-    }
-    other_order.quantity_currency = "BTC"
-    assert other_order.update_quantity_with_order_fees(base_order) is False
-    assert other_order.origin_quantity == decimal.Decimal(1)    # nothing changed
-    base_order.fee = {
-        enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("1.1")
-    }
-    other_order.quantity_currency = "BTC"
-    assert other_order.update_quantity_with_order_fees(base_order) is False
-    assert other_order.origin_quantity == decimal.Decimal(1)    # nothing changed
-
-    # case 4: quantity_currency is the amount unit: other_order quantity is reduced and adapted
-    base_order.fee = {
-        enums.FeePropertyColumns.CURRENCY.value: "BTC",
-        enums.FeePropertyColumns.COST.value: decimal.Decimal("0.111111111111111111111111")
-    }
-    other_order.quantity_currency = "BTC"
-    assert other_order.update_quantity_with_order_fees(base_order) is True
-    # 1 - 0.111111111111111111111111 with truncated digits
-    assert other_order.origin_quantity == decimal.Decimal("0.88888")
-    other_order.origin_quantity = decimal.Decimal(1)
-
-
 async def test_update_from_order(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
 
     base_order_1 = personal_data.Order(trader_inst)
     base_order_1.order_id = "1"
     base_order_1.exchange_order_id = "1a"
     base_order_1.status = enums.OrderStatus.OPEN
@@ -460,15 +383,14 @@
     assert order.tag is origin_tag
     assert order.trader_creation_kwargs is origin_trader_creation_kwargs
     assert order.exchange_creation_params is origin_exchange_creation_params
     assert order.order_id is origin_order_id
     assert order.exchange_order_id is origin_exchange_order_id
     assert order.has_been_bundled is origin_has_been_bundled
     assert order.associated_entry_ids is origin_associated_entry_ids
-    assert order.broker_applied is False
     assert order.update_with_triggering_order_fees is origin_update_with_triggering_order_fees
 
     # partial update
     order.update_from_storage_order_details({
         enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value: {"plop": 1}
     })
     assert order.tag is origin_tag
@@ -482,25 +404,23 @@
 
     # full update
     order.update_from_storage_order_details({
         constants.STORAGE_ORIGIN_VALUE: {
             enums.ExchangeConstantsOrderColumns.TAG.value: "t1",
             enums.ExchangeConstantsOrderColumns.ID.value: "11a",
             enums.ExchangeConstantsOrderColumns.EXCHANGE_ID.value: "eee1",
-            enums.ExchangeConstantsOrderColumns.BROKER_APPLIED.value: True,
         },
         enums.StoredOrdersAttr.TRADER_CREATION_KWARGS.value: {"plop2": 1},
         enums.StoredOrdersAttr.EXCHANGE_CREATION_PARAMS.value: {"ex": 2, "gg": "yesyes"},
         enums.StoredOrdersAttr.HAS_BEEN_BUNDLED.value: True,
         enums.StoredOrdersAttr.ENTRIES.value: ["ABC", "2"],
         enums.StoredOrdersAttr.UPDATE_WITH_TRIGGERING_ORDER_FEES.value: True,
     })
     assert order.tag == "t1" != origin_tag
     assert order.trader_creation_kwargs == {"plop2": 1} != origin_trader_creation_kwargs
     assert order.exchange_creation_params == {"ex": 2, "gg": "yesyes"} != origin_exchange_creation_params
     assert order.order_id == "11a" != origin_order_id
-    assert order.broker_applied is True
     assert order.exchange_order_id == "eee1" != origin_exchange_order_id
     assert order.has_been_bundled is True is not origin_has_been_bundled
     assert order.associated_entry_ids == ["ABC", "2"] != origin_associated_entry_ids
     assert order.has_been_bundled is True is not origin_has_been_bundled
     assert order.update_with_triggering_order_fees is True is not origin_update_with_triggering_order_fees
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_adapter.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_adapter.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_factory.py`

 * *Files 9% similar despite different names*

```diff
@@ -114,63 +114,39 @@
         assert limit_order.exchange_creation_params == {"plop": 1, "fake_param": True}
         # associated_entry_ids are not copied
         assert created_from_dict.associated_entry_ids is None
         assert limit_order.associated_entry_ids == ["1"]
         await self.stop(exchange_manager)
 
     async def test_create_order_from_order_storage_details_with_simple_order(self):
-        _, exchange_manager, trader_inst = await self.init_default()
-        try:
+        _, exchange_manager, trader_inst = await self.init_default()    
         
-            order = personal_data.BuyLimitOrder(trader_inst)
-            order.update(order_type=TraderOrderType.BUY_LIMIT,
-                         symbol="BTC/USDT",
-                         current_price=decimal.Decimal("70"),
-                         quantity=decimal.Decimal("10"),
-                         price=decimal.Decimal("70"))
-            order_storage_details = orders_storage._format_order(order, exchange_manager)
-            order_storage_details[StoredOrdersAttr.ENTRIES.value] = ["11111"]
-
-            pending_groups = {}
-            created_order = await personal_data.create_order_from_order_storage_details(
-                order_storage_details, exchange_manager, pending_groups
-            )
-            assert pending_groups == {}
-
-            assert created_order.exchange_manager is exchange_manager
-            assert created_order.origin_quantity == order.origin_quantity
-            assert created_order.timestamp == order.timestamp
-            assert created_order.creation_time == order.creation_time
-            assert created_order.origin_price == order.origin_price
-            assert created_order.__class__ is order.__class__
-            # associated_entry_ids are added from order_storage_details but not in original order
-            assert created_order.associated_entry_ids == ["11111"]
-            assert order.associated_entry_ids is None
-
-            # updated creation_time (as with chained orders): creation_time is used to restore order
-            assert created_order.creation_time != 123
-            order.creation_time = 123
-
-            order_storage_details = orders_storage._format_order(order, exchange_manager)
-            created_order = await personal_data.create_order_from_order_storage_details(
-                order_storage_details, exchange_manager, pending_groups
-            )
-            assert pending_groups == {}
-            assert created_order.exchange_manager is exchange_manager
-            assert created_order.origin_quantity == order.origin_quantity
-            assert created_order.timestamp == 123   # aligned with creation time
-            assert created_order.creation_time == 123   # aligned with creation time
-            assert created_order.origin_price == order.origin_price
-            assert created_order.__class__ is order.__class__
-            # associated_entry_ids are added from order_storage_details but not in original order
-            assert created_order.associated_entry_ids is None
-            assert order.associated_entry_ids is None
-
-        finally:
-            await self.stop(exchange_manager)
+        order = personal_data.BuyLimitOrder(trader_inst)
+        order.update(order_type=TraderOrderType.BUY_LIMIT,
+                     symbol="BTC/USDT",
+                     current_price=decimal.Decimal("70"),
+                     quantity=decimal.Decimal("10"),
+                     price=decimal.Decimal("70"))
+        order_storage_details = orders_storage._format_order(order, exchange_manager)
+        order_storage_details[StoredOrdersAttr.ENTRIES.value] = ["11111"]
+    
+        pending_groups = {}
+        created_order = await personal_data.create_order_from_order_storage_details(
+            order_storage_details, exchange_manager, pending_groups
+        )
+        assert pending_groups == {}
+    
+        assert created_order.exchange_manager is exchange_manager
+        assert created_order.origin_quantity == order.origin_quantity
+        assert created_order.origin_price == order.origin_price
+        assert created_order.__class__ is order.__class__
+        # associated_entry_ids are added from order_storage_details but not in original order
+        assert created_order.associated_entry_ids == ["11111"]
+        assert order.associated_entry_ids is None
+        await self.stop(exchange_manager)
     
     async def test_create_order_from_order_storage_details_with_groups(self):
         _, exchange_manager, trader_inst = await self.init_default()  
         
         order = personal_data.BuyLimitOrder(trader_inst)
         group = exchange_manager.exchange_personal_data.orders_manager.create_group(
             personal_data.OneCancelsTheOtherOrderGroup
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_order_util.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_order_util.py`

 * *Files 8% similar despite different names*

```diff
@@ -342,33 +342,24 @@
     base_order = personal_data.BuyLimitOrder(trader_inst)
     base_order.update(order_type=enums.TraderOrderType.BUY_LIMIT,
                       symbol="BTC/USDT",
                       current_price=decimal.Decimal("70"),
                       quantity=decimal.Decimal("10"),
                       price=decimal.Decimal("70"))
     base_order.is_waiting_for_chained_trigger = True
-    base_order.creation_time = 123
-    origin_time = base_order.creation_time
-    assert base_order.to_dict()[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] \
-           == origin_time
     # base_order.state is None since no state has been associated to it (not initiliazed)
     assert base_order.state is None
     assert base_order.is_initialized is False
 
     await personal_data.create_as_chained_order(base_order)
-    assert base_order.creation_time > origin_time   # creation_time got update using current time
     assert base_order.is_waiting_for_chained_trigger is False
     assert base_order.is_created() is True
     assert base_order.is_initialized is True
     assert isinstance(base_order.state, personal_data.OpenOrderState)
 
-    # use chained order creation time
-    assert base_order.to_dict()[enums.ExchangeConstantsOrderColumns.TIMESTAMP.value] \
-           == base_order.creation_time
-
 
 @pytest.mark.asyncio
 async def test_create_as_chained_order_bundled_order_no_open_order(trader_simulator):
     config, exchange_manager_inst, trader_inst = trader_simulator
 
     base_order = personal_data.BuyLimitOrder(trader_inst)
     base_order.update(order_type=enums.TraderOrderType.BUY_LIMIT,
@@ -531,71 +522,7 @@
         = decimal.Decimal("100")
     assert await personal_data.get_order_size_portfolio_percent(
         exchange_manager_inst, decimal.Decimal("0.1"), enums.TradeOrderSide.BUY, "BTC/UDST"
     ) == decimal.Decimal("100")
     assert await personal_data.get_order_size_portfolio_percent(
         exchange_manager_inst, decimal.Decimal("0.01"), enums.TradeOrderSide.BUY, "BTC/UDST"
     ) == decimal.Decimal("10")
-
-
-def test_get_split_orders_count_and_increment():
-    # example SOL/BTC values from 12/09/2023
-    symbol_market = {
-        enums.ExchangeConstantsMarketStatusColumns.LIMITS.value: {
-            enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT.value: {
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MIN.value: 0.01,
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_AMOUNT_MAX.value: 90000000.0,
-            },
-            enums.ExchangeConstantsMarketStatusColumns.LIMITS_COST.value: {
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_COST_MIN.value: 0.0001,
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_COST_MAX.value: 9000000.0
-            },
-            enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE.value: {
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MIN.value: 1e-07,
-                enums.ExchangeConstantsMarketStatusColumns.LIMITS_PRICE_MAX.value: 1000.0
-            },
-        },
-        enums.ExchangeConstantsMarketStatusColumns.PRECISION.value: {
-            enums.ExchangeConstantsMarketStatusColumns.PRECISION_PRICE.value: 7,
-            enums.ExchangeConstantsMarketStatusColumns.PRECISION_AMOUNT.value: 2
-        }
-    }
-    # all valid values
-    assert personal_data.get_split_orders_count_and_increment(
-        decimal.Decimal("0.0006858"),
-        decimal.Decimal("0.0006958"),
-        decimal.Decimal("1"),
-        4,
-        symbol_market,
-        True
-    ) == (4, decimal.Decimal('0.0000025'))
-
-    # too small amount for cost: adapt to 3 orders
-    assert personal_data.get_split_orders_count_and_increment(
-        decimal.Decimal("0.0006858"),
-        decimal.Decimal("0.0006958"),
-        decimal.Decimal("0.5"),
-        4,
-        symbol_market,
-        True
-    ) == (3, decimal.Decimal('0.000003333333333333333333333333333'))
-
-    # too small amount for cost: adapt to 0 orders
-    assert personal_data.get_split_orders_count_and_increment(
-        decimal.Decimal("0.0006858"),
-        decimal.Decimal("0.0006958"),
-        decimal.Decimal("0.1"),
-        4,
-        symbol_market,
-        True
-    ) == (0, decimal.Decimal('0'))
-
-    # too small amount for cost (because of the lowest price order amount that gets truncated because of
-    # exchange precision rules): adapt to 0 orders
-    assert personal_data.get_split_orders_count_and_increment(
-        decimal.Decimal("0.0006963"),
-        decimal.Decimal("0.0006958"),
-        decimal.Decimal("0.14985"),
-        4,
-        symbol_market,
-        False
-    ) == (0, decimal.Decimal('0'))
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_orders_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_orders_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/test_orders_storage_operations.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/test_orders_storage_operations.py`

 * *Files 0% similar despite different names*

```diff
@@ -40,28 +40,28 @@
     exchange_manager_inst.storage_manager.orders_storage = mocked_order_storage
     yield mocked_order_storage, exchange_manager_inst, trader_inst
 
 
 async def test_apply_order_storage_details_if_any(initialized_mocked_order_storage):
     mocked_order_storage, exchange_manager_inst, trader_inst = initialized_mocked_order_storage
     mocked_order_storage.get_startup_order_details = mock.AsyncMock(return_value={})
-    mocked_order_storage.should_store_data = mock.Mock(return_value=False)
+    mocked_order_storage.should_store_date = mock.Mock(return_value=False)
 
     order = personal_data.BuyLimitOrder(trader_inst)
     order.update(order_type=enums.TraderOrderType.BUY_LIMIT,
                  symbol="BTC/USDT",
                  current_price=decimal.Decimal("70"),
                  quantity=decimal.Decimal("10"),
                  price=decimal.Decimal("70"),
                  exchange_order_id="plop exchange_id")
     await personal_data.apply_order_storage_details_if_any(order, exchange_manager_inst, {})
     # disabled in trader simulator
     mocked_order_storage.get_startup_order_details.assert_not_awaited()
 
-    mocked_order_storage.should_store_data = mock.Mock(return_value=True)
+    mocked_order_storage.should_store_date = mock.Mock(return_value=True)
     await personal_data.apply_order_storage_details_if_any(order, exchange_manager_inst, {})
     mocked_order_storage.get_startup_order_details.assert_awaited_once_with("plop exchange_id")
 
     # ensure no crash with not well formatted order_details
     mocked_order_storage.get_startup_order_details = mock.AsyncMock(return_value={"hello": "hi there"})
     await personal_data.apply_order_storage_details_if_any(order, exchange_manager_inst, {})
     mocked_order_storage.get_startup_order_details.assert_awaited_once_with("plop exchange_id")
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_buy_limit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_buy_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_sell_limit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_sell_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_stop_loss_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_stop_loss_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_stop_loss_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_take_profit_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/limit/test_take_profit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/limit/test_take_profit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/test_buy_market_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/test_buy_market_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/market/test_sell_market_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/market/test_sell_market_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/test_unknown_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/test_unknown_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/test_trailing_stop_limit_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py` & `OctoBot-Trading-2.4.9/tests/personal_data/orders/types/trailing/test_trailing_stop_order.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_future_asset.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_future_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_margin_asset.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_margin_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/assets/test_spot_asset.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/assets/test_spot_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/test_historical_asset_value_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/history/test_historical_portfolio_value_manager.py`

 * *Files 1% similar despite different names*

```diff
@@ -49,28 +49,21 @@
 
 
 async def test_initialize(historical_portfolio_value_manager):
     # run_dbs_identifier is None: does nothing
     await historical_portfolio_value_manager.initialize()
     assert historical_portfolio_value_manager.historical_portfolio_value == sortedcontainers.SortedDict()
 
+    if os.getenv('CYTHON_IGNORE'):
+        return
     with mock.patch.object(historical_portfolio_value_manager, "_reload_historical_portfolio_value", mock.AsyncMock()) \
-         as _reload_historical_portfolio_value_mock:
+        as _reload_historical_portfolio_value_mock:
         historical_portfolio_value_manager.is_initialized = False
         await historical_portfolio_value_manager.initialize()
-        _reload_historical_portfolio_value_mock.assert_not_called()
-
-        try:
-            historical_portfolio_value_manager.portfolio_manager.exchange_manager.is_backtesting = False
-            historical_portfolio_value_manager.is_initialized = False
-            await historical_portfolio_value_manager.initialize()
-            _reload_historical_portfolio_value_mock.assert_called_once()
-        finally:
-            # restore value
-            historical_portfolio_value_manager.portfolio_manager.exchange_manager.is_backtesting = True
+        _reload_historical_portfolio_value_mock.assert_called_once()
 
 
 async def test_on_new_value(historical_portfolio_value_manager):
     timestamp = 1648462965  # Monday 28 March 2022 10:22:45 UTC
     exchange_time = timestamp + 10
     day_timestamp = 1648425600  # Monday 28 March 2022 00:00:00 UTC
     # force exchange current time
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_asset.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_asset.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,21 +13,19 @@
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import copy
 import os
 import decimal
 
-import mock
 import pytest
 import octobot_commons.constants as commons_constants
 
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
-import octobot_trading.enums as enums
 from octobot_trading.enums import TraderOrderType, TradeOrderSide
 from octobot_trading.personal_data.orders import BuyLimitOrder
 from octobot_trading.personal_data.orders import SellLimitOrder
 from octobot_trading.personal_data.orders import StopLossOrder
 from octobot_trading.personal_data.orders import BuyMarketOrder
 from octobot_trading.personal_data.orders.types.market.sell_market_order import SellMarketOrder
 import octobot_trading.personal_data.orders.groups as order_groups
@@ -255,70 +253,48 @@
     # Test buy order
     limit_buy = BuyLimitOrder(trader)
     limit_buy.update(order_type=TraderOrderType.BUY_LIMIT,
                      symbol="BTC/USDT",
                      current_price=decimal.Decimal(str(50)),
                      quantity=decimal.Decimal(str(2)),
                      price=decimal.Decimal(str(50)))
-    limit_buy_2 = BuyLimitOrder(trader)
-    limit_buy_2.update(order_type=TraderOrderType.BUY_LIMIT,
-                       symbol="BTC/USDT",
-                       current_price=decimal.Decimal(str(50)),
-                       quantity=decimal.Decimal(str(2)),
-                       price=decimal.Decimal(str(50)))
 
     # update portfolio with creations
     portfolio_manager.portfolio.update_portfolio_available(market_sell, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell, True)
     portfolio_manager.portfolio.update_portfolio_available(stop_loss, True)
-    # simulate fees in USDT (ex: Kucoin, OKX)
-    with mock.patch.object(limit_buy.exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-         as _get_fees_currency_mock:
-        # taker fees are locked
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
-    portfolio_manager.portfolio.update_portfolio_available(limit_buy_2, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
 
     assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('2.8')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('799.9')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('900')
 
     # when cancelling limit sell, market sell and stop orders
     portfolio_manager.portfolio.update_portfolio_available(stop_loss, False)
-    # simulate fees in USDT (ex: Kucoin, OKX)
-    with mock.patch.object(limit_buy.exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-         as _get_fees_currency_mock:
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell, False)
 
     assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('7')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('799.9')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('900')
 
     # when filling limit buy
-    # simulate fees in USDT (ex: Kucoin, OKX)
-    with mock.patch.object(limit_buy.exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-         as _get_fees_currency_mock:
-        await fill_limit_or_stop_order(limit_buy)
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('9')
-    # USDT available is now 899.95 as maker fees are applied
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('799.95')
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('12')
-    # USDT total is now 899.95 as maker fees are applied
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('899.95')
+    await fill_limit_or_stop_order(limit_buy)
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('8.999')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('900')
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('11.999')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('900')
 
     # when filling market sell
     await fill_market_order(market_sell)
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('9')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('1009.74')
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('9')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('1109.74')
-
-    # when filling limit buy 2 (fees paid in BTC)
-    await fill_market_order(limit_buy_2)
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('10.999')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('1009.74')
-    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('10.999')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('1009.74')
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal(
+        '8.999')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal(
+        '1109.79')
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal(
+        '8.999')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal(
+        '1109.79')
 
 
 async def test_update_portfolio_with_cancelled_orders(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
     # force fees => shouldn't do anything
@@ -349,52 +325,39 @@
                      symbol="BTC/USDT",
                      current_price=decimal.Decimal(str(80)),
                      quantity=decimal.Decimal(str(3.6)),
                      price=decimal.Decimal(str(80)))
 
     portfolio_manager.portfolio.update_portfolio_available(stop_loss, True)
     portfolio_manager.portfolio.update_portfolio_available(limit_sell, True)
-    assert round(portfolio_manager.portfolio.get_currency_portfolio("BTC").available,
-                 1) == decimal.Decimal('5.8')
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('1000')
 
     # Test buy order
     limit_buy = BuyLimitOrder(trader)
     limit_buy.update(order_type=TraderOrderType.BUY_LIMIT,
                      symbol="BTC/USDT",
                      current_price=decimal.Decimal(str(50)),
                      quantity=decimal.Decimal(str(4)),
                      price=decimal.Decimal(str(50)))
 
-    # simulate fees in USDT (ex: Kucoin, OKX)
-    with mock.patch.object(limit_buy.exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-         as _get_fees_currency_mock:
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
-    assert round(portfolio_manager.portfolio.get_currency_portfolio("BTC").available,
-                 1) == decimal.Decimal('5.8')
-    # also locked 0.2 USDT for fees (use taker fees to be sure to have enough funds if order is filled as taker)
-    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('799.8')
-
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
     portfolio_manager.portfolio.update_portfolio_available(market_sell, True)
 
     assert round(portfolio_manager.portfolio.get_currency_portfolio("BTC").available,
                  1) == decimal.Decimal('1.7')
     assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal(
-        '799.8')
+        '800')
     assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal(
         '10')
     assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal(
         '1000')
 
     # with no filled orders
     portfolio_manager.portfolio.update_portfolio_available(stop_loss, False)
     portfolio_manager.portfolio.update_portfolio_available(limit_sell, False)
-    with mock.patch.object(limit_buy.exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-         as _get_fees_currency_mock:
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy, False)
     portfolio_manager.portfolio.update_portfolio_available(market_sell, False)
 
     assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal(
         '10')
     assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal(
         '1000')
     assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal(
@@ -640,214 +603,187 @@
         '1120')
 
 
 async def test_update_portfolio_with_multiple_filled_orders(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
-    fees = {
-        enums.ExchangeConstantsMarketPropertyColumns.TAKER.value: 0.001,
-        enums.ExchangeConstantsMarketPropertyColumns.MAKER.value: 0.001,
-        enums.ExchangeConstantsMarketPropertyColumns.FEE.value: 0.001
-    }
+    # Test buy order
+    limit_sell = SellLimitOrder(trader)
+    limit_sell.update(order_type=TraderOrderType.SELL_LIMIT,
+                      symbol="BTC/USDT",
+                      current_price=decimal.Decimal(str(90)),
+                      quantity=decimal.Decimal(str(4)),
+                      price=decimal.Decimal(str(90)))
 
-    with mock.patch.object(exchange_manager.exchange.connector, "get_fees", return_value=fees) \
-         as get_fees_mock:
-        # Test buy order
-        limit_sell = SellLimitOrder(trader)
-        limit_sell.update(order_type=TraderOrderType.SELL_LIMIT,
-                          symbol="BTC/USDT",
-                          current_price=decimal.Decimal(str(90)),
-                          quantity=decimal.Decimal(str(4)),
-                          price=decimal.Decimal(str(90)))
-
-        # Test buy order
-        limit_buy = BuyLimitOrder(trader)
-        limit_buy.update(order_type=TraderOrderType.BUY_LIMIT,
-                         symbol="BTC/USDT",
-                         current_price=decimal.Decimal(str(60)),
-                         quantity=decimal.Decimal(str(2)),
-                         price=decimal.Decimal(str(60)))
-
-        # Test buy order
-        limit_buy_2 = BuyLimitOrder(trader)
-        limit_buy_2.update(order_type=TraderOrderType.BUY_LIMIT,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(50)),
-                           quantity=decimal.Decimal(str(4)),
-                           price=decimal.Decimal(str(50)))
-
-        # Test buy order
-        limit_buy_3 = BuyLimitOrder(trader)
-        limit_buy_3.update(order_type=TraderOrderType.BUY_LIMIT,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(46)),
-                           quantity=decimal.Decimal(str(2)),
-                           price=decimal.Decimal(str(46)))
-
-        # Test buy order
-        limit_buy_4 = BuyLimitOrder(trader)
-        limit_buy_4.update(order_type=TraderOrderType.BUY_LIMIT,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(41)),
-                           quantity=decimal.Decimal(str(1.78)),
-                           price=decimal.Decimal(str(41)))
-
-        # Test buy order
-        limit_buy_5 = BuyLimitOrder(trader)
-        limit_buy_5.update(order_type=TraderOrderType.BUY_LIMIT,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(0.2122427)),
-                           quantity=decimal.Decimal(str(3.72448)),
-                           price=decimal.Decimal(str(0.2122427)))
-
-        # Test buy order
-        limit_buy_6 = BuyLimitOrder(trader)
-        limit_buy_6.update(order_type=TraderOrderType.BUY_LIMIT,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(430)),
-                           quantity=decimal.Decimal(str(1.05)),
-                           price=decimal.Decimal(str(430)))
-
-        # Test sell order
-        limit_sell_2 = SellLimitOrder(trader)
-        limit_sell_2.update(order_type=TraderOrderType.SELL_LIMIT,
-                            symbol="BTC/USDT",
-                            current_price=decimal.Decimal(str(10)),
-                            quantity=decimal.Decimal(str(2)),
-                            price=decimal.Decimal(str(10)))
-
-        # Test stop loss order
-        stop_loss_2 = StopLossOrder(trader)
-        stop_loss_2.update(order_type=TraderOrderType.STOP_LOSS,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(10)),
-                           quantity=decimal.Decimal(str(2)),
-                           price=decimal.Decimal(str(10)))
-
-        # Test sell order
-        limit_sell_3 = SellLimitOrder(trader)
-        limit_sell_3.update(order_type=TraderOrderType.SELL_LIMIT,
-                            symbol="BTC/USDT",
-                            current_price=decimal.Decimal(str(20)),
-                            quantity=decimal.Decimal(str(1)),
-                            price=decimal.Decimal(str(20)))
-
-        # Test stop loss order
-        stop_loss_3 = StopLossOrder(trader)
-        stop_loss_3.update(order_type=TraderOrderType.STOP_LOSS,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(20)),
-                           quantity=decimal.Decimal(str(1)),
-                           price=decimal.Decimal(str(20)))
-
-        # Test sell order
-        limit_sell_4 = SellLimitOrder(trader)
-        limit_sell_4.update(order_type=TraderOrderType.SELL_LIMIT,
-                            symbol="BTC/USDT",
-                            current_price=decimal.Decimal(str(50)),
-                            quantity=decimal.Decimal(str(0.2)),
-                            price=decimal.Decimal(str(50)))
-
-        # Test stop loss order
-        stop_loss_4 = StopLossOrder(trader, side=TradeOrderSide.BUY)
-        stop_loss_4.update(order_type=TraderOrderType.STOP_LOSS,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(45)),
-                           quantity=decimal.Decimal(str(0.2)),
-                           price=decimal.Decimal(str(45)))
-
-        # Test sell order
-        limit_sell_5 = SellLimitOrder(trader)
-        limit_sell_5.update(order_type=TraderOrderType.SELL_LIMIT,
-                            symbol="BTC/USDT",
-                            current_price=decimal.Decimal(str(11)),
-                            quantity=decimal.Decimal(str(0.7)),
-                            price=decimal.Decimal(str(11)))
-
-        # Test stop loss order
-        stop_loss_5 = StopLossOrder(trader)
-        stop_loss_5.update(order_type=TraderOrderType.STOP_LOSS,
-                           symbol="BTC/USDT",
-                           current_price=decimal.Decimal(str(9)),
-                           quantity=decimal.Decimal(str(0.7)),
-                           price=decimal.Decimal(str(9)))
-
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_2, True)
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_3, True)
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_4, True)
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_5, True)
-        with mock.patch.object(exchange_manager.exchange.connector, "_get_fees_currency", return_value="BTC") \
-             as _get_fees_currency_mock:
-            portfolio_manager.portfolio.update_portfolio_available(limit_sell, True)
-            _get_fees_currency_mock.assert_called_once()
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_2, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_3, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_4, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_5, True)
-        with mock.patch.object(exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-             as _get_fees_currency_mock:
-            portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
-            _get_fees_currency_mock.assert_called_once()
-            _get_fees_currency_mock.reset_mock()
-            portfolio_manager.portfolio.update_portfolio_available(limit_buy_2, True)
-            _get_fees_currency_mock.assert_called_once()
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_3, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_4, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_5, True)
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_6, True)
-
-        assert round(portfolio_manager.portfolio.get_currency_portfolio("BTC").available,
-                     1) == decimal.Decimal('2.1')
-        assert round(portfolio_manager.portfolio.get_currency_portfolio("USDT").available,
-                     7) == decimal.Decimal('62.4095063')
-        assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('10')
-        assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('1000')
-
-        # cancels
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_3, False)
-        portfolio_manager.portfolio.update_portfolio_available(stop_loss_5, False)
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_2, False)
-        with mock.patch.object(exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-             as _get_fees_currency_mock:
-            portfolio_manager.portfolio.update_portfolio_available(limit_buy, False)
-            _get_fees_currency_mock.assert_called_once()
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_3, False)
-        portfolio_manager.portfolio.update_portfolio_available(limit_buy_5, False)
-        portfolio_manager.portfolio.update_portfolio_available(limit_sell_4, False)
-
-        assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('4.296')
-        assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('275.32')
-        assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('10')
-        assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('1000.0000000')
-
-        # filling
-        await fill_limit_or_stop_order(stop_loss_2)
-        with mock.patch.object(exchange_manager.exchange.connector, "_get_fees_currency", return_value="BTC") \
-             as _get_fees_currency_mock:
-            await fill_limit_or_stop_order(limit_sell)
-            # called twice: once for filled order fee calculation, once for forecasted fees calculation used to restore
-            # available amounts if relevant
-            assert _get_fees_currency_mock.call_count == 2
-        await fill_limit_or_stop_order(limit_sell_3)
-        with mock.patch.object(exchange_manager.exchange.connector, "_get_fees_currency", return_value="USDT") \
-             as _get_fees_currency_mock:
-            await fill_limit_or_stop_order(limit_buy_2)
-            # called twice: once for filled order fee calculation, once for forecasted fees calculation used to restore
-            # available amounts if relevant
-            assert _get_fees_currency_mock.call_count == 2
-        await fill_limit_or_stop_order(limit_sell_5)
-        await fill_limit_or_stop_order(stop_loss_4)
-        await fill_limit_or_stop_order(limit_buy_4)
-        await fill_limit_or_stop_order(limit_buy_6)
-
-        assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal('9.32317')
-        assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal('673.9633')
-        assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal('9.32317')
-        assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal('673.9633')
+    # Test buy order
+    limit_buy = BuyLimitOrder(trader)
+    limit_buy.update(order_type=TraderOrderType.BUY_LIMIT,
+                     symbol="BTC/USDT",
+                     current_price=decimal.Decimal(str(60)),
+                     quantity=decimal.Decimal(str(2)),
+                     price=decimal.Decimal(str(60)))
+
+    # Test buy order
+    limit_buy_2 = BuyLimitOrder(trader)
+    limit_buy_2.update(order_type=TraderOrderType.BUY_LIMIT,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(50)),
+                       quantity=decimal.Decimal(str(4)),
+                       price=decimal.Decimal(str(50)))
+
+    # Test buy order
+    limit_buy_3 = BuyLimitOrder(trader)
+    limit_buy_3.update(order_type=TraderOrderType.BUY_LIMIT,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(46)),
+                       quantity=decimal.Decimal(str(2)),
+                       price=decimal.Decimal(str(46)))
+
+    # Test buy order
+    limit_buy_4 = BuyLimitOrder(trader)
+    limit_buy_4.update(order_type=TraderOrderType.BUY_LIMIT,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(41)),
+                       quantity=decimal.Decimal(str(1.78)),
+                       price=decimal.Decimal(str(41)))
+
+    # Test buy order
+    limit_buy_5 = BuyLimitOrder(trader)
+    limit_buy_5.update(order_type=TraderOrderType.BUY_LIMIT,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(0.2122427)),
+                       quantity=decimal.Decimal(str(3.72448)),
+                       price=decimal.Decimal(str(0.2122427)))
+
+    # Test buy order
+    limit_buy_6 = BuyLimitOrder(trader)
+    limit_buy_6.update(order_type=TraderOrderType.BUY_LIMIT,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(430)),
+                       quantity=decimal.Decimal(str(1.05)),
+                       price=decimal.Decimal(str(430)))
+
+    # Test sell order
+    limit_sell_2 = SellLimitOrder(trader)
+    limit_sell_2.update(order_type=TraderOrderType.SELL_LIMIT,
+                        symbol="BTC/USDT",
+                        current_price=decimal.Decimal(str(10)),
+                        quantity=decimal.Decimal(str(2)),
+                        price=decimal.Decimal(str(10)))
+
+    # Test stop loss order
+    stop_loss_2 = StopLossOrder(trader)
+    stop_loss_2.update(order_type=TraderOrderType.STOP_LOSS,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(10)),
+                       quantity=decimal.Decimal(str(2)),
+                       price=decimal.Decimal(str(10)))
+
+    # Test sell order
+    limit_sell_3 = SellLimitOrder(trader)
+    limit_sell_3.update(order_type=TraderOrderType.SELL_LIMIT,
+                        symbol="BTC/USDT",
+                        current_price=decimal.Decimal(str(20)),
+                        quantity=decimal.Decimal(str(1)),
+                        price=decimal.Decimal(str(20)))
+
+    # Test stop loss order
+    stop_loss_3 = StopLossOrder(trader)
+    stop_loss_3.update(order_type=TraderOrderType.STOP_LOSS,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(20)),
+                       quantity=decimal.Decimal(str(1)),
+                       price=decimal.Decimal(str(20)))
+
+    # Test sell order
+    limit_sell_4 = SellLimitOrder(trader)
+    limit_sell_4.update(order_type=TraderOrderType.SELL_LIMIT,
+                        symbol="BTC/USDT",
+                        current_price=decimal.Decimal(str(50)),
+                        quantity=decimal.Decimal(str(0.2)),
+                        price=decimal.Decimal(str(50)))
+
+    # Test stop loss order
+    stop_loss_4 = StopLossOrder(trader, side=TradeOrderSide.BUY)
+    stop_loss_4.update(order_type=TraderOrderType.STOP_LOSS,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(45)),
+                       quantity=decimal.Decimal(str(0.2)),
+                       price=decimal.Decimal(str(45)))
+
+    # Test sell order
+    limit_sell_5 = SellLimitOrder(trader)
+    limit_sell_5.update(order_type=TraderOrderType.SELL_LIMIT,
+                        symbol="BTC/USDT",
+                        current_price=decimal.Decimal(str(11)),
+                        quantity=decimal.Decimal(str(0.7)),
+                        price=decimal.Decimal(str(11)))
+
+    # Test stop loss order
+    stop_loss_5 = StopLossOrder(trader)
+    stop_loss_5.update(order_type=TraderOrderType.STOP_LOSS,
+                       symbol="BTC/USDT",
+                       current_price=decimal.Decimal(str(9)),
+                       quantity=decimal.Decimal(str(0.7)),
+                       price=decimal.Decimal(str(9)))
+
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_2, True)
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_3, True)
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_4, True)
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_5, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_2, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_3, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_4, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_5, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_2, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_3, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_4, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_5, True)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_6, True)
+
+    assert round(portfolio_manager.portfolio.get_currency_portfolio("BTC").available,
+                 1) == decimal.Decimal('2.1')
+    assert round(portfolio_manager.portfolio.get_currency_portfolio("USDT").available,
+                 7) == decimal.Decimal('62.7295063')
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal(
+        '10')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").total == decimal.Decimal(
+        '1000')
+
+    # cancels
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_3, False)
+    portfolio_manager.portfolio.update_portfolio_available(stop_loss_5, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_2, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_3, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_buy_5, False)
+    portfolio_manager.portfolio.update_portfolio_available(limit_sell_4, False)
+
+    # filling
+    await fill_limit_or_stop_order(stop_loss_2)
+    await fill_limit_or_stop_order(limit_sell)
+    await fill_limit_or_stop_order(limit_sell_3)
+    await fill_limit_or_stop_order(limit_buy_2)
+    await fill_limit_or_stop_order(limit_sell_5)
+    await fill_limit_or_stop_order(stop_loss_4)
+    await fill_limit_or_stop_order(limit_buy_4)
+    await fill_limit_or_stop_order(limit_buy_5)
+    await fill_limit_or_stop_order(limit_buy_6)
+
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").available == decimal.Decimal(
+        '13.05448')
+    assert portfolio_manager.portfolio.get_currency_portfolio("USDT").available == decimal.Decimal(
+        '674.22')
+    assert portfolio_manager.portfolio.get_currency_portfolio("BTC").total == decimal.Decimal(
+        '13.05448')
+    assert round(portfolio_manager.portfolio.get_currency_portfolio("USDT").total,
+                 7) == decimal.Decimal('673.4295063')
 
 
 async def test_update_portfolio_with_multiple_symbols_orders(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
     # Test buy order
@@ -1006,15 +942,14 @@
 
 
 async def test_default_impl(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
     order = BuyMarketOrder(trader)
-    order.symbol = "BTC/USDT"
 
     # should not raise NotImplemented
     portfolio_manager.portfolio.update_portfolio_data_from_order(order)
     portfolio_manager.portfolio.update_portfolio_available_from_order(order)
     portfolio_manager.portfolio.log_portfolio_update_from_order(order)
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio_manager.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,22 +9,18 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import decimal
 import os
 
-import mock
 import pytest
 from mock import patch, Mock, AsyncMock
-import octobot_commons.constants as commons_constants
-import octobot_trading.personal_data as personal_data
 from octobot_trading.personal_data.orders import BuyMarketOrder, BuyLimitOrder
 
 from tests.exchanges import backtesting_trader, backtesting_config, backtesting_exchange_manager, fake_backtesting
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 from tests.personal_data import DEFAULT_MARKET_QUANTITY
@@ -59,46 +55,37 @@
 async def test_handle_balance_update_from_order(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
     trader.simulate = False
     order = BuyMarketOrder(trader)
 
+    if os.getenv('CYTHON_IGNORE'):
+        return
+
     with patch.object(portfolio_manager, '_refresh_real_trader_portfolio',
                       new=AsyncMock()) as _refresh_real_trader_portfolio_mock, \
         patch.object(portfolio_manager, '_refresh_simulated_trader_portfolio_from_order',
                      new=Mock()) as _refresh_simulated_trader_portfolio_from_order_mock:
         _refresh_real_trader_portfolio_mock.assert_not_called()
         await portfolio_manager.handle_balance_update_from_order(order, True)
         _refresh_real_trader_portfolio_mock.assert_called_once()
         _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
         _refresh_real_trader_portfolio_mock.reset_mock()
-        with portfolio_manager.disabled_portfolio_update_from_order():
-            await portfolio_manager.handle_balance_update_from_order(order, False)
-            _refresh_real_trader_portfolio_mock.assert_not_called()
-            _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
-            await portfolio_manager.handle_balance_update_from_order(order, True)
-            _refresh_real_trader_portfolio_mock.assert_not_called()
-            _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
         await portfolio_manager.handle_balance_update_from_order(order, False)
         _refresh_real_trader_portfolio_mock.assert_not_called()
         _refresh_simulated_trader_portfolio_from_order_mock.assert_called_once()
 
     trader.simulate = True
     with patch.object(portfolio_manager, '_refresh_simulated_trader_portfolio_from_order',
                       new=Mock()) as _refresh_simulated_trader_portfolio_from_order_mock:
         _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
         await portfolio_manager.handle_balance_update_from_order(order, True)
         _refresh_simulated_trader_portfolio_from_order_mock.assert_called_once()
         _refresh_simulated_trader_portfolio_from_order_mock.reset_mock()
-        with portfolio_manager.disabled_portfolio_update_from_order():
-            await portfolio_manager.handle_balance_update_from_order(order, True)
-            _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
-            await portfolio_manager.handle_balance_update_from_order(order, False)
-            _refresh_simulated_trader_portfolio_from_order_mock.assert_not_called()
         # ensure no side effect with require_exchange_update param
         await portfolio_manager.handle_balance_update_from_order(order, False)
         _refresh_simulated_trader_portfolio_from_order_mock.assert_called_once()
 
     trader.is_enabled = False
     trader.simulate = False
     assert not await portfolio_manager.handle_balance_update_from_order(order, True)
@@ -108,15 +95,14 @@
 async def test_refresh_simulated_trader_portfolio_from_order(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
 
     if os.getenv('CYTHON_IGNORE'):
         return
     order = BuyLimitOrder(trader)
-    order.symbol = "BTC/USDT"
     await order.initialize()
     with patch.object(portfolio_manager.portfolio, 'update_portfolio_available',
                       new=Mock()) as update_portfolio_available_mock:
         update_portfolio_available_mock.assert_not_called()
         portfolio_manager._refresh_simulated_trader_portfolio_from_order(order)
         update_portfolio_available_mock.assert_called_once()
 
@@ -130,37 +116,7 @@
     assert order.is_filled()
 
     with patch.object(portfolio_manager.portfolio, 'update_portfolio_from_filled_order',
                       new=Mock()) as update_portfolio_from_filled_order_mock:
         update_portfolio_from_filled_order_mock.assert_not_called()
         portfolio_manager._refresh_simulated_trader_portfolio_from_order(order)
         update_portfolio_from_filled_order_mock.assert_called_once()
-
-
-async def test_load_simulated_portfolio_from_history(backtesting_trader):
-    config, exchange_manager, trader = backtesting_trader
-    portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
-
-    portfolio_manager.historical_portfolio_value_manager = mock.Mock(
-        historical_ending_portfolio={
-            "BTC": {
-                commons_constants.PORTFOLIO_AVAILABLE: 1,
-                commons_constants.PORTFOLIO_TOTAL: 10.11,
-            },
-            "ETH": {
-                commons_constants.PORTFOLIO_AVAILABLE: -1,
-                commons_constants.PORTFOLIO_TOTAL: 10,
-            },
-            "USDT": {
-                commons_constants.PORTFOLIO_AVAILABLE: 34,
-                commons_constants.PORTFOLIO_TOTAL: 34,
-            }
-        },
-        stop=mock.AsyncMock()
-    )
-    portfolio_manager._load_simulated_portfolio_from_history()
-    # ensure only the total value is loaded in simulated portfolio
-    assert portfolio_manager.portfolio.portfolio == {
-        "BTC": personal_data.SpotAsset("BTC", decimal.Decimal("10.11"), decimal.Decimal("10.11")),
-        "ETH": personal_data.SpotAsset("ETH", decimal.Decimal("10"), decimal.Decimal("10")),
-        "USDT": personal_data.SpotAsset("USDT", decimal.Decimal("34"), decimal.Decimal("34"))
-    }
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_portfolio_profitability.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_portfolio_profitability.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/test_value_converter.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/test_value_converter.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,17 +14,14 @@
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import decimal
 import pytest
 
 import octobot_trading.constants as constants
 import octobot_trading.errors as errors
-import octobot_trading.personal_data as trading_personal_data
-
-import octobot_commons.constants as commons_constants
 
 from tests.exchanges import backtesting_trader, backtesting_config, backtesting_exchange_manager, fake_backtesting
 
 
 def test_try_convert_currency_value_using_multiple_pairs(backtesting_trader):
     config, exchange_manager, trader = backtesting_trader
     portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
@@ -150,35 +147,7 @@
     # now use bridges cache
     assert value_converter.try_convert_currency_value_using_multiple_pairs("ADA", "XRP", constants.ONE, []) == \
            decimal.Decimal(2) / decimal.Decimal(100) / decimal.Decimal("0.1") / decimal.Decimal("0.0000001")
     assert value_converter.convert_currency_value_from_saved_price_bridges(
         "ADA", "XRP", decimal.Decimal("0.0001")
     ) == decimal.Decimal("0.0001") * decimal.Decimal(2) / decimal.Decimal(100) / \
         decimal.Decimal("0.1") / decimal.Decimal("0.0000001")
-
-
-def test_get_usd_like_value(backtesting_trader):
-    config, exchange_manager, trader = backtesting_trader
-    portfolio_manager = exchange_manager.exchange_personal_data.portfolio_manager
-    value_converter = portfolio_manager.portfolio_value_holder.value_converter
-    # no last_prices_by_trading_pair
-    assert value_converter.get_usd_like_value(commons_constants.USD_LIKE_COINS[0], decimal.Decimal("11")) \
-           == decimal.Decimal("11")
-    assert value_converter.get_usd_like_value(commons_constants.USD_LIKE_COINS[-1], decimal.Decimal("11")) \
-           == decimal.Decimal("11")
-    with pytest.raises(errors.MissingPriceDataError):
-        value_converter.get_usd_like_value("BTC", decimal.Decimal("11"))
-
-    value_converter.update_last_price("BTC/USDC", decimal.Decimal("30000"))
-    assert value_converter.get_usd_like_value("BTC", decimal.Decimal("11")) \
-           == decimal.Decimal("11") * decimal.Decimal("30000")
-
-    with pytest.raises(errors.MissingPriceDataError):
-        value_converter.get_usd_like_value("ETH", decimal.Decimal("11"))
-
-
-def test_can_convert_symbol_to_usd_like():
-    assert trading_personal_data.ValueConverter.can_convert_symbol_to_usd_like("BTC/USDT") is True
-    assert trading_personal_data.ValueConverter.can_convert_symbol_to_usd_like(
-        f"{commons_constants.USD_LIKE_COINS[4]}/BTC"
-    ) is True
-    assert trading_personal_data.ValueConverter.can_convert_symbol_to_usd_like("BTC/ETH") is False
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_future_portfolio.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_future_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_margin_portfolio.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_margin_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/portfolios/types/test_spot_portfolio.py` & `OctoBot-Trading-2.4.9/tests/personal_data/portfolios/types/test_spot_portfolio.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/channel/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/channel/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/states/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/states/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/test_position.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/test_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/test_position_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/test_position_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/test_positions_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/test_positions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/types/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/types/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/types/test_inverse_position.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/types/test_inverse_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/positions/types/test_linear_position.py` & `OctoBot-Trading-2.4.9/tests/personal_data/positions/types/test_linear_position.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/trades/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/trades/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,15 +10,14 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import octobot_trading.personal_data as personal_data
-import octobot_trading.enums
 
 
 def create_trade(trader, exchange_order_id, is_closing_order, origin_order_id):
     trade = personal_data.Trade(trader)
     trade.exchange_order_id = exchange_order_id
     trade.is_closing_order = is_closing_order
     trade.origin_order_id = origin_order_id
@@ -29,10 +28,8 @@
     trade = personal_data.Trade(trader)
     trade.executed_time = executed_time
     trade.executed_quantity = executed_quantity
     trade.executed_price = executed_price
     trade.symbol = symbol
     trade.fee = fee
     trade.side = side
-    trade.trade_type = octobot_trading.enums.TraderOrderType.BUY_LIMIT
-    trade.exchange_trade_type = octobot_trading.enums.TradeOrderType.LIMIT
     return trade
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_factory.py`

 * *Files 9% similar despite different names*

```diff
@@ -23,15 +23,16 @@
 from octobot_commons.tests.test_config import load_test_config
 from octobot_trading.enums import TraderOrderType, OrderStatus, FeePropertyColumns
 from octobot_trading.constants import ZERO
 from octobot_trading.exchanges.exchange_manager import ExchangeManager
 from octobot_trading.personal_data.orders.order_factory import create_order_instance_from_raw
 from octobot_trading.exchanges.traders.trader_simulator import TraderSimulator
 
-from octobot_trading.personal_data.trades import create_trade_instance_from_raw, create_trade_from_order
+from octobot_trading.personal_data.trades import create_trade_instance_from_raw, create_trade_from_order, \
+    create_trade_instance
 
 # All test coroutines will be treated as marked.
 from octobot_trading.api.exchange import cancel_ccxt_throttle_task
 
 pytestmark = pytest.mark.asyncio
 
 
@@ -60,15 +61,14 @@
 
         raw_trade = json.loads(
             """
             {	
               "info": {},
               "id": "12345-67890:09876/54321",
               "exchange_id": "plop",
-              "exchange_trade_id": "plop-trade",
               "timestamp": 1502962946216,
               "datetime": "2017-08-17 12:42:48.000",
               "symbol": "ETH/BTC",
               "order": "12345-67890:09876/54321",
               "type": "limit",
               "side": "buy",
               "takerOrMaker": "taker",
@@ -84,15 +84,14 @@
             """)
 
         trade = create_trade_instance_from_raw(trader, raw_trade)
 
         assert trade.trade_id == '12345-67890:09876/54321'
         assert trade.origin_order_id == '12345-67890:09876/54321'
         assert trade.exchange_order_id == 'plop'
-        assert trade.exchange_trade_id == 'plop-trade'
         assert trade.trade_type == TraderOrderType.BUY_LIMIT
         assert trade.symbol == 'ETH/BTC'
         assert trade.total_cost == decimal.Decimal(str(0.10376526))
         assert trade.executed_quantity == decimal.Decimal(str(1.5))
         assert trade.origin_price == decimal.Decimal(str(0.06917684))
         assert trade.executed_price == decimal.Decimal(str(0.06917684))
         assert trade.executed_time == 1502962946216
@@ -142,15 +141,14 @@
         order = create_order_instance_from_raw(trader, raw_order)
         order.tag = "tag"
         trade = create_trade_from_order(order, close_status=OrderStatus.FILLED)
 
         assert trade.trade_id == '12345-67890:09876/54321'
         assert trade.origin_order_id == '12345-67890:09876/54321'
         assert trade.exchange_order_id == '12345-67890:09876/1111'
-        assert trade.exchange_trade_id is None
         assert trade.simulated is True
         assert trade.trade_type == TraderOrderType.SELL_LIMIT
         assert trade.symbol == 'BTC/USDT'
         assert trade.total_cost == decimal.Decimal(str(0.076094524))
         assert trade.executed_quantity == decimal.Decimal(str(1.1))
         assert trade.origin_quantity == decimal.Decimal(str(1.5))
         assert trade.origin_price == decimal.Decimal("7684")
@@ -159,17 +157,16 @@
         assert trade.is_closing_order is True
         assert trade.tag == 'tag'
 
         trade = create_trade_from_order(order)
         assert trade.status == OrderStatus.FILLED
 
         exec_time = time.time()
-        trade = create_trade_from_order(order, executed_time=exec_time, exchange_trade_id="plop-trade1")
+        trade = create_trade_from_order(order, executed_time=exec_time)
         assert trade.executed_time == exec_time
-        assert trade.exchange_trade_id == "plop-trade1"
 
         # market order
         raw_order = {
             'id': '362550114',
             'exchange_id': 'AaaaAA',
             'clientOrderId': 'x-T9698eeeeeeeeeeeeee792',
             'timestamp': 1637579281.377,
@@ -189,20 +186,19 @@
             'remaining': 0.0,
             'status': 'closed',
             'fee': {'cost': 0.03764836, 'currency': 'USDT'},
             'trades': [],
             'fees': []
         }
         order = create_order_instance_from_raw(trader, raw_order)
-        trade = create_trade_from_order(order, close_status=OrderStatus.FILLED, exchange_trade_id="trade_exchange")
+        trade = create_trade_from_order(order, close_status=OrderStatus.FILLED)
 
         assert trade.trade_id == '362550114'
         assert trade.origin_order_id == '362550114'
         assert trade.exchange_order_id == 'AaaaAA'
-        assert trade.exchange_trade_id == 'trade_exchange'
         assert trade.trade_type == TraderOrderType.SELL_MARKET
         assert trade.symbol == 'UNI/USDT'
         assert trade.total_cost == ZERO
         assert trade.executed_quantity == decimal.Decimal("44964.0")
         assert trade.origin_quantity == decimal.Decimal("44964.0")
         assert trade.origin_price == ZERO
         assert trade.executed_price == ZERO
@@ -243,20 +239,37 @@
 
         order = create_order_instance_from_raw(trader, raw_order)
         trade = create_trade_from_order(order, close_status=OrderStatus.OPEN)
 
         assert trade.trade_id is not None
         assert trade.origin_order_id == trade.trade_id
         assert trade.exchange_order_id == 'plopplip'
-        assert trade.exchange_trade_id is None
         assert trade.simulated is True
         assert trade.trade_type == TraderOrderType.SELL_LIMIT
         assert trade.symbol == 'BTC/USDT'
         assert trade.total_cost == decimal.Decimal(str(0.076094524))
         assert trade.executed_quantity == decimal.Decimal(str(1.1))
         assert trade.origin_quantity == decimal.Decimal(str(1.5))
         assert trade.origin_price == decimal.Decimal(str(7684))
         assert trade.executed_price == decimal.Decimal(str(7684))
         assert trade.status == OrderStatus.OPEN
         assert trade.is_closing_order is False
 
         await self.stop(exchange_manager)
+
+    async def test_create_trade_instance(self):
+        _, exchange_manager, trader = await self.init_default()
+
+        trade = create_trade_instance(trader,
+                                      order_type=TraderOrderType.SELL_MARKET,
+                                      symbol="ETH/USDT",
+                                      quantity_filled=decimal.Decimal(str(1.2)),
+                                      total_cost=decimal.Decimal(str(10)))
+
+        assert trade.trade_id is not None
+
+        assert trade.symbol == "ETH/USDT"
+        assert trade.trade_type == TraderOrderType.SELL_MARKET
+        assert round(trade.executed_quantity, 3) == decimal.Decimal(str(1.2))
+        assert trade.total_cost == decimal.Decimal(str(10))
+
+        await self.stop(exchange_manager)
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/trades/test_trade_pnl.py` & `OctoBot-Trading-2.4.9/tests/personal_data/trades/test_trade_pnl.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import mock
 import pytest
 import decimal
 
 from tests import event_loop
 from tests.exchanges import simulated_exchange_manager, simulated_trader
 from tests.personal_data.trades import create_executed_trade
 
@@ -40,30 +39,14 @@
     assert pnl.get_total_close_quantity() == constants.ZERO
     with pytest.raises(errors.IncompletePNLError):
         pnl.get_entry_price()
     with pytest.raises(errors.IncompletePNLError):
         pnl.get_close_price()
     assert pnl.get_paid_regular_fees_in_quote() == constants.ZERO
     assert pnl.get_paid_special_fees_by_currency() == {}
-    with mock.patch.object(pnl, "get_closed_entry_value", mock.Mock(return_value=constants.ZERO)), \
-         mock.patch.object(pnl, "get_close_ratio", mock.Mock(return_value=constants.ZERO)), \
-         mock.patch.object(pnl, "get_closed_close_value", mock.Mock(return_value=constants.ONE_HUNDRED)), \
-         mock.patch.object(pnl, "get_paid_regular_fees_in_quote", mock.Mock(return_value=constants.ONE)):
-        # X/0
-        assert pnl.get_profits() == (
-            constants.ONE_HUNDRED - constants.ONE,
-            constants.ZERO
-        )
-        with mock.patch.object(pnl, "get_closed_close_value", mock.Mock(return_value=constants.ZERO)), \
-             mock.patch.object(pnl, "get_paid_regular_fees_in_quote", mock.Mock(return_value=constants.ZERO)):
-            # 0/0
-            assert pnl.get_profits() == (
-                constants.ZERO,
-                constants.ZERO
-            )
 
 
 def test_with_invalid_values(simulated_trader):
     _, _, trader = simulated_trader
     pnl = personal_data.TradePnl([
         create_executed_trade(trader, enums.TradeOrderSide.BUY, 12, decimal.Decimal(0), decimal.Decimal(10), SYMBOL, _get_fees("BTC", 0.1)),
     ], [
```

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/transactions/__init__.py` & `OctoBot-Trading-2.4.9/tests/personal_data/transactions/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/transactions/test_transaction_factory.py` & `OctoBot-Trading-2.4.9/tests/personal_data/transactions/test_transaction_factory.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/personal_data/transactions/test_transactions_manager.py` & `OctoBot-Trading-2.4.9/tests/personal_data/transactions/test_transactions_manager.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/signals/__init__.py` & `OctoBot-Trading-2.4.9/tests/signals/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/signals/test_trading_signal_bundle_builder.py` & `OctoBot-Trading-2.4.9/tests/signals/test_trading_signal_bundle_builder.py`

 * *Files 1% similar despite different names*

```diff
@@ -45,42 +45,14 @@
          as _pack_referenced_orders_together_mock:
         trading_signal_bundle = trading_signal_bundle_builder.build()
         assert trading_signal_bundle.identifier == "identifier"
         assert trading_signal_bundle.signals == []
         _pack_referenced_orders_together_mock.assert_called_once()
 
 
-def test_sort(trading_signal_bundle_builder, buy_limit_order):
-    assert trading_signal_bundle_builder.signals == []
-    assert trading_signal_bundle_builder.sort_signals().signals == []
-    order_ids = [
-        f"order_id_{i}"
-        for i in range(5)
-    ]
-    buy_limit_order.order_id = order_ids[0]
-    trading_signal_bundle_builder.add_created_order(buy_limit_order, buy_limit_order.exchange_manager, target_amount="1%")
-    # add new order (orders are based on order_id)
-    buy_limit_order.order_id = order_ids[1]
-    trading_signal_bundle_builder.add_cancelled_order(buy_limit_order, buy_limit_order.exchange_manager)
-    buy_limit_order.order_id = order_ids[2]
-    trading_signal_bundle_builder.add_cancelled_order(buy_limit_order, buy_limit_order.exchange_manager)
-    buy_limit_order.order_id = order_ids[3]
-    trading_signal_bundle_builder.add_created_order(buy_limit_order, buy_limit_order.exchange_manager, target_amount="2%")
-    buy_limit_order.order_id = order_ids[4]
-    trading_signal_bundle_builder.add_created_order(buy_limit_order, buy_limit_order.exchange_manager, target_amount="3%")
-
-    origin_signals = copy.copy(trading_signal_bundle_builder.signals)
-    assert order_ids == [signal.content[enums.TradingSignalOrdersAttrs.ORDER_ID.value] for signal in origin_signals]
-    builder = trading_signal_bundle_builder.sort_signals()
-    assert builder is trading_signal_bundle_builder
-    sorted_signals = builder.signals
-    sorted_ids = [order_ids[1], order_ids[2], order_ids[0], order_ids[3], order_ids[4]]
-    assert sorted_ids == [signal.content[enums.TradingSignalOrdersAttrs.ORDER_ID.value] for signal in sorted_signals]
-
-
 def test_add_created_order(trading_signal_bundle_builder, buy_limit_order):
     with pytest.raises(errors.InvalidArgumentError):
         trading_signal_bundle_builder.add_created_order(buy_limit_order, buy_limit_order.exchange_manager)
     trading_signal_bundle_builder.add_created_order(buy_limit_order, buy_limit_order.exchange_manager, target_amount="1%")
     assert len(trading_signal_bundle_builder.signals) == 1
     assert trading_signal_bundle_builder.signals[0].content[enums.TradingSignalCommonsAttrs.ACTION.value] \
            is enums.TradingSignalOrdersActions.CREATE.value
```

### Comparing `OctoBot-Trading-2.4.85/tests/signals/test_util.py` & `OctoBot-Trading-2.4.9/tests/signals/test_util.py`

 * *Files 1% similar despite different names*

```diff
@@ -61,21 +61,20 @@
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: None,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.ORDER_ID.value: buy_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: None,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: None,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
         enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: None,
-        enums.TradingSignalOrdersAttrs.UPDATE_WITH_TRIGGERING_ORDER_FEES.value: False,
     }
 
     sell_limit_order.add_chained_order(buy_limit_order)
     sell_limit_order.symbol = "BTC/ETH"
     buy_limit_order.associate_to_entry("1")
-    await buy_limit_order.set_as_chained_order(sell_limit_order, True, {}, True)
+    await buy_limit_order.set_as_chained_order(sell_limit_order, True, {}, False)
     assert signals.create_order_signal_content(
         buy_limit_order,
         enums.TradingSignalOrdersActions.CREATE,
         "strat",
         exchange_manager,
         target_amount="1%",
         target_position="2",
@@ -104,25 +103,23 @@
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: None,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.ORDER_ID.value: buy_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: sell_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: sell_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
         enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: ["1"],
-        enums.TradingSignalOrdersAttrs.UPDATE_WITH_TRIGGERING_ORDER_FEES.value: True,
     }
 
     order_group = personal_data.OneCancelsTheOtherOrderGroup(
         "group_name",
         buy_limit_order.exchange_manager.exchange_personal_data.orders_manager
     )
     buy_limit_order.add_to_order_group(order_group)
     buy_limit_order.associate_to_entry("2")
     buy_limit_order.associate_to_entry("3")
-    buy_limit_order.update_with_triggering_order_fees = False
     final_order_desc = {
         enums.TradingSignalCommonsAttrs.ACTION.value: enums.TradingSignalOrdersActions.CREATE.value,
         enums.TradingSignalOrdersAttrs.SIDE.value: enums.TradeOrderSide.BUY.value,
         enums.TradingSignalOrdersAttrs.STRATEGY.value: "strat",
         enums.TradingSignalOrdersAttrs.SYMBOL.value: "BTC/ETH",
         enums.TradingSignalOrdersAttrs.EXCHANGE.value: "binanceus",
         enums.TradingSignalOrdersAttrs.EXCHANGE_TYPE.value: enums.ExchangeTypes.SPOT.value,
@@ -144,15 +141,14 @@
         enums.TradingSignalOrdersAttrs.GROUP_TYPE.value: personal_data.OneCancelsTheOtherOrderGroup.__name__,
         enums.TradingSignalOrdersAttrs.TAG.value: "hello",
         enums.TradingSignalOrdersAttrs.ORDER_ID.value: buy_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.BUNDLED_WITH.value: sell_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.CHAINED_TO.value: sell_limit_order.order_id,
         enums.TradingSignalOrdersAttrs.ADDITIONAL_ORDERS.value: [],
         enums.TradingSignalOrdersAttrs.ASSOCIATED_ORDER_IDS.value: ["1", "2", "3"],
-        enums.TradingSignalOrdersAttrs.UPDATE_WITH_TRIGGERING_ORDER_FEES.value: False
     }
     assert signals.create_order_signal_content(
         buy_limit_order,
         enums.TradingSignalOrdersActions.CREATE,
         "strat",
         exchange_manager,
         target_amount="1%",
```

### Comparing `OctoBot-Trading-2.4.85/tests/test_utils/order_util.py` & `OctoBot-Trading-2.4.9/tests/test_utils/order_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/test_utils/random_numbers.py` & `OctoBot-Trading-2.4.9/tests/test_utils/random_numbers.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/util/__init__.py` & `OctoBot-Trading-2.4.9/tests/util/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests/util/test_config_util.py` & `OctoBot-Trading-2.4.9/tests/util/test_config_util.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests_additional/__init__.py` & `OctoBot-Trading-2.4.9/tests_additional/__init__.py`

 * *Files identical despite different names*

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/__init__.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,24 +26,23 @@
 import octobot_trading.errors as errors
 
 
 LOADED_EXCHANGE_CREDS_ENV_VARIABLES = False
 
 
 @contextlib.asynccontextmanager
-async def get_exchange_manager(exchange_name, config=None, authenticated=False, market_filter=None):
+async def get_exchange_manager(exchange_name, config=None, authenticated=False):
     config = {**test_config.load_test_config(), **config} if config else test_config.load_test_config()
     if exchange_name not in config[commons_constants.CONFIG_EXCHANGES]:
         config[commons_constants.CONFIG_EXCHANGES][exchange_name] = {}
     if authenticated:
         config[commons_constants.CONFIG_EXCHANGES][exchange_name].update(_get_exchange_auth_details(
             exchange_name
         ))
     exchange_manager_instance = exchanges.ExchangeManager(config, exchange_name)
-    exchange_manager_instance.market_filter = market_filter
     if config[commons_constants.CONFIG_EXCHANGES][exchange_name]. \
        get(commons_constants.CONFIG_EXCHANGE_TYPE, enums.ExchangeTypes.SPOT.value) == enums.ExchangeTypes.FUTURE.value:
         exchange_manager_instance.is_future = True
     await exchange_manager_instance.initialize()
     try:
         yield exchange_manager_instance
     except errors.UnreachableExchange as err:
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/real_exchange_tester.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/real_exchange_tester.py`

 * *Files 20% similar despite different names*

```diff
@@ -11,43 +11,37 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import contextlib
 
-import ccxt.async_support
 from ccxt import Exchange
 
 import octobot_commons.constants as constants
 import octobot_commons.enums as commons_enums
 import octobot_trading.enums as trading_enums
-import octobot_trading.exchanges.connectors.ccxt.ccxt_client_util as ccxt_client_util
-import octobot_trading.exchanges.util as exchanges_util
 from octobot_trading.enums import ExchangeConstantsTickersColumns as Ectc, \
     ExchangeConstantsMarketStatusColumns as Ecmsc
 from tests_additional.real_exchanges import get_exchange_manager
 
 
 class RealExchangeTester:
     # enter exchange name as a class variable here
     EXCHANGE_NAME = None
     EXCHANGE_TYPE = trading_enums.ExchangeTypes.SPOT.value
     SYMBOL = None
     SYMBOL_2 = None
     SYMBOL_3 = None
-    INACTIVE_MARKETS = []
     # default is 1h, change if necessary
     TIME_FRAME = commons_enums.TimeFrames.ONE_HOUR
     ALLOWED_TIMEFRAMES_WITHOUT_CANDLE = 0
     CANDLE_SINCE = 1661990400000  # 1 September 2022 00:00:00
     CANDLE_SINCE_SEC = CANDLE_SINCE / 1000
     REQUIRES_AUTH = False  # set True when even normally public apis require authentication
-    MARKET_STATUS_TYPE = trading_enums.ExchangeTypes.SPOT.value
-    HISTORICAL_CANDLES_TO_FETCH_COUNT = 650
 
     # Public methods: to be implemented as tests
     # Use await self._[method_name] to get the test request result
     # ex: market_status = await self.get_market_status()
 
     # unauthenticated API
     async def test_time_frames(self):
@@ -99,97 +93,46 @@
     #
     # async def test_cancel_order(self):
     #     pass
     #
     # async def test_create_order(self):
     #     pass
 
-    def ensure_required_market_status_values(self, market_status):
-            assert market_status
-            assert market_status[Ecmsc.TYPE.value] == self.MARKET_STATUS_TYPE
-            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
-            assert market_status[Ecmsc.ACTIVE.value] \
-                   is False if market_status[Ecmsc.SYMBOL.value] in self.INACTIVE_MARKETS else True
-            assert market_status[Ecmsc.PRECISION.value]
-
-    async def test_get_historical_ohlcv(self):
-        # common implementation, should always work if candles history is supported
-        historical_ohlcv = await self.get_historical_ohlcv()
-        assert len(historical_ohlcv) > 500  # should be around 650
-        self.ensure_elements_order(historical_ohlcv, commons_enums.PriceIndexes.IND_PRICE_TIME.value)
-        self.ensure_unique_elements(historical_ohlcv, commons_enums.PriceIndexes.IND_PRICE_TIME.value)
-        start, end = self.get_historical_ohlcv_start_and_end_times()
-        max_candle_time = self.get_time_after_time_frames(start, len(historical_ohlcv))
-        assert max_candle_time <= end
-        assert max_candle_time <= self.get_time()
-        # on some exchanges, a lot of candles are missing, ensure more than 1 fetch succeeded
-        assert (
-            self.HISTORICAL_CANDLES_TO_FETCH_COUNT * 0.85
-            < len(historical_ohlcv)
-            <= self.HISTORICAL_CANDLES_TO_FETCH_COUNT
-        )
-        for candle in historical_ohlcv:
-            assert start <= candle[commons_enums.PriceIndexes.IND_PRICE_TIME.value] <= end
-
     def get_config(self):
         return {
             constants.CONFIG_EXCHANGES: {
                 self.EXCHANGE_NAME: {
                     constants.CONFIG_EXCHANGE_TYPE: self.EXCHANGE_TYPE
                 }
             }
         }
-
+    
     @contextlib.asynccontextmanager
-    async def get_exchange_manager(self, market_filter=None):
-        async with get_exchange_manager(
-            self.EXCHANGE_NAME, config=self.get_config(),
-            authenticated=self.REQUIRES_AUTH, market_filter=market_filter
-        ) as exchange_manager:
+    async def get_exchange_manager(self):
+        async with get_exchange_manager(self.EXCHANGE_NAME, config=self.get_config(),
+                                        authenticated=self.REQUIRES_AUTH) as exchange_manager:
             yield exchange_manager
 
     async def time_frames(self):
         async with self.get_exchange_manager() as exchange_manager:
             return exchange_manager.exchange.time_frames
 
     async def get_market_statuses(self):
         # return 2 different market status with different traded pairs to reduce possible
         # side effects using only one pair.
         async with self.get_exchange_manager() as exchange_manager:
-            self._ensure_market_status_cachability(exchange_manager)
             return exchange_manager.exchange.get_market_status(self.SYMBOL), \
                 exchange_manager.exchange.get_market_status(self.SYMBOL_2), \
                 exchange_manager.exchange.get_market_status(self.SYMBOL_3)
 
-    def _ensure_market_status_cachability(self, exchange_manager):
-        client_using_cached_markets = getattr(ccxt.async_support, self.EXCHANGE_NAME)()
-        ccxt_client_util.load_markets_from_cache(client_using_cached_markets)
-        assert exchange_manager.exchange.connector.client.markets == client_using_cached_markets.markets
-
     async def get_symbol_prices(self, limit=None, **kwargs):
         async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_symbol_prices(self.SYMBOL, self.TIME_FRAME,
                                                                      limit=limit, **kwargs)
 
-    async def get_historical_ohlcv(self, **kwargs) -> list:
-        async with self.get_exchange_manager() as exchange_manager:
-            start, end = self.get_historical_ohlcv_start_and_end_times()
-            start_ms, end_ms = start * 1000, end * 1000
-            ohlcvs = []
-            async for ohlcv in exchanges_util.get_historical_ohlcv(
-                exchange_manager, self.SYMBOL, self.TIME_FRAME, start_ms, end_ms, request_retry_timeout=2, **kwargs
-            ):
-                ohlcvs.extend(ohlcv)
-            return ohlcvs
-
-    def get_historical_ohlcv_start_and_end_times(self):
-        start = self.get_time() - (self.get_timeframe_seconds() * self.HISTORICAL_CANDLES_TO_FETCH_COUNT * 2)
-        end = self.get_time_after_time_frames(start, self.HISTORICAL_CANDLES_TO_FETCH_COUNT)
-        return start, end
-
     async def get_kline_price(self, **kwargs):
         async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_kline_price(self.SYMBOL, self.TIME_FRAME, **kwargs)
 
     async def get_order_book(self, **kwargs):
         async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_order_book(self.SYMBOL, **kwargs)
@@ -198,27 +141,18 @@
         async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_recent_trades(self.SYMBOL, limit=limit)
 
     async def get_price_ticker(self):
         async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_price_ticker(self.SYMBOL)
 
-    async def get_all_currencies_price_ticker(self, market_filter=None, **kwargs):
-        async with self.get_exchange_manager(market_filter=market_filter) as exchange_manager:
+    async def get_all_currencies_price_ticker(self, **kwargs):
+        async with self.get_exchange_manager() as exchange_manager:
             return await exchange_manager.exchange.get_all_currencies_price_ticker(**kwargs)
 
-    def get_market_filter(self):
-        def market_filter(market):
-            return (
-                market[trading_enums.ExchangeConstantsMarketStatusColumns.SYMBOL.value]
-                in (self.SYMBOL, self.SYMBOL_2)
-            )
-
-        return market_filter
-
     def get_allowed_time_delta(self):
         return (self.ALLOWED_TIMEFRAMES_WITHOUT_CANDLE + 1) * \
             commons_enums.TimeFramesMinutes[self.TIME_FRAME] * \
             constants.MINUTE_TO_SECONDS * 1.3
 
     @staticmethod
     def get_time():
@@ -230,25 +164,18 @@
 
     def get_timeframe_seconds(self):
         return commons_enums.TimeFramesMinutes[self.TIME_FRAME] * constants.MINUTE_TO_SECONDS
 
     def get_time_after_time_frames(self, start, time_frames_count):
         return start + self.get_timeframe_seconds() * time_frames_count
 
-    def get_timeframe_ms_delta(self, time_frames_count):
-        return self.get_ms_time() - (self.get_timeframe_seconds() * time_frames_count * constants.MSECONDS_TO_SECONDS)
-
     @staticmethod
     def ensure_elements_order(elements, sort_key, reverse=False):
         assert sorted(elements, key=lambda x: x[sort_key], reverse=reverse) == elements
 
-    @staticmethod
-    def ensure_unique_elements(elements, key):
-        assert len(elements) == len(set(element[key] for element in elements))
-
     def check_market_status_limits(self, market_status,
                                    normal_price_max=10000, normal_price_min=1e-06,
                                    normal_cost_max=10000, normal_cost_min=1e-06,
                                    low_price_max=1e-07, low_price_min=1e-09,
                                    low_cost_max=1e-03, low_cost_min=1e-06,
                                    expect_invalid_price_limit_values=False,
                                    expect_inferior_or_equal_price_and_cost=False,
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/real_futures_exchange_tester.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/real_futures_exchange_tester.py`

 * *Files 7% similar despite different names*

```diff
@@ -18,15 +18,14 @@
 
 from tests_additional.real_exchanges import get_exchange_manager
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 
 
 class RealFuturesExchangeTester(RealExchangeTester):
     EXCHANGE_TYPE = enums.ExchangeTypes.FUTURE.value
-    MARKET_STATUS_TYPE = "swap"
 
     async def test_get_funding_rate(self):
         pass
 
     async def get_funding_rate(self, **kwargs):
         async with self.get_exchange_manager() as exchange_manager:
             return (
@@ -39,38 +38,33 @@
 
     def _check_funding_rate(
         self,
         funding_rate,
         has_rate=True,
         has_last_time=True,
         has_next_rate=True,
-        has_next_time=True,
-        has_next_time_in_the_past=False
+        has_next_time=True
     ):
         """
         Used data are
         - funding rate (value)
         - last_updated (timestamp)
         - predicted_funding_rate (value)
         - next_update (timestamp)
         """
         assert funding_rate
         if has_rate:
-            assert funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value] \
-                   and not funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value].is_nan()
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value]
         else:
             assert funding_rate[enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value].is_nan()
         if has_last_time:
-            assert 0 < funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value] <= self.get_time()
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value] <= self.get_time()
         else:
             assert funding_rate[enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value] == constants.ZERO
         if has_next_rate:
-            assert funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value] \
-                   and not funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value].is_nan()
+            assert funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value]
         else:
             assert funding_rate[enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value].is_nan()
-        if has_next_time_in_the_past:
-            assert funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value] < self.get_time()
-        elif has_next_time:
+        if has_next_time:
             assert funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value] >= self.get_time()
         else:
             assert funding_rate[enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value] == constants.ZERO
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_ascendex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_ascendex.py`

 * *Files 5% similar despite different names*

```diff
@@ -48,15 +48,17 @@
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             # on AscendEx, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in AscendEx tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in AscendEx tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
@@ -93,19 +95,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        with pytest.raises(AssertionError):
-            # seems temporarily broken (exchange side)
-            await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_binance.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bybit.py`

 * *Files 8% similar despite different names*

```diff
@@ -23,58 +23,67 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBinanceRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "binanceus"  # use binanceus for tests as binance is blocked in the us
+class TestBybitRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bybit"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
-    INACTIVE_MARKETS = [SYMBOL_3]
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on Bybit, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Bybit tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Bybit tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
+            # min cost and price can be inferior or equal as we are in /USD futures
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 500
+        assert len(symbol_prices) == 200
+        # check candles order (oldest first)
+        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+        # check last candle is the current candle
+        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+
+        # can't fetch more than 200 candles
+        symbol_prices = await self.get_symbol_prices(limit=1500)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
@@ -96,17 +105,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -129,28 +135,14 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
-    async def test_get_all_currencies_price_ticker_with_market_filter(self):
-        tickers = await self.get_all_currencies_price_ticker(market_filter=self.get_market_filter())
-        assert len(tickers) > 2    # all tickers
-        assert self.SYMBOL in tickers
-        assert self.SYMBOL_2 in tickers
-        assert self.SYMBOL_3 not in tickers  # symbol not correctly parsed as not in available markets
-        tickers = await self.get_all_currencies_price_ticker(
-            symbols=[self.SYMBOL, self.SYMBOL_2],
-            market_filter=self.get_market_filter()
-        )
-        assert list(tickers) == [self.SYMBOL, self.SYMBOL_2]    # ticker for self.SYMBOL, self.SYMBOL_2
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -168,11 +160,11 @@
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value]
+            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker)
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_binance_futures.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bithumb.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,88 +9,76 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import contextlib
-import mock
 import pytest
 
+from ccxt.async_support import bithumb
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
-import octobot_trading.exchanges as exchanges
-import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
+from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBinanceFuturesRealExchangeTester(RealFuturesExchangeTester):
-    EXCHANGE_NAME = "binance"
-    SYMBOL = "BTC/USDT:USDT"
-    SYMBOL_2 = "BTC/USD:BTC"
-    SYMBOL_3 = "XRP/USD:XRP"
+class TestBithumbRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bithumb"
+    SYMBOL = "BTC/KRW"
+    SYMBOL_2 = "ETH/BTC"
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
-            TimeFrames.FIFTEEN_MINUTES.value,
+            # TimeFrames.FIFTEEN_MINUTES.value, 10m instead
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
-            TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.THREE_DAYS.value,
-            TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
             assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(
-                market_status,
-                expect_invalid_price_limit_values=False,
-                enable_price_and_cost_comparison=False,
-                low_price_max=0.5,
-                low_cost_max=1,
-            )
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 500
+        assert len(symbol_prices) >= 4000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+        # candle limit is not supported, replaced by (await self.get_symbol_prices())[-limit:] in bithumb tentacle
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=200)
+        symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
@@ -102,27 +90,30 @@
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        kline_price = await self.get_kline_price()
+        # kline_price = await self.get_kline_price()
+        client = bithumb()
+        await client.fetch_markets()
+        kline_price = [(await client.fetch_ohlcv(TestBithumbRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
+
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
+        await client.close()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
         assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
@@ -138,22 +129,14 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
-    async def test_get_funding_rate(self):
-        funding_rate, ticker_funding_rate = await self.get_funding_rate()
-        # patch LAST_FUNDING_TIME in tentacle
-        self._check_funding_rate(funding_rate, has_last_time=False)
-        # no funding info in ticker
-        self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
-                                 has_next_rate=False, has_next_time=False)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -174,8 +157,8 @@
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealFuturesExchangeTester.check_ticker_typing(ticker)
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bingx.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bybit_futures.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,134 +15,110 @@
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBingxRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bingx"
-    SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "SHIB/USDT"
-    CANDLE_SINCE = 1680215441000  # Friday, March 24, 2023 3:00:00 PM UTC (large differences not supported)
-    CANDLE_SINCE_SEC = CANDLE_SINCE / 1000
+class TestBybitRealExchangeTester(RealFuturesExchangeTester):
+    EXCHANGE_NAME = "bybit"
+    SYMBOL = "BTC/USDT:USDT"
+    SYMBOL_2 = "ETH/USD:ETH"
+    SYMBOL_3 = "XRP/USD:XRP"
 
-    async def _test_time_frames(self):
+    async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
-
-            assert market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value] > 1
-            if market_status[Ecmsc.SYMBOL.value] == self.SYMBOL_3:
-                assert market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value] == 0
-            else:
-                assert market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value] > 2
-
-
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on Bybit, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Bybit tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Bybit tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(
-                market_status,
-                has_price_limits=False,
-                low_cost_max=5 if market_status[Ecmsc.SYMBOL.value] == self.SYMBOL_3 else 1e-03,
-                expect_invalid_price_limit_values=False
-            )
+            # min cost and price can be inferior or equal as we are in /USD futures
+            self.check_market_status_limits(market_status,
+                                            low_price_min=0.0001,    # XRP/USD
+                                            low_price_max=0.1,    # XRP/USD
+                                            expect_invalid_price_limit_values=False,
+                                            expect_inferior_or_equal_price_and_cost=True)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 500
+        assert len(symbol_prices) == 200
+        # max is 200 on Bybit
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
+        # check candles order (oldest first)
+        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+        # check last candle is the current candle
+        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+
+        # fetching more than 200 candles is fetching candles from the past
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=1500)
-        # max candles is 1000
-        assert len(symbol_prices) == 1000
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        # try with since and no limit (used in get_historical_ohlcv)
-
-        for since_value in (
-            self.CANDLE_SINCE,
-            super().CANDLE_SINCE,
-        ):
-            candle_since_sec = since_value / 1000
-            for limit in (None, None):
-                symbol_prices = await self.get_symbol_prices(since=since_value, limit=limit)
-                if limit:
-                    assert len(symbol_prices) == limit
-                else:
-                    assert len(symbol_prices) > 5
-                # check candles order (oldest first)
-                self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-                # check that fetched candles are historical candles
-                max_candle_time = self.get_time_after_time_frames(candle_since_sec, len(symbol_prices))
-                assert max_candle_time <= self.get_time()
-                for candle in symbol_prices:
-                    if since_value == super().CANDLE_SINCE:
-                        assert candle_since_sec <= candle[PriceIndexes.IND_PRICE_TIME.value]
-                        # ensure that still can't fetch candle before self.CANDLE_SINCE
-                        # this fails if fetch works
-                        assert max_candle_time < candle[PriceIndexes.IND_PRICE_TIME.value]
-                        max_theoretical_bingx_candle_time = self.get_time_after_time_frames(
-                            self.CANDLE_SINCE_SEC, len(symbol_prices)
-                        )
-                        # ensure fetch data are just moved to the 1st available candles but are still making sense
-                        assert (
-                            self.CANDLE_SINCE_SEC
-                            <= candle[PriceIndexes.IND_PRICE_TIME.value]
-                            <= max_theoretical_bingx_candle_time
-                        )
-                    else:
-                        # when fetching after january 2023, it works
-                        assert candle_since_sec <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+        for limit in (50, None):
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
@@ -166,14 +142,22 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
+    async def test_get_funding_rate(self):
+        funding_rate, ticker_funding_rate = await self.get_funding_rate()
+        # patch FUNDING_RATE and LAST_FUNDING_TIME in tentacle
+        self._check_funding_rate(funding_rate, has_rate=False, has_last_time=False)
+        # missing PREDICTED_FUNDING_RATE, find order info in info (exchange tentacle)
+        self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
+                                 has_next_rate=False, has_next_time=False)
+
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -193,9 +177,9 @@
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker)
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealFuturesExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitfinex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_binance_futures.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,90 +9,110 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
-import asyncio
-import time
+import contextlib
+import mock
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
+import octobot_trading.exchanges as exchanges
+import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBitfinexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitfinex2"
-    SYMBOL = "BTC/USD"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
-    DEFAULT_CANDLE_LIMIT = 500
-    SLEEP_TIME = 10
+class TestBinanceFuturesRealExchangeTester(RealFuturesExchangeTester):
+    EXCHANGE_NAME = "binance"
+    SYMBOL = "BTC/USDT:USDT"
+    SYMBOL_2 = "BTC/USD:BTC"
+    SYMBOL_3 = "XRP/USD:XRP"
+
+    @contextlib.asynccontextmanager
+    async def get_exchange_manager(self):
+        # allows to fetch both linear and inverse markets
+        # (same as having bot ccxt binanceusdm and binancecoinm
+        # to add in tentacles
+        additional_config = {
+            ccxt_constants.CCXT_OPTIONS: {
+                'fetchMarkets': [
+                    'linear',
+                    'inverse',
+                ],
+            }
+        }
+        with mock.patch.object(
+            exchanges.RestExchange, "get_additional_connector_config", mock.Mock(return_value=additional_config)
+        ):
+            async with super().get_exchange_manager() as exchange_manager:
+                yield exchange_manager
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
+            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
+            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
+            TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
             assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
                    market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            normal_price_min=1e-08,
-                                            normal_cost_min=1e-13,  # weirdly low value
-                                            low_cost_min=1e-08,  # higher min cost on lower prices, makes no sense
-                                            # but is compatible
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False    # because of low cose value in
-                                            # normal prices but not in low ones
-                                            )
+            self.check_market_status_limits(
+                market_status,
+                expect_invalid_price_limit_values=False,
+                enable_price_and_cost_comparison=False,
+                low_price_max=0.5,
+                low_cost_max=1,
+            )
 
     async def test_get_symbol_prices(self):
         # without limit
-        # since is required not to fetch 2014 candle, to be fixed in tentacle
-        since = self.get_timeframe_ms_delta(self.DEFAULT_CANDLE_LIMIT)
-        symbol_prices = await self.get_symbol_prices(since=since, limit=self.DEFAULT_CANDLE_LIMIT)
-        assert self.DEFAULT_CANDLE_LIMIT == len(symbol_prices)
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        since = self.get_timeframe_ms_delta(200)
-        symbol_prices = await self.get_symbol_prices(since=since, limit=200)
-        assert 200 == len(symbol_prices)
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
@@ -103,47 +123,30 @@
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            # issue: some candles are missing (fetching 10k candles), allow for delta in max time
-            allowed_delta = len(symbol_prices) // 1000 * self.get_timeframe_seconds()
-            max_candle_time += allowed_delta
             for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
-                assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        # await asyncio.sleep(10) # prevent rate api limit
         kline_price = await self.get_kline_price()
-        kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
-        assert kline_start_time < 1364970800  # 3 April 2013 06:33:20
-
-        # to be fixed in tentacle: fetch kline from get_symbol_prices
-        since = self.get_timeframe_ms_delta(1)
-        kline_price = (await self.get_symbol_prices(since=since, limit=1))[-1:]
-
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        # bitfinex2 only supports 1, 25 and 100 size
-        # https://docs.bitfinex.com/reference#rest-public-book
-        order_book = await self.get_order_book(limit=25)
-        assert len(order_book[Ecobic.ASKS.value]) == 25
+        order_book = await self.get_order_book()
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 25
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -153,14 +156,22 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
+    async def test_get_funding_rate(self):
+        funding_rate, ticker_funding_rate = await self.get_funding_rate()
+        # patch NEXT_FUNDING_TIME in tentacle
+        self._check_funding_rate(funding_rate)
+        # no funding info in ticker
+        self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
+                                 has_next_rate=False, has_next_time=False)
+
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -171,19 +182,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
-            assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.BID_VOLUME.value] is None
+            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            # open is None on this exchange
-            RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealFuturesExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitget.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_huobi.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,80 +17,67 @@
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 import octobot_trading.errors as errors
-from tests_additional.real_exchanges import get_exchange_manager
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBitgetRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitget"
+class TestHuobiRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "huobi"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            # TimeFrames.THREE_MINUTES.value,
-            # TimeFrames.FIVE_MINUTES.value,
+            TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            # TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            # TimeFrames.SIX_HOURS.value,
-            # TimeFrames.HEIGHT_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            # TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
-            # TimeFrames.ONE_MONTH.value
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on Bitget, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1  # to be fixed in Bitget tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1  # to be fixed in Bitget tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
+            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            for val in (Ecmsc.LIMITS_PRICE_MIN.value, Ecmsc.LIMITS_PRICE_MAX.value):
-                assert market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value][val] is None
-            # wtf value, to fix in tentacle
-            for val in (Ecmsc.LIMITS_COST_MIN.value, Ecmsc.LIMITS_COST_MAX.value):
-                assert market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_COST.value][val] in (None, 0, 5)
-            # can't use normal checker
-            # self.check_market_status_limits(market_status, expect_invalid_price_limit_values=True)
+            # invalid values => remove price limit in tentacle
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 100
+        assert len(symbol_prices) == 150
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=50)
-        assert len(symbol_prices) == 50
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
@@ -106,17 +93,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await self.get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bithumb.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_hollaex.py`

 * *Files 7% similar despite different names*

```diff
@@ -11,72 +11,74 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-from ccxt.async_support import bithumb
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBithumbRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bithumb"
-    SYMBOL = "BTC/KRW"
+class TestHollaexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "hollaex"
+    SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL_3 = "XRP/USDT"
+    # use one day timeframe to avoid low liquidity issues when fetching candles
+    TIME_FRAME = TimeFrames.ONE_DAY
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
-            TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
-            TimeFrames.FIVE_MINUTES.value,
-            # TimeFrames.FIFTEEN_MINUTES.value, 10m instead
-            TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.SIX_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
-            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
-                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1.0     # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1.0     # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, has_price_limits=False)
+            self.check_market_status_limits(market_status,
+                                            normal_cost_min=1e-07,
+                                            low_price_min=0.01,  # XRP/USDT instead of /BTC
+                                            low_price_max=1,
+                                            low_cost_min=0.01,
+                                            low_cost_max=1,
+                                            expect_invalid_price_limit_values=False,
+                                            enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
-        # without limit
-        symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) >= 4000
+        # without limit is not supported replaced by a 500 default limit in hollaex tentacle
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # candle limit is not supported, replaced by (await self.get_symbol_prices())[-limit:] in bithumb tentacle
         # try with candles limit (used in candled updater)
-        symbol_prices = (await self.get_symbol_prices())[-200:]
+        symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
@@ -87,40 +89,32 @@
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
-            assert max_candle_time <= self.get_time()
-            with pytest.raises(AssertionError):  # not supported
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            # sometimes exchange time is not sync
+            assert max_candle_time <= self.get_time_after_time_frames(self.get_time(), 1)
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        # kline_price = await self.get_kline_price()
-        client = bithumb()
-        await client.fetch_markets()
-        kline_price = [(await client.fetch_ohlcv(TestBithumbRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
-
+        kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
-        await client.close()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
+        assert len(order_book[Ecobic.ASKS.value]) >= 10
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 5
+        assert len(order_book[Ecobic.BIDS.value]) >= 10
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitso.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitso.py`

 * *Files 3% similar despite different names*

```diff
@@ -45,15 +45,17 @@
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
@@ -96,17 +98,14 @@
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             # sometimes exchange time is not sync
             assert max_candle_time <= self.get_time_after_time_frames(self.get_time(), 1)
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bitstamp.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_upbit.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,67 +12,66 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
-import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBitstampRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bitstamp"
-    SYMBOL = "BTC/USD"
+class TestUpbitRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "upbit"
+    SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.SIX_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit is not supported replaced by a 500 default limit in bitstamp tentacle
-        symbol_prices = await self.get_symbol_prices(limit=500)
-        assert len(symbol_prices) == 500
+        # without limit
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
@@ -83,41 +82,39 @@
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
-                assert len(symbol_prices) == limit
+                assert limit - 2 <= len(symbol_prices) <= limit  # no idea why but it happens
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) >= 1000
+        assert len(order_book[Ecobic.ASKS.value]) == 15
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) >= 1000
+        assert len(order_book[Ecobic.BIDS.value]) == 15
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -145,18 +142,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
+            assert ticker[Ectc.BID.value] is None
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value]
+            assert ticker[Ectc.ASK.value] is None
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
+            assert ticker[Ectc.PREVIOUS_CLOSE.value]
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bybit.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_phemex.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,122 +11,126 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-from octobot_commons.enums import TimeFrames, PriceIndexes
+from octobot_commons.enums import TimeFrames, PriceIndexes, TimeFramesMinutes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
+import octobot_trading.errors as errors
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBybitRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "bybit"
+class TestPhemexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "phemex"
     SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL_2 = "ETH/USDT"
+    SYMBOL_3 = "XRP/USDT"
+    ALLOWED_TIMEFRAMES_WITHOUT_CANDLE = 1   # low liquidity on spot trading
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.TWO_HOURS.value,
+            TimeFrames.THREE_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on Bybit, precision is a decimal instead of a number of digits
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on Phemex, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Bybit tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Phemex tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Bybit tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Phemex tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # min cost and price can be inferior or equal as we are in /USD futures
-            self.check_market_status_limits(market_status, has_price_limits=False)
+            self.check_market_status_limits(market_status,
+                                            low_price_min=1e-05,  # XRP/USDT instead of /BTC
+                                            low_price_max=1e-04,
+                                            low_cost_min=0.01,
+                                            low_cost_max=1,
+                                            expect_invalid_price_limit_values=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 200
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
-
-        # can't fetch more than 1000 candles
-        symbol_prices = await self.get_symbol_prices(limit=1500)
         assert len(symbol_prices) == 1000
+        symbol_prices = await self.get_symbol_prices(limit=100)
+        assert len(symbol_prices) == 100
+        symbol_prices = await self.get_symbol_prices(limit=500)
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
+        assert len(symbol_prices) == 200    # see possibleLimitValues
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        for limit in (50, None):
+        for limit in (100, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
+                with pytest.raises(AssertionError):  # not supported: candles are after the max time requested
+                    assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
+        assert len(order_book[Ecobic.ASKS.value]) == 30
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 5
+        assert len(order_book[Ecobic.BIDS.value]) == 30
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -155,17 +159,17 @@
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
+            assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            RealExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_bybit_futures.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kucoin_futures.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,181 +10,153 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
-import decimal
 
-from octobot_commons.enums import TimeFrames, PriceIndexes
 import octobot_commons.constants as commons_constants
-import octobot_trading.enums as enums
-import octobot_trading.constants as constants
-import octobot_trading.exchanges.connectors.ccxt.enums as ccxt_enums
-import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
+from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
+import octobot_trading.errors as errors
 from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestBybitRealExchangeTester(RealFuturesExchangeTester):
-    EXCHANGE_NAME = "bybit"
+class TestKucoinFuturesRealExchangeTester(RealFuturesExchangeTester):
+    EXCHANGE_NAME = "kucoinfutures"
     SYMBOL = "BTC/USDT:USDT"
-    SYMBOL_2 = "ETH/USD:ETH"
+    SYMBOL_2 = "BTC/USD:BTC"
     SYMBOL_3 = "XRP/USD:XRP"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
+            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
+            TimeFrames.ONE_WEEK.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on Bybit, precision is a decimal instead of a number of digits
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Bybit tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Bybit tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # min cost and price can be inferior or equal as we are in /USD futures
+            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
             self.check_market_status_limits(market_status,
-                                            low_price_min=0.0001,    # XRP/USD
-                                            low_price_max=0.1,    # XRP/USD
-                                            expect_invalid_price_limit_values=False,
-                                            expect_inferior_or_equal_price_and_cost=True)
+                                            expect_invalid_price_limit_values=True,
+                                            enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 200
-        # max is 1000 on Bybit
-        symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
-
-        # fetching more than 200 candles is fetching candles from the past
-        symbol_prices = await self.get_symbol_prices(limit=1500)
-        assert len(symbol_prices) == 1000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
+        symbol_prices = await self.get_symbol_prices(limit=100)
+        assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
-            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit) == []
+            # "to" param is required: add in tentacle
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, to=self.get_ms_time())
             if limit:
                 assert len(symbol_prices) == limit
+                real_limit = \
+                    self.get_time_after_time_frames(self.CANDLE_SINCE, limit) * commons_constants.MSECONDS_TO_SECONDS
+                symbol_prices_real = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, to=real_limit)
+                assert symbol_prices_real == symbol_prices
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
+        # kucoin requires a limit of None, 20 or 100 in order book
+        order_book = await self.get_order_book(limit=20)
+        assert len(order_book[Ecobic.ASKS.value]) == 20
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 5
+        assert len(order_book[Ecobic.BIDS.value]) == 20
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
+        # note: on ccxt kucoin recent trades are received in reverse order from exchange and therefore should never be
+        # filtered by limit before reversing (or most recent trades are lost)
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        tickers = await self.get_all_currencies_price_ticker()
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
+        with pytest.raises(errors.NotSupported):
+            tickers = await self.get_all_currencies_price_ticker()
+            for symbol, ticker in tickers.items():
+                self._check_ticker(ticker, symbol)
 
     async def test_get_funding_rate(self):
         funding_rate, ticker_funding_rate = await self.get_funding_rate()
-        # patch LAST_FUNDING_TIME in tentacle
-        self._check_funding_rate(funding_rate, has_last_time=False)
-        # missing PREDICTED_FUNDING_RATE, find order info in info (exchange tentacle)
+        # patch NEXT_FUNDING_TIME in tentacle
+        self._check_funding_rate(funding_rate, has_next_time=False)
+        # no funding info in ticker
         self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
                                  has_next_rate=False, has_next_time=False)
-        ticker_funding = self._get_adapted_funding_from_ticker(ticker_funding_rate)
-        self._check_funding_rate(ticker_funding)
-
-    def _get_adapted_funding_from_ticker(self, ticker):
-        tentacle_funding_from_ticker = {}
-        funding_dict = ticker[ccxt_constants.CCXT_INFO]
-        funding_next_timestamp = (
-            float(funding_dict.get(ccxt_enums.ExchangeFundingCCXTColumns.NEXT_FUNDING_TIME.value, 0)) /
-            commons_constants.MSECONDS_TO_SECONDS
-        )
-        funding_rate = decimal.Decimal(
-            str(funding_dict.get(ccxt_enums.ExchangeFundingCCXTColumns.FUNDING_RATE.value, constants.NaN))
-        )
-        tentacle_funding_from_ticker.update({
-            enums.ExchangeConstantsFundingColumns.LAST_FUNDING_TIME.value:
-                max(funding_next_timestamp - 8 * commons_constants.HOURS_TO_SECONDS, 0),
-            enums.ExchangeConstantsFundingColumns.FUNDING_RATE.value: funding_rate,
-            enums.ExchangeConstantsFundingColumns.NEXT_FUNDING_TIME.value: funding_next_timestamp,
-            enums.ExchangeConstantsFundingColumns.PREDICTED_FUNDING_RATE.value: funding_rate
-        })
-        return tentacle_funding_from_ticker
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -194,20 +166,23 @@
             Ectc.ASK_VOLUME.value,
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
-            assert ticker[Ectc.HIGH.value]
-            assert ticker[Ectc.LOW.value]
+            assert ticker[Ectc.HIGH.value] is None
+            assert ticker[Ectc.LOW.value] is None
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value]
-            assert ticker[Ectc.OPEN.value]
+            assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            RealFuturesExchangeTester.check_ticker_typing(ticker, check_timestamp=False)
+            assert ticker[Ectc.BASE_VOLUME.value] is None
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealFuturesExchangeTester.check_ticker_typing(
+                ticker,
+                check_open=False, check_low=False, check_high=False, check_base_volume=False
+            )
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_coinbase.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_gateio.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,87 +11,74 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-import octobot_trading.errors
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestCoinbaseRealExchangeTester(RealExchangeTester):
-    # ALL require authentication ?
-    # https://github.com/ccxt/ccxt/issues/16719
-    EXCHANGE_NAME = "coinbase"
+class TestGateIORealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "gateio"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "ADA/BTC"
-    REQUIRES_AUTH = True    # set True when even normally public apis require authentication
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
+            TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.SIX_HOURS.value,
+            TimeFrames.FOUR_HOURS.value,
+            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.ONE_DAY.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in coinbase tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in coinbase tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, has_price_limits=False)
-
-    def _get_ohlcv_params(self, limit):
-        # to be added in tentacle
-        to_time = self.get_ms_time()
-        return {
-            "since": to_time - (self.get_timeframe_seconds() * limit * 1000),
-            "limit": limit,
-        }
+            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
+            self.check_market_status_limits(market_status, has_price_limits=False,)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 300
+        assert len(symbol_prices) == 1000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        # max value is 300, larger value fetch candles from the past
-        symbol_prices = await self.get_symbol_prices(**self._get_ohlcv_params(500))
-        assert len(symbol_prices) == 300
-        # ensure data from the past
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] < self.get_time() - self.get_allowed_time_delta()
-
-        # ensure data within limit value
-        symbol_prices = await self.get_symbol_prices(**self._get_ohlcv_params(300))
-        assert len(symbol_prices) == 300
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
@@ -105,17 +92,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -125,15 +109,15 @@
         assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50
+        assert len(recent_trades) > 20
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
@@ -154,23 +138,20 @@
             Ectc.ASK_VOLUME.value,
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
-            assert ticker[Ectc.HIGH.value] is None
-            assert ticker[Ectc.LOW.value] is None
+            assert ticker[Ectc.HIGH.value]
+            assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value] is None
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(
-                ticker,
-                check_open=False, check_high=False, check_low=False, check_base_volume=False
-            )
+            assert ticker[Ectc.BASE_VOLUME.value]
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_coinex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_mexc.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,111 +23,107 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestCoinexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "coinex"
+class TestMEXCRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "mexc"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.SIX_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
+            TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
+            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, has_price_limits=False)
+            self.check_market_status_limits(
+                market_status,
+                has_price_limits=False
+            )
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        # default 100 candles
-        assert len(symbol_prices) == 100
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=550)
-        assert len(symbol_prices) == 550
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-    async def test_get_historical_symbol_prices(self):
+    async def test_get_historical_symbol_prices(self):  #todo
         # try with since and limit (used in data collector)
         for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            with pytest.raises(AssertionError):  # not supported
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        assert await self.get_historical_ohlcv() == []
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
+                with pytest.raises(AssertionError):
+                    # candles are not respecting the since + limit param (candles are too early)
+                    assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
-
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        # fetchOrderBook() limit argument must be None, 5/10/20/50. Default is 20
-        order_book = await self.get_order_book(limit=10)
-        assert len(order_book[Ecobic.ASKS.value]) == 10
+        order_book = await self.get_order_book()
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 10
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50
+        assert len(recent_trades) >= 20
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
@@ -157,11 +153,11 @@
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
+            assert ticker[Ectc.PREVIOUS_CLOSE.value]
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_cryptocom.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_cryptocom.py`

 * *Files 4% similar despite different names*

```diff
@@ -47,15 +47,17 @@
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             # on CryptoCom, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in CryptoCom tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in CryptoCom tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
@@ -96,32 +98,28 @@
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             with pytest.raises(AssertionError):  # not supported
                 for candle in symbol_prices:
                     assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        assert await self.get_historical_ohlcv() == []
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
         assert len(order_book[Ecobic.ASKS.value]) == 5
-        assert len(order_book[Ecobic.ASKS.value][0]) == 3
+        assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
-        assert len(order_book[Ecobic.BIDS.value][0]) == 3
+        assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
@@ -152,14 +150,14 @@
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value] is None
+            assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False)
+            RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_gateio.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_ndax.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,97 +12,105 @@
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
+import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestGateIORealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "gateio"
+class TestNdaxRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "ndax"
     SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+    SYMBOL_2 = "ETH/CAD"
+    SYMBOL_3 = "XRP/CAD"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
-            TimeFrames.ONE_DAY.value
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
+            TimeFrames.ONE_DAY.value,
+            TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on this exchange, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
-            self.check_market_status_limits(market_status, has_price_limits=False,)
+            self.check_market_status_limits(market_status,
+                                            low_price_max=1e-03,
+                                            low_price_min=1e-05,
+                                            normal_cost_min=1e-07,
+                                            low_cost_max=1e-02,
+                                            low_cost_min=1e-04,
+                                            expect_invalid_price_limit_values=False,
+                                            enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 1000
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+        assert len(symbol_prices) == 0  # limit has to be set in tentacle or on candle is returns by default
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
-            with pytest.raises(errors.FailedRequest):
-                await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
-            # not supported anymore (Candlestick too long ago. Maximum 10000 points ago are allowed)
-            # symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
-            # if limit:
-            #     assert len(symbol_prices) == limit
-            # else:
-            #     assert len(symbol_prices) > 5
-            # # check candles order (oldest first)
-            # self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-            # # check that fetched candles are historical candles
-            # max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
-            # assert max_candle_time <= self.get_time()
-            # for candle in symbol_prices:
-            #     assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            if limit:
+                assert len(symbol_prices) == limit
+            else:
+                assert len(symbol_prices) > 5
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check that fetched candles are historical candles
+            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
+            assert max_candle_time <= self.get_time()
+            if limit is None:
+                with pytest.raises(AssertionError):  # not supported
+                    for candle in symbol_prices:
+                        assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
+            else:
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
@@ -113,26 +121,25 @@
         assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) > 20
+        assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        tickers = await self.get_all_currencies_price_ticker()
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
+        with pytest.raises(errors.NotSupported):
+            await self.get_all_currencies_price_ticker()
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -142,20 +149,21 @@
             Ectc.ASK_VOLUME.value,
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
-            assert ticker[Ectc.HIGH.value]
-            assert ticker[Ectc.LOW.value]
+            # todo fix in tentacle: replace 0.0 by None
+            assert ticker[Ectc.HIGH.value] is None
+            assert ticker[Ectc.LOW.value] is None
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value]
-            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
-            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_timestamp=False)
+            assert ticker[Ectc.BASE_VOLUME.value] is not None
+            assert ticker[Ectc.TIMESTAMP.value]
+            RealExchangeTester.check_ticker_typing(ticker, check_high=False, check_low=False, check_open=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_hitbtc.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_hitbtc.py`

 * *Files 6% similar despite different names*

```diff
@@ -46,15 +46,17 @@
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] < 1  # to be fixed in hitbtc tentacle
             assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] < 1  # to be fixed in hitbtc tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
@@ -93,21 +95,15 @@
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
-                # invalid max time: history is not supported
-                assert max_candle_time <= candle[PriceIndexes.IND_PRICE_TIME.value]
-
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        assert await self.get_historical_ohlcv() == []
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price(sort='DESC')  # to be fixed in hitbtc tentacle
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_hollaex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bittrex.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,74 +10,71 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
+from ccxt.async_support import bittrex
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestHollaexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "hollaex"
+class TestBittrexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bittrex"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/USDT"
-    # use one day timeframe to avoid low liquidity issues when fetching candles
-    TIME_FRAME = TimeFrames.ONE_DAY
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
+            TimeFrames.ONE_MINUTE.value,
+            TimeFrames.FIVE_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.ONE_DAY.value,
+            TimeFrames.ONE_DAY.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1.0     # to be fixed in tentacle
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1.0     # to be fixed in tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on this exchange, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            normal_price_max=30000,
-                                            normal_cost_min=1e-07,
-                                            low_price_min=0.01,  # XRP/USDT instead of /BTC
-                                            low_price_max=1,
-                                            low_cost_min=0.01,
-                                            low_cost_max=1,
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit is not supported replaced by a 500 default limit in hollaex tentacle
-        symbol_prices = await self.get_symbol_prices(limit=500)
-        assert len(symbol_prices) == 500
+        # without limit
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) >= 744
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+        # candle limit is not supported, replaced by (await self.get_symbol_prices())[-limit:] in bittrex tentacle
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=200)
+        symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
@@ -88,35 +85,42 @@
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
-            # sometimes exchange time is not sync
-            assert max_candle_time <= self.get_time_after_time_frames(self.get_time(), 1)
+            assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
+                if limit is None:
+                    assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
+                else:
+                    with pytest.raises(AssertionError):  # not supported: candles are after the max time requested
+                        assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        kline_price = await self.get_kline_price()
+        # kline_price = await self.get_kline_price()
+        client = bittrex()
+        await client.fetch_markets()
+        kline_price = [(await client.fetch_ohlcv(TestBittrexRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
+
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
+        await client.close()
 
     async def test_get_order_book(self):
-        order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) >= 10
+        # fetchOrderBook() limit argument must be None, 1, 25 or 500, default is 25
+        order_book = await self.get_order_book(limit=25)
+        assert len(order_book[Ecobic.ASKS.value]) == 25
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) >= 10
+        assert len(order_book[Ecobic.BIDS.value]) == 25
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -142,20 +146,21 @@
             Ectc.ASK_VOLUME.value,
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
-            assert ticker[Ectc.HIGH.value]
-            assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.HIGH.value] is None
+            assert ticker[Ectc.LOW.value] is None
+            assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value]
+            assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker)
+            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
+            assert ticker[Ectc.BASE_VOLUME.value] is None
+            RealExchangeTester.check_ticker_typing(ticker, check_open=False, check_high=False,
+                                                   check_low=False, check_base_volume=False, check_timestamp=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_htx.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kraken.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,130 +10,139 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
+from ccxt.async_support import kraken
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
-import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestHTXRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "htx"
+class TestKrakenRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "kraken"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
+            TimeFrames.ONE_WEEK.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
-            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on this exchange, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values => remove price limit in tentacle
-            self.check_market_status_limits(market_status, has_price_limits=False)
+            self.check_market_status_limits(market_status,
+                                            normal_cost_min=1e-07,
+                                            low_cost_min=1e-08,
+                                            expect_invalid_price_limit_values=False,
+                                            enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
         # without limit
-        # useHistoricalEndpointForSpot is required to handle limit => to add in tentacle
-        symbol_prices = await self.get_symbol_prices(useHistoricalEndpointForSpot=False)
-        assert len(symbol_prices) == 150
+        symbol_prices = await self.get_symbol_prices()
+        assert len(symbol_prices) == 720
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
+        # candle limit is not supported, replaced by (await self.get_symbol_prices())[-limit:] in kraken tentacle
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=200, useHistoricalEndpointForSpot=False)
+        symbol_prices = (await self.get_symbol_prices())[-200:]
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # without useHistoricalEndpointForSpot=False
-        useHistoricalEndpointForSpot_symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(useHistoricalEndpointForSpot_symbol_prices) == 200
-
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        kline_price = await self.get_kline_price()
+        # kline_price = await self.get_kline_price()
+        client = kraken()
+        await client.fetch_markets()
+        kline_price = [(await client.fetch_ohlcv(TestKrakenRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
+
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
+        await client.close()
 
     async def test_get_order_book(self):
+        # We should prefer using fetch_l2_order_book (from https://github.com/ccxt/ccxt/issues/8135)
         order_book = await self.get_order_book()
         assert len(order_book[Ecobic.ASKS.value]) == 5
-        assert len(order_book[Ecobic.ASKS.value][0]) == 2
+        # [price, amount, time] instead of [price, amount]
+        assert len(order_book[Ecobic.ASKS.value][0]) == 3
         assert len(order_book[Ecobic.BIDS.value]) == 5
-        assert len(order_book[Ecobic.BIDS.value][0]) == 2
+        # [price, amount, time] instead of [price, amount]
+        assert len(order_book[Ecobic.BIDS.value][0]) == 3
 
     async def test_get_recent_trades(self):
-        recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50
+        # https://github.com/ccxt/ccxt/issues/5698
+        recent_trades = await self.get_recent_trades(limit=1000)
+        assert len(recent_trades) == 1000
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        tickers = await self.get_all_currencies_price_ticker()
+        # get_all_currencies_price_ticker kraken fetchTickers() requires a symbols argument, an array of symbols
+        tickers = await self.get_all_currencies_price_ticker(symbols=[self.SYMBOL, self.SYMBOL_2])
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
@@ -148,17 +157,17 @@
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
+            assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kraken.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_wavesexchange.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,145 +10,151 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
-from ccxt.async_support import kraken
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+import octobot_trading.exchanges as exchanges
+import octobot_trading.errors as errors
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestKrakenRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "kraken"
-    SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/BTC"
-    SYMBOL_3 = "XRP/BTC"
+class TestWavesExchangeRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "wavesexchange"
+    SYMBOL = "ETH/USDT-ERC20"
+    SYMBOL_2 = "CRO-WXG/XTN"
+    SYMBOL_3 = "SHIB-WXG/XTN"
+    ALLOWED_TIMEFRAMES_WITHOUT_CANDLE = RealExchangeTester.ALLOWED_TIMEFRAMES_WITHOUT_CANDLE + 1    # account for dumped candle
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value
+            TimeFrames.ONE_WEEK.value,
+            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            normal_cost_min=1e-07,
-                                            low_cost_min=1e-08,
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit
-        symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 720
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
-
-        # candle limit is not supported, replaced by (await self.get_symbol_prices())[-limit:] in kraken tentacle
-        # try with candles limit (used in candled updater)
-        symbol_prices = (await self.get_symbol_prices())[-200:]
-        assert len(symbol_prices) == 200
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+        previous_DUMP_INCOMPLETE_LAST_CANDLE_value = exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE
+        try:
+            # todo set RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = True in exchange tentacle
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = True
+            # without limit
+            # broken because last X candles have None prices (raising TypeError)
+            with pytest.raises(errors.UnexpectedAdapterError):
+                symbol_prices = await self.get_symbol_prices()
+            return
+            assert len(symbol_prices) == 1440 - 1 or len(symbol_prices) == 1440  # last candle might be removed
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check last candle is the current candle
+            assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+
+            # try with candles limit (used in candled updater)
+            symbol_prices = await self.get_symbol_prices(limit=201)
+            assert len(symbol_prices) == 200 or len(symbol_prices) == 201  # last candle might be removed
+            # check candles order (oldest first)
+            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+            # check last candle is the current candle
+            assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
+
+        finally:
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = previous_DUMP_INCOMPLETE_LAST_CANDLE_value
 
     async def test_get_historical_symbol_prices(self):
-        # try with since and limit (used in data collector)
-        for limit in (50, None):
-            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
-            if limit:
-                assert len(symbol_prices) == limit
-            else:
-                assert len(symbol_prices) > 5
+        previous_DUMP_INCOMPLETE_LAST_CANDLE_value = exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE
+        try:
+            # todo set RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = True in exchange tentacle
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = True
+            # without limit
+            # broken because last X candles have None prices (raising TypeError)
+            # try with since and limit (used in data collector)
+            for limit in (50, None):
+                with pytest.raises(errors.UnexpectedAdapterError):
+                    symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            return
+
+            assert len(symbol_prices) == 50
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            with pytest.raises(AssertionError):  # not supported
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        ohlcv = await self.get_historical_ohlcv()
-        assert 0 < len(ohlcv) < 100
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
+        finally:
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = previous_DUMP_INCOMPLETE_LAST_CANDLE_value
 
     async def test_get_kline_price(self):
-        # kline_price = await self.get_kline_price()
-        client = kraken()
-        await client.fetch_markets()
-        kline_price = [(await client.fetch_ohlcv(TestKrakenRealExchangeTester.SYMBOL, TimeFrames.ONE_HOUR.value))[-1]]
-
-        assert len(kline_price) == 1
-        assert len(kline_price[0]) == 6
-        kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
-        # assert kline is the current candle
-        assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
-        await client.close()
+        previous_DUMP_INCOMPLETE_LAST_CANDLE_value = exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE
+        try:
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = True
+            # not supported because of exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE
+            with pytest.raises(errors.NotSupported):
+                kline_price = await self.get_kline_price(limit=2)
+                assert len(kline_price) == 1
+                assert len(kline_price[0]) == 6
+                kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
+                # assert kline is the current candle
+                assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
+        finally:
+            exchanges.RestExchange.DUMP_INCOMPLETE_LAST_CANDLE = previous_DUMP_INCOMPLETE_LAST_CANDLE_value
 
     async def test_get_order_book(self):
-        # We should prefer using fetch_l2_order_book (from https://github.com/ccxt/ccxt/issues/8135)
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
-        # [price, amount, time] instead of [price, amount]
-        assert len(order_book[Ecobic.ASKS.value][0]) == 3
-        assert len(order_book[Ecobic.BIDS.value]) == 5
-        # [price, amount, time] instead of [price, amount]
-        assert len(order_book[Ecobic.BIDS.value][0]) == 3
+        assert len(order_book[Ecobic.ASKS.value]) == 6
+        assert len(order_book[Ecobic.ASKS.value][0]) == 2
+        assert len(order_book[Ecobic.BIDS.value]) == 6
+        assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
-        # https://github.com/ccxt/ccxt/issues/5698
-        recent_trades = await self.get_recent_trades(limit=1000)
-        assert len(recent_trades) == 1000
+        recent_trades = await self.get_recent_trades()
+        assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
-    async def test_get_all_currencies_price_ticker(self):
-        # get_all_currencies_price_ticker kraken fetchTickers() requires a symbols argument, an array of symbols
-        tickers = await self.get_all_currencies_price_ticker(symbols=[self.SYMBOL, self.SYMBOL_2])
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -159,17 +165,17 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
+            assert ticker[Ectc.BID.value] is None
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value]
+            assert ticker[Ectc.ASK.value] is None
             assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kucoin.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_kucoin.py`

 * *Files 11% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 #  License along with this library.
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
@@ -50,30 +49,28 @@
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
             self.check_market_status_limits(market_status, has_price_limits=False)
-            # kucoin special value to handle to market status min cost (https://docs.kucoin.com/#get-symbols-list)
-            min_funds = market_status[ccxt_constants.CCXT_INFO].get("minFunds")
-            assert min_funds is not None
-            assert float(min_funds) > 0
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -101,17 +98,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -137,28 +131,14 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
-    async def test_get_all_currencies_price_ticker_with_market_filter(self):
-        tickers = await self.get_all_currencies_price_ticker(market_filter=self.get_market_filter())
-        assert len(tickers) > 2    # all tickers
-        assert self.SYMBOL in tickers
-        assert self.SYMBOL_2 in tickers
-        assert self.SYMBOL_3 in tickers  # symbol not correctly parsed as not in available markets (but luckily kucoin also uses the same syntax)
-        tickers = await self.get_all_currencies_price_ticker(
-            symbols=[self.SYMBOL, self.SYMBOL_2],
-            market_filter=self.get_market_filter()
-        )
-        assert list(tickers) == [self.SYMBOL, self.SYMBOL_2]    # ticker for self.SYMBOL, self.SYMBOL_2
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_kucoin_futures.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_coinbase.py`

 * *Files 18% similar despite different names*

```diff
@@ -11,156 +11,123 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-import octobot_commons.constants as commons_constants
+import octobot_trading.errors
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
-    ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
+    ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-import octobot_trading.errors as errors
-import octobot_trading.exchanges.connectors.ccxt.constants as ccxt_constants
-from tests_additional.real_exchanges.real_futures_exchange_tester import RealFuturesExchangeTester
+from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestKucoinFuturesRealExchangeTester(RealFuturesExchangeTester):
-    EXCHANGE_NAME = "kucoinfutures"
-    SYMBOL = "BTC/USDT:USDT"
-    SYMBOL_2 = "BTC/USD:BTC"
-    SYMBOL_3 = "XRP/USD:XRP"
+class TestCoinbaseRealExchangeTester(RealExchangeTester):
+    # ALL require authentication ?
+    # https://github.com/ccxt/ccxt/issues/16719
+    EXCHANGE_NAME = "coinbase"
+    SYMBOL = "BTC/USD"
+    SYMBOL_2 = "ETH/BTC"
+    SYMBOL_3 = "ADA/BTC"
+    REQUIRES_AUTH = True    # set True when even normally public apis require authentication
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
-            TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
-            TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
-            TimeFrames.TWELVE_HOURS.value,
-            TimeFrames.ONE_DAY.value,
-            TimeFrames.ONE_WEEK.value
+            TimeFrames.ONE_DAY.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on this exchange, precision is a decimal instead of a number of digits
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in coinbase tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in coinbase tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            # invalid values (should be much lower for XRP/BTC => remove price limit in tentacle
-            self.check_market_status_limits(market_status,
-                                            expect_invalid_price_limit_values=True,
-                                            enable_price_and_cost_comparison=False)
-            # ensure no "minFunds" in futures
-            assert "minFunds" not in market_status[ccxt_constants.CCXT_INFO]
+            self.check_market_status_limits(market_status, has_price_limits=False)
+
+    def _get_ohlcv_params(self, limit):
+        # to be added in tentacle
+        to_time = self.get_ms_time()
+        return {
+            "since": to_time - (self.get_timeframe_seconds() * limit * 1000),
+            "limit": limit,
+        }
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 200
+        assert len(symbol_prices) == 5
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        symbol_prices = await self.get_symbol_prices(limit=100)
-        assert len(symbol_prices) == 100
+        # max value is 299
+        with pytest.raises(octobot_trading.errors.FailedRequest):
+            await self.get_symbol_prices(**self._get_ohlcv_params(300))
+        symbol_prices = await self.get_symbol_prices(**self._get_ohlcv_params(299))
+        assert len(symbol_prices) == 299
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
-            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit) == []
-            # "to" param is required: add in tentacle
-            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, to=self.get_ms_time())
-            if limit:
-                assert len(symbol_prices) == limit
-                real_limit = \
-                    self.get_time_after_time_frames(self.CANDLE_SINCE, limit) * commons_constants.MSECONDS_TO_SECONDS
-                symbol_prices_real = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, to=real_limit)
-                assert symbol_prices_real == symbol_prices
-            else:
-                assert len(symbol_prices) > 5
-            # check candles order (oldest first)
-            self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-            # check that fetched candles are historical candles
-            max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
-            assert max_candle_time <= self.get_time()
-            with pytest.raises(AssertionError):  # not supported
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(octobot_trading.errors.FailedRequest):
+                await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)    # not supported
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        # kucoin requires a limit of None, 20 or 100 in order book
-        order_book = await self.get_order_book(limit=20)
-        assert len(order_book[Ecobic.ASKS.value]) == 20
-        assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 20
-        assert len(order_book[Ecobic.BIDS.value][0]) == 2
+        with pytest.raises(octobot_trading.errors.NotSupported):
+            await self.get_order_book()
 
     async def test_get_recent_trades(self):
-        # note: on ccxt kucoin recent trades are received in reverse order from exchange and therefore should never be
-        # filtered by limit before reversing (or most recent trades are lost)
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
-    async def test_get_funding_rate(self):
-        funding_rate, ticker_funding_rate = await self.get_funding_rate()
-        # patch NEXT_FUNDING_TIME & LAST_FUNDING_TIME in tentacle
-        self._check_funding_rate(funding_rate, has_next_time_in_the_past=True, has_last_time=False)
-        # no funding info in ticker
-        self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
-                                 has_next_rate=False, has_next_time=False)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
@@ -172,20 +139,20 @@
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value] is None
             assert ticker[Ectc.LOW.value] is None
             assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
+            assert ticker[Ectc.BID_VOLUME.value] is None
             assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value] is None
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value] is None
-            assert ticker[Ectc.TIMESTAMP.value]
-            RealFuturesExchangeTester.check_ticker_typing(
+            assert ticker[Ectc.TIMESTAMP.value] is None  # will trigger an 'Ignored incomplete ticker'
+            RealExchangeTester.check_ticker_typing(
                 ticker,
-                check_open=False, check_low=False, check_high=False, check_base_volume=False
+                check_open=False, check_high=False, check_low=False, check_timestamp=False, check_base_volume=False
             )
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_mexc.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okx.py`

 * *Files 10% similar despite different names*

```diff
@@ -23,55 +23,61 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestMEXCRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "mexc"
+class TestOkxRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "okx"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
+            TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.HEIGHT_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 1e-06 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in tentacle
-            assert 1e-09 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1   # to be fixed in tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
+            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(
-                market_status,
-                has_price_limits=False
-            )
+            self.check_market_status_limits(market_status,
+                                            normal_cost_min=1e-09,
+                                            low_cost_min=1e-08,
+                                            expect_invalid_price_limit_values=False,
+                                            enable_price_and_cost_comparison=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 500
+        assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
@@ -93,17 +99,14 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -113,15 +116,15 @@
         assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) >= 20
+        assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
@@ -151,11 +154,11 @@
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value]
             assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
-            assert ticker[Ectc.PREVIOUS_CLOSE.value]
+            assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_ndax.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitfinex.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,81 +9,94 @@
 #  This library is distributed in the hope that it will be useful,
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
+import asyncio
+
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
-import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestNdaxRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "ndax"
-    SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/CAD"
-    SYMBOL_3 = "XRP/CAD"
+class TestBitfinexRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bitfinex2"
+    SYMBOL = "BTC/USD"
+    SYMBOL_2 = "ETH/BTC"
+    SYMBOL_3 = "XRP/BTC"
+    DEFAULT_CANDLE_LIMIT = 100
+    SLEEP_TIME = 10
 
     async def test_time_frames(self):
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             self.check_market_status_limits(market_status,
-                                            low_price_max=1e-03,
-                                            low_price_min=1e-05,
-                                            normal_cost_min=1e-07,
-                                            low_cost_max=1e-02,
-                                            low_cost_min=1e-04,
+                                            normal_price_min=1e-08,
+                                            normal_cost_min=1e-13,  # weirdly low value
+                                            low_cost_min=1e-08,  # higher min cost on lower prices, makes no sense
+                                            # but is compatible
                                             expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False)
+                                            enable_price_and_cost_comparison=False    # because of low cose value in
+                                            # normal prices but not in low ones
+                                            )
 
     async def test_get_symbol_prices(self):
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 0  # limit has to be set in tentacle or on candle is returns by default
+        # no idea why 4 candles less than asked for but it seems to be a bitfinex issue
+        candle_limit_error = 4
+        assert self.DEFAULT_CANDLE_LIMIT >= len(symbol_prices) >= self.DEFAULT_CANDLE_LIMIT - candle_limit_error
+        # check candles order (oldest first)
+        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
+        # check last candle is the current candle
+        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
-        assert len(symbol_prices) == 200
+        assert 200 >= len(symbol_prices) >= 200 - candle_limit_error
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
@@ -94,53 +107,53 @@
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            if limit is None:
-                with pytest.raises(AssertionError):  # not supported
-                    for candle in symbol_prices:
-                        assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-            else:
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
+        # await asyncio.sleep(10) # prevent rate api limit
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
-        order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 5
-        assert len(order_book[Ecobic.ASKS.value][0]) == 3
-        assert len(order_book[Ecobic.BIDS.value]) == 5
-        assert len(order_book[Ecobic.BIDS.value][0]) == 3
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
+        # bitfinex2 only supports 1, 25 and 100 size
+        # https://docs.bitfinex.com/reference#rest-public-book
+        order_book = await self.get_order_book(limit=25)
+        assert len(order_book[Ecobic.ASKS.value]) == 25
+        assert len(order_book[Ecobic.ASKS.value][0]) == 2
+        assert len(order_book[Ecobic.BIDS.value]) == 25
+        assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         recent_trades = await self.get_recent_trades()
-        assert len(recent_trades) == 50
+        assert len(recent_trades) == 50  # broken after ccxt 2.4.60 (trade symbol parsing issue), still the case in 2.8.4
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
     async def test_get_price_ticker(self):
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
         ticker = await self.get_price_ticker()
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
-        with pytest.raises(errors.NotSupported):
-            await self.get_all_currencies_price_ticker()
+        await asyncio.sleep(self.SLEEP_TIME)  # prevent rate api limit
+        tickers = await self.get_all_currencies_price_ticker()
+        for symbol, ticker in tickers.items():
+            self._check_ticker(ticker, symbol)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
@@ -150,21 +163,21 @@
             Ectc.ASK_VOLUME.value,
             Ectc.OPEN.value,
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
-            # todo fix in tentacle: replace 0.0 by None
-            assert ticker[Ectc.HIGH.value] is None
-            assert ticker[Ectc.LOW.value] is None
+            assert ticker[Ectc.HIGH.value]
+            assert ticker[Ectc.LOW.value]
             assert ticker[Ectc.BID.value]
             assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK.value]
             assert ticker[Ectc.ASK_VOLUME.value] is None
-            assert ticker[Ectc.OPEN.value] is None
+            assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
-            assert ticker[Ectc.BASE_VOLUME.value] is not None
+            assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
-            RealExchangeTester.check_ticker_typing(ticker, check_high=False, check_low=False, check_open=False)
+            # open is None on this exchange
+            RealExchangeTester.check_ticker_typing(ticker, check_open=False)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okcoin.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okcoin.py`

 * *Files 13% similar despite different names*

```diff
@@ -29,15 +29,17 @@
     EXCHANGE_NAME = "okcoin"
     SYMBOL = "BTC/USD"
     SYMBOL_2 = "ETH/USD"
     SYMBOL_3 = "NYC/USD"
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okx.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitget.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,121 +16,122 @@
 import pytest
 
 from octobot_commons.enums import TimeFrames, PriceIndexes
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
+from tests_additional.real_exchanges import get_exchange_manager
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestOkxRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "okx"
+class TestBitgetRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bitget"
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
-            TimeFrames.THREE_MINUTES.value,
-            TimeFrames.FIVE_MINUTES.value,
+            # TimeFrames.THREE_MINUTES.value,
+            # TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
-            TimeFrames.TWO_HOURS.value,
+            # TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
-            TimeFrames.SIX_HOURS.value,
+            # TimeFrames.SIX_HOURS.value,
+            # TimeFrames.HEIGHT_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
+            # TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
+            # TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] < 1   # to be fixed in tentacle
-            assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on Bitget, precision is a decimal instead of a number of digits
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_AMOUNT.value] < 1  # to be fixed in Bitget tentacle
+            assert 0 < market_status[Ecmsc.PRECISION.value][
+                Ecmsc.PRECISION_PRICE.value] < 1  # to be fixed in Bitget tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            normal_cost_min=1e-09,
-                                            low_cost_min=1e-08,
-                                            expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=False,
-                                            has_price_limits=False)
+            for val in (Ecmsc.LIMITS_PRICE_MIN.value, Ecmsc.LIMITS_PRICE_MAX.value):
+                assert market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_PRICE.value][val] is None
+            # wtf value, to fix in tentacle
+            for val in (Ecmsc.LIMITS_COST_MIN.value, Ecmsc.LIMITS_COST_MAX.value):
+                assert market_status[Ecmsc.LIMITS.value][Ecmsc.LIMITS_COST.value][val] in (None, 0, 5)
+            # can't use normal checker
+            # self.check_market_status_limits(market_status, expect_invalid_price_limit_values=True)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 100
+        assert len(symbol_prices) == 1000
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
+        symbol_prices = await self.get_symbol_prices(limit=50)
+        assert len(symbol_prices) == 50
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # max candles is 300 (unliked stated on docs which says 100)
-        symbol_prices = await self.get_symbol_prices(limit=1000)
-        assert len(symbol_prices) == 300
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
-
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
-            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
+            assert await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit) == []
+            # with now time as until: does not give historical candles
+            symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit, until=self.get_ms_time())
             if limit:
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            with pytest.raises(AssertionError):  # not supported
+                for candle in symbol_prices:
+                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
         assert len(order_book[Ecobic.ASKS.value]) == 5
-        assert len(order_book[Ecobic.ASKS.value][0]) == 3
+        assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
-        assert len(order_book[Ecobic.BIDS.value][0]) == 3
+        assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
@@ -139,28 +140,14 @@
         self._check_ticker(ticker, self.SYMBOL, check_content=True)
 
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
-    async def test_get_all_currencies_price_ticker_with_market_filter(self):
-        tickers = await self.get_all_currencies_price_ticker(market_filter=self.get_market_filter())
-        assert len(tickers) > 2    # all tickers
-        assert self.SYMBOL in tickers
-        assert self.SYMBOL_2 in tickers
-        assert self.SYMBOL_3 in tickers  # symbol not correctly parsed as not in available markets (but luckily okx also uses the same syntax)
-        tickers = await self.get_all_currencies_price_ticker(
-            symbols=[self.SYMBOL, self.SYMBOL_2],
-            market_filter=self.get_market_filter()
-        )
-        assert list(tickers) == [self.SYMBOL, self.SYMBOL_2]    # ticker for self.SYMBOL, self.SYMBOL_2
-        for symbol, ticker in tickers.items():
-            self._check_ticker(ticker, symbol)
-
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
         assert all(key in ticker for key in (
             Ectc.HIGH.value,
             Ectc.LOW.value,
             Ectc.BID.value,
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_okx_futures.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_okx_futures.py`

 * *Files 6% similar despite different names*

```diff
@@ -49,28 +49,29 @@
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1   # to be fixed in tentacle
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] <= 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
             self.check_market_status_limits(market_status,
                                             low_price_max=1e-05,
                                             expect_invalid_price_limit_values=False,
-                                            enable_price_and_cost_comparison=True,
-                                            has_price_limits=False)
+                                            enable_price_and_cost_comparison=True)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
         assert len(symbol_prices) == 100
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
@@ -81,22 +82,14 @@
         symbol_prices = await self.get_symbol_prices(limit=200)
         assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
-        # max candles is 300 (unliked stated on docs which says 100)
-        symbol_prices = await self.get_symbol_prices(limit=1000)
-        assert len(symbol_prices) == 300
-        # check candles order (oldest first)
-        self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
-        # check last candle is the current candle
-        assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
-
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
                 assert len(symbol_prices) == limit
             else:
@@ -105,31 +98,28 @@
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
                 assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
         assert len(order_book[Ecobic.ASKS.value]) == 5
-        assert len(order_book[Ecobic.ASKS.value][0]) == 3
+        assert len(order_book[Ecobic.ASKS.value][0]) == 2
         assert len(order_book[Ecobic.BIDS.value]) == 5
-        assert len(order_book[Ecobic.BIDS.value][0]) == 3
+        assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
 
@@ -140,16 +130,16 @@
     async def test_get_all_currencies_price_ticker(self):
         tickers = await self.get_all_currencies_price_ticker()
         for symbol, ticker in tickers.items():
             self._check_ticker(ticker, symbol)
 
     async def test_get_funding_rate(self):
         funding_rate, ticker_funding_rate = await self.get_funding_rate()
-        # patch LAST_FUNDING_TIME in tentacle
-        self._check_funding_rate(funding_rate, has_last_time=False)
+        # patch FUNDING_RATE and LAST_FUNDING_TIME in tentacle
+        self._check_funding_rate(funding_rate, has_rate=False, has_last_time=False)
         # no funding info in ticker
         self._check_funding_rate(ticker_funding_rate, has_rate=False, has_last_time=False,
                                  has_next_rate=False, has_next_time=False)
 
     @staticmethod
     def _check_ticker(ticker, symbol, check_content=False):
         assert ticker[Ectc.SYMBOL.value] == symbol
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_phemex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_bitstamp.py`

 * *Files 15% similar despite different names*

```diff
@@ -11,138 +11,112 @@
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #  Lesser General Public License for more details.
 #
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with this library.
 import pytest
 
-from octobot_commons.enums import TimeFrames, PriceIndexes, TimeFramesMinutes
+from octobot_commons.enums import TimeFrames, PriceIndexes
+import octobot_trading.errors as errors
 from octobot_trading.enums import ExchangeConstantsMarketStatusColumns as Ecmsc, \
     ExchangeConstantsOrderBookInfoColumns as Ecobic, ExchangeConstantsOrderColumns as Ecoc, \
     ExchangeConstantsTickersColumns as Ectc
-import octobot_trading.errors as errors
 from tests_additional.real_exchanges.real_exchange_tester import RealExchangeTester
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestPhemexRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "phemex"
-    SYMBOL = "BTC/USDT"
-    SYMBOL_2 = "ETH/USDT"
-    SYMBOL_3 = "XRP/USDT"
-    ALLOWED_TIMEFRAMES_WITHOUT_CANDLE = 1   # low liquidity on spot trading
+class TestBitstampRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "bitstamp"
+    SYMBOL = "BTC/USD"
+    SYMBOL_2 = "ETH/BTC"
+    SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
             TimeFrames.TWO_HOURS.value,
-            TimeFrames.THREE_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.SIX_HOURS.value,
             TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
             TimeFrames.ONE_WEEK.value,
-            TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on Phemex, precision is a decimal instead of a number of digits
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            # on this exchange, precision is a decimal instead of a number of digits
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in Phemex tentacle
+                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
             assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in Phemex tentacle
+                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status,
-                                            low_price_min=1e-05,  # XRP/USDT instead of /BTC
-                                            low_price_max=1e-04,
-                                            low_cost_min=0.01,
-                                            low_cost_max=1,
-                                            expect_invalid_price_limit_values=False)
+            self.check_market_status_limits(market_status, has_price_limits=False)
 
     async def test_get_symbol_prices(self):
-        # without limit
-        symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 1000
-        symbol_prices = await self.get_symbol_prices(limit=100)
-        assert len(symbol_prices) == 100
+        # without limit is not supported replaced by a 500 default limit in bitstamp tentacle
         symbol_prices = await self.get_symbol_prices(limit=500)
         assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
-        # to be fixed in tentacle
-        # WARNING some limits are not allowed, see https://phemex-docs.github.io/#query-kline
-        with pytest.raises(errors.FailedRequest):
-            await self.get_symbol_prices(limit=200)
-
-        symbol_prices = await self.get_symbol_prices(limit=1000)
-        assert len(symbol_prices) == 1000
+        symbol_prices = await self.get_symbol_prices(limit=200)
+        assert len(symbol_prices) == 200
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
-        for limit in (100, None):
+        for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
                 assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             for candle in symbol_prices:
-                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value]
-                with pytest.raises(AssertionError):  # not supported: candles are after the max time requested
-                    assert candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        ohlcv = await self.get_historical_ohlcv()
-        assert 0 < len(ohlcv) < 400
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
-        with pytest.raises(errors.FailedRequest):
-            await self.get_kline_price()
-
-        # to be fixed in tentacle: use get_symbol_prices to comply with allowed limits
-        kline_price = (await self.get_symbol_prices(limit=5))[-1:]
+        kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 30
+        assert len(order_book[Ecobic.ASKS.value]) >= 2000
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 30
+        assert len(order_book[Ecobic.BIDS.value]) >= 2000
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_poloniex.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_poloniex.py`

 * *Files 2% similar despite different names*

```diff
@@ -43,15 +43,17 @@
             TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
             TimeFrames.ONE_DAY.value,
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_AMOUNT.value] <= 1   # to be fixed in tentacle
             assert 1e-08 <= market_status[Ecmsc.PRECISION.value][
                 Ecmsc.PRECISION_PRICE.value] < 1    # to be fixed in tentacle
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
@@ -89,18 +91,14 @@
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
             with pytest.raises(AssertionError):  # not supported
                 for candle in symbol_prices:
                     assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
-    async def test_get_historical_ohlcv(self):
-        # not supported
-        assert await self.get_historical_ohlcv() == []
-
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
@@ -141,18 +139,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value]
-            assert ticker[Ectc.BID_VOLUME.value]
-            assert ticker[Ectc.ASK.value]
-            assert ticker[Ectc.ASK_VOLUME.value]
+            assert ticker[Ectc.BID.value] is None
+            assert ticker[Ectc.BID_VOLUME.value] is None
+            assert ticker[Ectc.ASK.value] is None
+            assert ticker[Ectc.ASK_VOLUME.value] is None
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value] is None
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

### Comparing `OctoBot-Trading-2.4.85/tests_additional/real_exchanges/test_upbit.py` & `OctoBot-Trading-2.4.9/tests_additional/real_exchanges/test_binance.py`

 * *Files 8% similar despite different names*

```diff
@@ -23,53 +23,59 @@
 # required to catch async loop context exceptions
 from tests import event_loop
 
 # All test coroutines will be treated as marked.
 pytestmark = pytest.mark.asyncio
 
 
-class TestUpbitRealExchangeTester(RealExchangeTester):
-    EXCHANGE_NAME = "upbit"
+class TestBinanceRealExchangeTester(RealExchangeTester):
+    EXCHANGE_NAME = "binanceus"  # use binanceus for tests as binance is blocked in the us
     SYMBOL = "BTC/USDT"
     SYMBOL_2 = "ETH/BTC"
     SYMBOL_3 = "XRP/BTC"
 
     async def test_time_frames(self):
         time_frames = await self.time_frames()
         assert all(time_frame in time_frames for time_frame in (
             TimeFrames.ONE_MINUTE.value,
             TimeFrames.THREE_MINUTES.value,
             TimeFrames.FIVE_MINUTES.value,
             TimeFrames.FIFTEEN_MINUTES.value,
             TimeFrames.THIRTY_MINUTES.value,
             TimeFrames.ONE_HOUR.value,
+            TimeFrames.TWO_HOURS.value,
             TimeFrames.FOUR_HOURS.value,
+            TimeFrames.SIX_HOURS.value,
+            TimeFrames.HEIGHT_HOURS.value,
+            TimeFrames.TWELVE_HOURS.value,
             TimeFrames.ONE_DAY.value,
+            TimeFrames.THREE_DAYS.value,
             TimeFrames.ONE_WEEK.value,
             TimeFrames.ONE_MONTH.value
         ))
 
     async def test_get_market_status(self):
         for market_status in await self.get_market_statuses():
-            self.ensure_required_market_status_values(market_status)
-            # on this exchange, precision is a decimal instead of a number of digits
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_AMOUNT.value] <= 1  # to be fixed in this exchange tentacle
-            assert 0 < market_status[Ecmsc.PRECISION.value][
-                Ecmsc.PRECISION_PRICE.value] <= 1  # to be fixed in this exchange tentacle
+            assert market_status
+            assert market_status[Ecmsc.SYMBOL.value] in (self.SYMBOL, self.SYMBOL_2, self.SYMBOL_3)
+            assert market_status[Ecmsc.PRECISION.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_AMOUNT.value]
+            assert int(market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]) == \
+                   market_status[Ecmsc.PRECISION.value][Ecmsc.PRECISION_PRICE.value]
             assert all(elem in market_status[Ecmsc.LIMITS.value]
                        for elem in (Ecmsc.LIMITS_AMOUNT.value,
                                     Ecmsc.LIMITS_PRICE.value,
                                     Ecmsc.LIMITS_COST.value))
-            self.check_market_status_limits(market_status, has_price_limits=False)
+            self.check_market_status_limits(market_status, expect_invalid_price_limit_values=False)
 
     async def test_get_symbol_prices(self):
         # without limit
         symbol_prices = await self.get_symbol_prices()
-        assert len(symbol_prices) == 200
+        assert len(symbol_prices) == 500
         # check candles order (oldest first)
         self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
         # check last candle is the current candle
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
         # try with candles limit (used in candled updater)
         symbol_prices = await self.get_symbol_prices(limit=200)
@@ -80,42 +86,38 @@
         assert symbol_prices[-1][PriceIndexes.IND_PRICE_TIME.value] >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_historical_symbol_prices(self):
         # try with since and limit (used in data collector)
         for limit in (50, None):
             symbol_prices = await self.get_symbol_prices(since=self.CANDLE_SINCE, limit=limit)
             if limit:
-                assert limit - 2 <= len(symbol_prices) <= limit  # no idea why but it happens
+                assert len(symbol_prices) == limit
             else:
                 assert len(symbol_prices) > 5
             # check candles order (oldest first)
             self.ensure_elements_order(symbol_prices, PriceIndexes.IND_PRICE_TIME.value)
             # check that fetched candles are historical candles
             max_candle_time = self.get_time_after_time_frames(self.CANDLE_SINCE_SEC, len(symbol_prices))
             assert max_candle_time <= self.get_time()
-            with pytest.raises(AssertionError):  # not supported
-                for candle in symbol_prices:
-                    assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
-
-    async def test_get_historical_ohlcv(self):
-        await super().test_get_historical_ohlcv()
+            for candle in symbol_prices:
+                assert self.CANDLE_SINCE_SEC <= candle[PriceIndexes.IND_PRICE_TIME.value] <= max_candle_time
 
     async def test_get_kline_price(self):
         kline_price = await self.get_kline_price()
         assert len(kline_price) == 1
         assert len(kline_price[0]) == 6
         kline_start_time = kline_price[0][PriceIndexes.IND_PRICE_TIME.value]
         # assert kline is the current candle
         assert kline_start_time >= self.get_time() - self.get_allowed_time_delta()
 
     async def test_get_order_book(self):
         order_book = await self.get_order_book()
-        assert len(order_book[Ecobic.ASKS.value]) == 15
+        assert len(order_book[Ecobic.ASKS.value]) == 5
         assert len(order_book[Ecobic.ASKS.value][0]) == 2
-        assert len(order_book[Ecobic.BIDS.value]) == 15
+        assert len(order_book[Ecobic.BIDS.value]) == 5
         assert len(order_book[Ecobic.BIDS.value][0]) == 2
 
     async def test_get_recent_trades(self):
         recent_trades = await self.get_recent_trades()
         assert len(recent_trades) == 50
         # check trades order (oldest first)
         self.ensure_elements_order(recent_trades, Ecoc.TIMESTAMP.value)
@@ -143,18 +145,18 @@
             Ectc.CLOSE.value,
             Ectc.LAST.value,
             Ectc.PREVIOUS_CLOSE.value
         ))
         if check_content:
             assert ticker[Ectc.HIGH.value]
             assert ticker[Ectc.LOW.value]
-            assert ticker[Ectc.BID.value] is None
-            assert ticker[Ectc.BID_VOLUME.value] is None
-            assert ticker[Ectc.ASK.value] is None
-            assert ticker[Ectc.ASK_VOLUME.value] is None
+            assert ticker[Ectc.BID.value]
+            assert ticker[Ectc.BID_VOLUME.value]
+            assert ticker[Ectc.ASK.value]
+            assert ticker[Ectc.ASK_VOLUME.value]
             assert ticker[Ectc.OPEN.value]
             assert ticker[Ectc.CLOSE.value]
             assert ticker[Ectc.LAST.value]
             assert ticker[Ectc.PREVIOUS_CLOSE.value]
             assert ticker[Ectc.BASE_VOLUME.value]
             assert ticker[Ectc.TIMESTAMP.value]
             RealExchangeTester.check_ticker_typing(ticker)
```

